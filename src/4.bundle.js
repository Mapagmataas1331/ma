"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkma_"] = self["webpackChunkma_"] || []).push([[4],{

/***/ 12:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataSnapshot\": () => (/* binding */ DataSnapshot),\n/* harmony export */   \"Database\": () => (/* binding */ Database),\n/* harmony export */   \"OnDisconnect\": () => (/* binding */ OnDisconnect),\n/* harmony export */   \"QueryConstraint\": () => (/* binding */ QueryConstraint),\n/* harmony export */   \"TransactionResult\": () => (/* binding */ TransactionResult),\n/* harmony export */   \"_QueryImpl\": () => (/* binding */ QueryImpl),\n/* harmony export */   \"_QueryParams\": () => (/* binding */ QueryParams),\n/* harmony export */   \"_ReferenceImpl\": () => (/* binding */ ReferenceImpl),\n/* harmony export */   \"_TEST_ACCESS_forceRestClient\": () => (/* binding */ forceRestClient),\n/* harmony export */   \"_TEST_ACCESS_hijackHash\": () => (/* binding */ hijackHash),\n/* harmony export */   \"_repoManagerDatabaseFromApp\": () => (/* binding */ repoManagerDatabaseFromApp),\n/* harmony export */   \"_setSDKVersion\": () => (/* binding */ setSDKVersion),\n/* harmony export */   \"_validatePathString\": () => (/* binding */ validatePathString),\n/* harmony export */   \"_validateWritablePath\": () => (/* binding */ validateWritablePath),\n/* harmony export */   \"child\": () => (/* binding */ child),\n/* harmony export */   \"connectDatabaseEmulator\": () => (/* binding */ connectDatabaseEmulator),\n/* harmony export */   \"enableLogging\": () => (/* binding */ enableLogging),\n/* harmony export */   \"endAt\": () => (/* binding */ endAt),\n/* harmony export */   \"endBefore\": () => (/* binding */ endBefore),\n/* harmony export */   \"equalTo\": () => (/* binding */ equalTo),\n/* harmony export */   \"forceLongPolling\": () => (/* binding */ forceLongPolling),\n/* harmony export */   \"forceWebSockets\": () => (/* binding */ forceWebSockets),\n/* harmony export */   \"get\": () => (/* binding */ get),\n/* harmony export */   \"getDatabase\": () => (/* binding */ getDatabase),\n/* harmony export */   \"goOffline\": () => (/* binding */ goOffline),\n/* harmony export */   \"goOnline\": () => (/* binding */ goOnline),\n/* harmony export */   \"increment\": () => (/* binding */ increment),\n/* harmony export */   \"limitToFirst\": () => (/* binding */ limitToFirst),\n/* harmony export */   \"limitToLast\": () => (/* binding */ limitToLast),\n/* harmony export */   \"off\": () => (/* binding */ off),\n/* harmony export */   \"onChildAdded\": () => (/* binding */ onChildAdded),\n/* harmony export */   \"onChildChanged\": () => (/* binding */ onChildChanged),\n/* harmony export */   \"onChildMoved\": () => (/* binding */ onChildMoved),\n/* harmony export */   \"onChildRemoved\": () => (/* binding */ onChildRemoved),\n/* harmony export */   \"onDisconnect\": () => (/* binding */ onDisconnect),\n/* harmony export */   \"onValue\": () => (/* binding */ onValue),\n/* harmony export */   \"orderByChild\": () => (/* binding */ orderByChild),\n/* harmony export */   \"orderByKey\": () => (/* binding */ orderByKey),\n/* harmony export */   \"orderByPriority\": () => (/* binding */ orderByPriority),\n/* harmony export */   \"orderByValue\": () => (/* binding */ orderByValue),\n/* harmony export */   \"push\": () => (/* binding */ push),\n/* harmony export */   \"query\": () => (/* binding */ query),\n/* harmony export */   \"ref\": () => (/* binding */ ref),\n/* harmony export */   \"refFromURL\": () => (/* binding */ refFromURL),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"runTransaction\": () => (/* binding */ runTransaction),\n/* harmony export */   \"serverTimestamp\": () => (/* binding */ serverTimestamp),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"setPriority\": () => (/* binding */ setPriority),\n/* harmony export */   \"setWithPriority\": () => (/* binding */ setWithPriority),\n/* harmony export */   \"startAfter\": () => (/* binding */ startAfter),\n/* harmony export */   \"startAt\": () => (/* binding */ startAt),\n/* harmony export */   \"update\": () => (/* binding */ update)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);\n\n\n\n\n\nconst name = \"@firebase/database\";\nconst version = \"0.14.4\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** The semver (www.semver.org) version of the SDK. */\r\nlet SDK_VERSION = '';\r\n/**\r\n * SDK_VERSION should be set before any database instance is created\r\n * @internal\r\n */\r\nfunction setSDKVersion(version) {\r\n    SDK_VERSION = version;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Wraps a DOM Storage object and:\r\n * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.\r\n * - prefixes names with \"firebase:\" to avoid collisions with app data.\r\n *\r\n * We automatically (see storage.js) create two such wrappers, one for sessionStorage,\r\n * and one for localStorage.\r\n *\r\n */\r\nclass DOMStorageWrapper {\r\n    /**\r\n     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)\r\n     */\r\n    constructor(domStorage_) {\r\n        this.domStorage_ = domStorage_;\r\n        // Use a prefix to avoid collisions with other stuff saved by the app.\r\n        this.prefix_ = 'firebase:';\r\n    }\r\n    /**\r\n     * @param key - The key to save the value under\r\n     * @param value - The value being stored, or null to remove the key.\r\n     */\r\n    set(key, value) {\r\n        if (value == null) {\r\n            this.domStorage_.removeItem(this.prefixedName_(key));\r\n        }\r\n        else {\r\n            this.domStorage_.setItem(this.prefixedName_(key), (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(value));\r\n        }\r\n    }\r\n    /**\r\n     * @returns The value that was stored under this key, or null\r\n     */\r\n    get(key) {\r\n        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));\r\n        if (storedVal == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(storedVal);\r\n        }\r\n    }\r\n    remove(key) {\r\n        this.domStorage_.removeItem(this.prefixedName_(key));\r\n    }\r\n    prefixedName_(name) {\r\n        return this.prefix_ + name;\r\n    }\r\n    toString() {\r\n        return this.domStorage_.toString();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory storage implementation that matches the API of DOMStorageWrapper\r\n * (TODO: create interface for both to implement).\r\n */\r\nclass MemoryStorage {\r\n    constructor() {\r\n        this.cache_ = {};\r\n        this.isInMemoryStorage = true;\r\n    }\r\n    set(key, value) {\r\n        if (value == null) {\r\n            delete this.cache_[key];\r\n        }\r\n        else {\r\n            this.cache_[key] = value;\r\n        }\r\n    }\r\n    get(key) {\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.cache_, key)) {\r\n            return this.cache_[key];\r\n        }\r\n        return null;\r\n    }\r\n    remove(key) {\r\n        delete this.cache_[key];\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.\r\n * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change\r\n * to reflect this type\r\n *\r\n * @param domStorageName - Name of the underlying storage object\r\n *   (e.g. 'localStorage' or 'sessionStorage').\r\n * @returns Turning off type information until a common interface is defined.\r\n */\r\nconst createStoragefor = function (domStorageName) {\r\n    try {\r\n        // NOTE: just accessing \"localStorage\" or \"window['localStorage']\" may throw a security exception,\r\n        // so it must be inside the try/catch.\r\n        if (typeof window !== 'undefined' &&\r\n            typeof window[domStorageName] !== 'undefined') {\r\n            // Need to test cache. Just because it's here doesn't mean it works\r\n            const domStorage = window[domStorageName];\r\n            domStorage.setItem('firebase:sentinel', 'cache');\r\n            domStorage.removeItem('firebase:sentinel');\r\n            return new DOMStorageWrapper(domStorage);\r\n        }\r\n    }\r\n    catch (e) { }\r\n    // Failed to create wrapper.  Just return in-memory storage.\r\n    // TODO: log?\r\n    return new MemoryStorage();\r\n};\r\n/** A storage object that lasts across sessions */\r\nconst PersistentStorage = createStoragefor('localStorage');\r\n/** A storage object that only lasts one session */\r\nconst SessionStorage = createStoragefor('sessionStorage');\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/database');\r\n/**\r\n * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).\r\n */\r\nconst LUIDGenerator = (function () {\r\n    let id = 1;\r\n    return function () {\r\n        return id++;\r\n    };\r\n})();\r\n/**\r\n * Sha1 hash of the input string\r\n * @param str - The string to hash\r\n * @returns {!string} The resulting hash\r\n */\r\nconst sha1 = function (str) {\r\n    const utf8Bytes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringToByteArray)(str);\r\n    const sha1 = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Sha1();\r\n    sha1.update(utf8Bytes);\r\n    const sha1Bytes = sha1.digest();\r\n    return _firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64.encodeByteArray(sha1Bytes);\r\n};\r\nconst buildLogMessage_ = function (...varArgs) {\r\n    let message = '';\r\n    for (let i = 0; i < varArgs.length; i++) {\r\n        const arg = varArgs[i];\r\n        if (Array.isArray(arg) ||\r\n            (arg &&\r\n                typeof arg === 'object' &&\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                typeof arg.length === 'number')) {\r\n            message += buildLogMessage_.apply(null, arg);\r\n        }\r\n        else if (typeof arg === 'object') {\r\n            message += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(arg);\r\n        }\r\n        else {\r\n            message += arg;\r\n        }\r\n        message += ' ';\r\n    }\r\n    return message;\r\n};\r\n/**\r\n * Use this for all debug messages in Firebase.\r\n */\r\nlet logger = null;\r\n/**\r\n * Flag to check for log availability on first log message\r\n */\r\nlet firstLog_ = true;\r\n/**\r\n * The implementation of Firebase.enableLogging (defined here to break dependencies)\r\n * @param logger_ - A flag to turn on logging, or a custom logger\r\n * @param persistent - Whether or not to persist logging settings across refreshes\r\n */\r\nconst enableLogging$1 = function (logger_, persistent) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!persistent || logger_ === true || logger_ === false, \"Can't turn on custom loggers persistently.\");\r\n    if (logger_ === true) {\r\n        logClient.logLevel = _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.VERBOSE;\r\n        logger = logClient.log.bind(logClient);\r\n        if (persistent) {\r\n            SessionStorage.set('logging_enabled', true);\r\n        }\r\n    }\r\n    else if (typeof logger_ === 'function') {\r\n        logger = logger_;\r\n    }\r\n    else {\r\n        logger = null;\r\n        SessionStorage.remove('logging_enabled');\r\n    }\r\n};\r\nconst log = function (...varArgs) {\r\n    if (firstLog_ === true) {\r\n        firstLog_ = false;\r\n        if (logger === null && SessionStorage.get('logging_enabled') === true) {\r\n            enableLogging$1(true);\r\n        }\r\n    }\r\n    if (logger) {\r\n        const message = buildLogMessage_.apply(null, varArgs);\r\n        logger(message);\r\n    }\r\n};\r\nconst logWrapper = function (prefix) {\r\n    return function (...varArgs) {\r\n        log(prefix, ...varArgs);\r\n    };\r\n};\r\nconst error = function (...varArgs) {\r\n    const message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_(...varArgs);\r\n    logClient.error(message);\r\n};\r\nconst fatal = function (...varArgs) {\r\n    const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;\r\n    logClient.error(message);\r\n    throw new Error(message);\r\n};\r\nconst warn = function (...varArgs) {\r\n    const message = 'FIREBASE WARNING: ' + buildLogMessage_(...varArgs);\r\n    logClient.warn(message);\r\n};\r\n/**\r\n * Logs a warning if the containing page uses https. Called when a call to new Firebase\r\n * does not use https.\r\n */\r\nconst warnIfPageIsSecure = function () {\r\n    // Be very careful accessing browser globals. Who knows what may or may not exist.\r\n    if (typeof window !== 'undefined' &&\r\n        window.location &&\r\n        window.location.protocol &&\r\n        window.location.protocol.indexOf('https:') !== -1) {\r\n        warn('Insecure Firebase access from a secure page. ' +\r\n            'Please use https in calls to new Firebase().');\r\n    }\r\n};\r\n/**\r\n * Returns true if data is NaN, or +/- Infinity.\r\n */\r\nconst isInvalidJSONNumber = function (data) {\r\n    return (typeof data === 'number' &&\r\n        (data !== data || // NaN\r\n            data === Number.POSITIVE_INFINITY ||\r\n            data === Number.NEGATIVE_INFINITY));\r\n};\r\nconst executeWhenDOMReady = function (fn) {\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)() || document.readyState === 'complete') {\r\n        fn();\r\n    }\r\n    else {\r\n        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which\r\n        // fire before onload), but fall back to onload.\r\n        let called = false;\r\n        const wrappedFn = function () {\r\n            if (!document.body) {\r\n                setTimeout(wrappedFn, Math.floor(10));\r\n                return;\r\n            }\r\n            if (!called) {\r\n                called = true;\r\n                fn();\r\n            }\r\n        };\r\n        if (document.addEventListener) {\r\n            document.addEventListener('DOMContentLoaded', wrappedFn, false);\r\n            // fallback to onload.\r\n            window.addEventListener('load', wrappedFn, false);\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }\r\n        else if (document.attachEvent) {\r\n            // IE.\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            document.attachEvent('onreadystatechange', () => {\r\n                if (document.readyState === 'complete') {\r\n                    wrappedFn();\r\n                }\r\n            });\r\n            // fallback to onload.\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            window.attachEvent('onload', wrappedFn);\r\n            // jQuery has an extra hack for IE that we could employ (based on\r\n            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.\r\n            // I'm hoping we don't need it.\r\n        }\r\n    }\r\n};\r\n/**\r\n * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names\r\n */\r\nconst MIN_NAME = '[MIN_NAME]';\r\n/**\r\n * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names\r\n */\r\nconst MAX_NAME = '[MAX_NAME]';\r\n/**\r\n * Compares valid Firebase key names, plus min and max name\r\n */\r\nconst nameCompare = function (a, b) {\r\n    if (a === b) {\r\n        return 0;\r\n    }\r\n    else if (a === MIN_NAME || b === MAX_NAME) {\r\n        return -1;\r\n    }\r\n    else if (b === MIN_NAME || a === MAX_NAME) {\r\n        return 1;\r\n    }\r\n    else {\r\n        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);\r\n        if (aAsInt !== null) {\r\n            if (bAsInt !== null) {\r\n                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        else if (bAsInt !== null) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return a < b ? -1 : 1;\r\n        }\r\n    }\r\n};\r\n/**\r\n * @returns {!number} comparison result.\r\n */\r\nconst stringCompare = function (a, b) {\r\n    if (a === b) {\r\n        return 0;\r\n    }\r\n    else if (a < b) {\r\n        return -1;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n};\r\nconst requireKey = function (key, obj) {\r\n    if (obj && key in obj) {\r\n        return obj[key];\r\n    }\r\n    else {\r\n        throw new Error('Missing required key (' + key + ') in object: ' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(obj));\r\n    }\r\n};\r\nconst ObjectToUniqueKey = function (obj) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(obj);\r\n    }\r\n    const keys = [];\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const k in obj) {\r\n        keys.push(k);\r\n    }\r\n    // Export as json, but with the keys sorted.\r\n    keys.sort();\r\n    let key = '{';\r\n    for (let i = 0; i < keys.length; i++) {\r\n        if (i !== 0) {\r\n            key += ',';\r\n        }\r\n        key += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(keys[i]);\r\n        key += ':';\r\n        key += ObjectToUniqueKey(obj[keys[i]]);\r\n    }\r\n    key += '}';\r\n    return key;\r\n};\r\n/**\r\n * Splits a string into a number of smaller segments of maximum size\r\n * @param str - The string\r\n * @param segsize - The maximum number of chars in the string.\r\n * @returns The string, split into appropriately-sized chunks\r\n */\r\nconst splitStringBySize = function (str, segsize) {\r\n    const len = str.length;\r\n    if (len <= segsize) {\r\n        return [str];\r\n    }\r\n    const dataSegs = [];\r\n    for (let c = 0; c < len; c += segsize) {\r\n        if (c + segsize > len) {\r\n            dataSegs.push(str.substring(c, len));\r\n        }\r\n        else {\r\n            dataSegs.push(str.substring(c, c + segsize));\r\n        }\r\n    }\r\n    return dataSegs;\r\n};\r\n/**\r\n * Apply a function to each (key, value) pair in an object or\r\n * apply a function to each (index, value) pair in an array\r\n * @param obj - The object or array to iterate over\r\n * @param fn - The function to apply\r\n */\r\nfunction each(obj, fn) {\r\n    for (const key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n            fn(key, obj[key]);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)\r\n * I made one modification at the end and removed the NaN / Infinity\r\n * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.\r\n * @param v - A double\r\n *\r\n */\r\nconst doubleToIEEE754String = function (v) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL\r\n    const ebits = 11, fbits = 52;\r\n    const bias = (1 << (ebits - 1)) - 1;\r\n    let s, e, f, ln, i;\r\n    // Compute sign, exponent, fraction\r\n    // Skip NaN / Infinity handling --MJL.\r\n    if (v === 0) {\r\n        e = 0;\r\n        f = 0;\r\n        s = 1 / v === -Infinity ? 1 : 0;\r\n    }\r\n    else {\r\n        s = v < 0;\r\n        v = Math.abs(v);\r\n        if (v >= Math.pow(2, 1 - bias)) {\r\n            // Normalized\r\n            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);\r\n            e = ln + bias;\r\n            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));\r\n        }\r\n        else {\r\n            // Denormalized\r\n            e = 0;\r\n            f = Math.round(v / Math.pow(2, 1 - bias - fbits));\r\n        }\r\n    }\r\n    // Pack sign, exponent, fraction\r\n    const bits = [];\r\n    for (i = fbits; i; i -= 1) {\r\n        bits.push(f % 2 ? 1 : 0);\r\n        f = Math.floor(f / 2);\r\n    }\r\n    for (i = ebits; i; i -= 1) {\r\n        bits.push(e % 2 ? 1 : 0);\r\n        e = Math.floor(e / 2);\r\n    }\r\n    bits.push(s ? 1 : 0);\r\n    bits.reverse();\r\n    const str = bits.join('');\r\n    // Return the data as a hex string. --MJL\r\n    let hexByteString = '';\r\n    for (i = 0; i < 64; i += 8) {\r\n        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);\r\n        if (hexByte.length === 1) {\r\n            hexByte = '0' + hexByte;\r\n        }\r\n        hexByteString = hexByteString + hexByte;\r\n    }\r\n    return hexByteString.toLowerCase();\r\n};\r\n/**\r\n * Used to detect if we're in a Chrome content script (which executes in an\r\n * isolated environment where long-polling doesn't work).\r\n */\r\nconst isChromeExtensionContentScript = function () {\r\n    return !!(typeof window === 'object' &&\r\n        window['chrome'] &&\r\n        window['chrome']['extension'] &&\r\n        !/^chrome/.test(window.location.href));\r\n};\r\n/**\r\n * Used to detect if we're in a Windows 8 Store app.\r\n */\r\nconst isWindowsStoreApp = function () {\r\n    // Check for the presence of a couple WinRT globals\r\n    return typeof Windows === 'object' && typeof Windows.UI === 'object';\r\n};\r\n/**\r\n * Converts a server error code to a Javascript Error\r\n */\r\nfunction errorForServerCode(code, query) {\r\n    let reason = 'Unknown Error';\r\n    if (code === 'too_big') {\r\n        reason =\r\n            'The data requested exceeds the maximum size ' +\r\n                'that can be accessed with a single request.';\r\n    }\r\n    else if (code === 'permission_denied') {\r\n        reason = \"Client doesn't have permission to access the desired data.\";\r\n    }\r\n    else if (code === 'unavailable') {\r\n        reason = 'The service is unavailable';\r\n    }\r\n    const error = new Error(code + ' at ' + query._path.toString() + ': ' + reason);\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    error.code = code.toUpperCase();\r\n    return error;\r\n}\r\n/**\r\n * Used to test for integer-looking strings\r\n */\r\nconst INTEGER_REGEXP_ = new RegExp('^-?(0*)\\\\d{1,10}$');\r\n/**\r\n * For use in keys, the minimum possible 32-bit integer.\r\n */\r\nconst INTEGER_32_MIN = -2147483648;\r\n/**\r\n * For use in kyes, the maximum possible 32-bit integer.\r\n */\r\nconst INTEGER_32_MAX = 2147483647;\r\n/**\r\n * If the string contains a 32-bit integer, return it.  Else return null.\r\n */\r\nconst tryParseInt = function (str) {\r\n    if (INTEGER_REGEXP_.test(str)) {\r\n        const intVal = Number(str);\r\n        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {\r\n            return intVal;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Helper to run some code but catch any exceptions and re-throw them later.\r\n * Useful for preventing user callbacks from breaking internal code.\r\n *\r\n * Re-throwing the exception from a setTimeout is a little evil, but it's very\r\n * convenient (we don't have to try to figure out when is a safe point to\r\n * re-throw it), and the behavior seems reasonable:\r\n *\r\n * * If you aren't pausing on exceptions, you get an error in the console with\r\n *   the correct stack trace.\r\n * * If you're pausing on all exceptions, the debugger will pause on your\r\n *   exception and then again when we rethrow it.\r\n * * If you're only pausing on uncaught exceptions, the debugger will only pause\r\n *   on us re-throwing it.\r\n *\r\n * @param fn - The code to guard.\r\n */\r\nconst exceptionGuard = function (fn) {\r\n    try {\r\n        fn();\r\n    }\r\n    catch (e) {\r\n        // Re-throw exception when it's safe.\r\n        setTimeout(() => {\r\n            // It used to be that \"throw e\" would result in a good console error with\r\n            // relevant context, but as of Chrome 39, you just get the firebase.js\r\n            // file/line number where we re-throw it, which is useless. So we log\r\n            // e.stack explicitly.\r\n            const stack = e.stack || '';\r\n            warn('Exception was thrown by user callback.', stack);\r\n            throw e;\r\n        }, Math.floor(0));\r\n    }\r\n};\r\n/**\r\n * @returns {boolean} true if we think we're currently being crawled.\r\n */\r\nconst beingCrawled = function () {\r\n    const userAgent = (typeof window === 'object' &&\r\n        window['navigator'] &&\r\n        window['navigator']['userAgent']) ||\r\n        '';\r\n    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we\r\n    // believe to support JavaScript/AJAX rendering.\r\n    // NOTE: Google Webmaster Tools doesn't really belong, but their \"This is how a visitor to your website\r\n    // would have seen the page\" is flaky if we don't treat it as a crawler.\r\n    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);\r\n};\r\n/**\r\n * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.\r\n *\r\n * It is removed with clearTimeout() as normal.\r\n *\r\n * @param fn - Function to run.\r\n * @param time - Milliseconds to wait before running.\r\n * @returns The setTimeout() return value.\r\n */\r\nconst setTimeoutNonBlocking = function (fn, time) {\r\n    const timeout = setTimeout(fn, time);\r\n    // Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.\r\n    if (typeof timeout === 'number' &&\r\n        // @ts-ignore Is only defined in Deno environments.\r\n        typeof Deno !== 'undefined' &&\r\n        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\r\n        Deno['unrefTimer']) {\r\n        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\r\n        Deno.unrefTimer(timeout);\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    }\r\n    else if (typeof timeout === 'object' && timeout['unref']) {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        timeout['unref']();\r\n    }\r\n    return timeout;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Abstraction around AppCheck's token fetching capabilities.\r\n */\r\nclass AppCheckTokenProvider {\r\n    constructor(appName_, appCheckProvider) {\r\n        this.appName_ = appName_;\r\n        this.appCheckProvider = appCheckProvider;\r\n        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });\r\n        if (!this.appCheck) {\r\n            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(appCheck => (this.appCheck = appCheck));\r\n        }\r\n    }\r\n    getToken(forceRefresh) {\r\n        if (!this.appCheck) {\r\n            return new Promise((resolve, reject) => {\r\n                // Support delayed initialization of FirebaseAppCheck. This allows our\r\n                // customers to initialize the RTDB SDK before initializing Firebase\r\n                // AppCheck and ensures that all requests are authenticated if a token\r\n                // becomes available before the timoeout below expires.\r\n                setTimeout(() => {\r\n                    if (this.appCheck) {\r\n                        this.getToken(forceRefresh).then(resolve, reject);\r\n                    }\r\n                    else {\r\n                        resolve(null);\r\n                    }\r\n                }, 0);\r\n            });\r\n        }\r\n        return this.appCheck.getToken(forceRefresh);\r\n    }\r\n    addTokenChangeListener(listener) {\r\n        var _a;\r\n        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then(appCheck => appCheck.addTokenListener(listener));\r\n    }\r\n    notifyForInvalidToken() {\r\n        warn(`Provided AppCheck credentials for the app named \"${this.appName_}\" ` +\r\n            'are invalid. This usually indicates your app was not initialized correctly.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Abstraction around FirebaseApp's token fetching capabilities.\r\n */\r\nclass FirebaseAuthTokenProvider {\r\n    constructor(appName_, firebaseOptions_, authProvider_) {\r\n        this.appName_ = appName_;\r\n        this.firebaseOptions_ = firebaseOptions_;\r\n        this.authProvider_ = authProvider_;\r\n        this.auth_ = null;\r\n        this.auth_ = authProvider_.getImmediate({ optional: true });\r\n        if (!this.auth_) {\r\n            authProvider_.onInit(auth => (this.auth_ = auth));\r\n        }\r\n    }\r\n    getToken(forceRefresh) {\r\n        if (!this.auth_) {\r\n            return new Promise((resolve, reject) => {\r\n                // Support delayed initialization of FirebaseAuth. This allows our\r\n                // customers to initialize the RTDB SDK before initializing Firebase\r\n                // Auth and ensures that all requests are authenticated if a token\r\n                // becomes available before the timoeout below expires.\r\n                setTimeout(() => {\r\n                    if (this.auth_) {\r\n                        this.getToken(forceRefresh).then(resolve, reject);\r\n                    }\r\n                    else {\r\n                        resolve(null);\r\n                    }\r\n                }, 0);\r\n            });\r\n        }\r\n        return this.auth_.getToken(forceRefresh).catch(error => {\r\n            // TODO: Need to figure out all the cases this is raised and whether\r\n            // this makes sense.\r\n            if (error && error.code === 'auth/token-not-initialized') {\r\n                log('Got auth/token-not-initialized error.  Treating as null token.');\r\n                return null;\r\n            }\r\n            else {\r\n                return Promise.reject(error);\r\n            }\r\n        });\r\n    }\r\n    addTokenChangeListener(listener) {\r\n        // TODO: We might want to wrap the listener and call it with no args to\r\n        // avoid a leaky abstraction, but that makes removing the listener harder.\r\n        if (this.auth_) {\r\n            this.auth_.addAuthTokenListener(listener);\r\n        }\r\n        else {\r\n            this.authProvider_\r\n                .get()\r\n                .then(auth => auth.addAuthTokenListener(listener));\r\n        }\r\n    }\r\n    removeTokenChangeListener(listener) {\r\n        this.authProvider_\r\n            .get()\r\n            .then(auth => auth.removeAuthTokenListener(listener));\r\n    }\r\n    notifyForInvalidToken() {\r\n        let errorMessage = 'Provided authentication credentials for the app named \"' +\r\n            this.appName_ +\r\n            '\" are invalid. This usually indicates your app was not ' +\r\n            'initialized correctly. ';\r\n        if ('credential' in this.firebaseOptions_) {\r\n            errorMessage +=\r\n                'Make sure the \"credential\" property provided to initializeApp() ' +\r\n                    'is authorized to access the specified \"databaseURL\" and is from the correct ' +\r\n                    'project.';\r\n        }\r\n        else if ('serviceAccount' in this.firebaseOptions_) {\r\n            errorMessage +=\r\n                'Make sure the \"serviceAccount\" property provided to initializeApp() ' +\r\n                    'is authorized to access the specified \"databaseURL\" and is from the correct ' +\r\n                    'project.';\r\n        }\r\n        else {\r\n            errorMessage +=\r\n                'Make sure the \"apiKey\" and \"databaseURL\" properties provided to ' +\r\n                    'initializeApp() match the values provided for your app at ' +\r\n                    'https://console.firebase.google.com/.';\r\n        }\r\n        warn(errorMessage);\r\n    }\r\n}\r\n/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */\r\nclass EmulatorTokenProvider {\r\n    constructor(accessToken) {\r\n        this.accessToken = accessToken;\r\n    }\r\n    getToken(forceRefresh) {\r\n        return Promise.resolve({\r\n            accessToken: this.accessToken\r\n        });\r\n    }\r\n    addTokenChangeListener(listener) {\r\n        // Invoke the listener immediately to match the behavior in Firebase Auth\r\n        // (see packages/auth/src/auth.js#L1807)\r\n        listener(this.accessToken);\r\n    }\r\n    removeTokenChangeListener(listener) { }\r\n    notifyForInvalidToken() { }\r\n}\r\n/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */\r\nEmulatorTokenProvider.OWNER = 'owner';\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PROTOCOL_VERSION = '5';\r\nconst VERSION_PARAM = 'v';\r\nconst TRANSPORT_SESSION_PARAM = 's';\r\nconst REFERER_PARAM = 'r';\r\nconst FORGE_REF = 'f';\r\n// Matches console.firebase.google.com, firebase-console-*.corp.google.com and\r\n// firebase.corp.google.com\r\nconst FORGE_DOMAIN_RE = /(console\\.firebase|firebase-console-\\w+\\.corp|firebase\\.corp)\\.google\\.com/;\r\nconst LAST_SESSION_PARAM = 'ls';\r\nconst APPLICATION_ID_PARAM = 'p';\r\nconst APP_CHECK_TOKEN_PARAM = 'ac';\r\nconst WEBSOCKET = 'websocket';\r\nconst LONG_POLLING = 'long_polling';\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A class that holds metadata about a Repo object\r\n */\r\nclass RepoInfo {\r\n    /**\r\n     * @param host - Hostname portion of the url for the repo\r\n     * @param secure - Whether or not this repo is accessed over ssl\r\n     * @param namespace - The namespace represented by the repo\r\n     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).\r\n     * @param nodeAdmin - Whether this instance uses Admin SDK credentials\r\n     * @param persistenceKey - Override the default session persistence storage key\r\n     */\r\n    constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = '', includeNamespaceInQueryParams = false, isUsingEmulator = false) {\r\n        this.secure = secure;\r\n        this.namespace = namespace;\r\n        this.webSocketOnly = webSocketOnly;\r\n        this.nodeAdmin = nodeAdmin;\r\n        this.persistenceKey = persistenceKey;\r\n        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;\r\n        this.isUsingEmulator = isUsingEmulator;\r\n        this._host = host.toLowerCase();\r\n        this._domain = this._host.substr(this._host.indexOf('.') + 1);\r\n        this.internalHost =\r\n            PersistentStorage.get('host:' + host) || this._host;\r\n    }\r\n    isCacheableHost() {\r\n        return this.internalHost.substr(0, 2) === 's-';\r\n    }\r\n    isCustomHost() {\r\n        return (this._domain !== 'firebaseio.com' &&\r\n            this._domain !== 'firebaseio-demo.com');\r\n    }\r\n    get host() {\r\n        return this._host;\r\n    }\r\n    set host(newHost) {\r\n        if (newHost !== this.internalHost) {\r\n            this.internalHost = newHost;\r\n            if (this.isCacheableHost()) {\r\n                PersistentStorage.set('host:' + this._host, this.internalHost);\r\n            }\r\n        }\r\n    }\r\n    toString() {\r\n        let str = this.toURLString();\r\n        if (this.persistenceKey) {\r\n            str += '<' + this.persistenceKey + '>';\r\n        }\r\n        return str;\r\n    }\r\n    toURLString() {\r\n        const protocol = this.secure ? 'https://' : 'http://';\r\n        const query = this.includeNamespaceInQueryParams\r\n            ? `?ns=${this.namespace}`\r\n            : '';\r\n        return `${protocol}${this.host}/${query}`;\r\n    }\r\n}\r\nfunction repoInfoNeedsQueryParam(repoInfo) {\r\n    return (repoInfo.host !== repoInfo.internalHost ||\r\n        repoInfo.isCustomHost() ||\r\n        repoInfo.includeNamespaceInQueryParams);\r\n}\r\n/**\r\n * Returns the websocket URL for this repo\r\n * @param repoInfo - RepoInfo object\r\n * @param type - of connection\r\n * @param params - list\r\n * @returns The URL for this repo\r\n */\r\nfunction repoInfoConnectionURL(repoInfo, type, params) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof type === 'string', 'typeof type must == string');\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof params === 'object', 'typeof params must == object');\r\n    let connURL;\r\n    if (type === WEBSOCKET) {\r\n        connURL =\r\n            (repoInfo.secure ? 'wss://' : 'ws://') + repoInfo.internalHost + '/.ws?';\r\n    }\r\n    else if (type === LONG_POLLING) {\r\n        connURL =\r\n            (repoInfo.secure ? 'https://' : 'http://') +\r\n                repoInfo.internalHost +\r\n                '/.lp?';\r\n    }\r\n    else {\r\n        throw new Error('Unknown connection type: ' + type);\r\n    }\r\n    if (repoInfoNeedsQueryParam(repoInfo)) {\r\n        params['ns'] = repoInfo.namespace;\r\n    }\r\n    const pairs = [];\r\n    each(params, (key, value) => {\r\n        pairs.push(key + '=' + value);\r\n    });\r\n    return connURL + pairs.join('&');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Tracks a collection of stats.\r\n */\r\nclass StatsCollection {\r\n    constructor() {\r\n        this.counters_ = {};\r\n    }\r\n    incrementCounter(name, amount = 1) {\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.counters_, name)) {\r\n            this.counters_[name] = 0;\r\n        }\r\n        this.counters_[name] += amount;\r\n    }\r\n    get() {\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(this.counters_);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst collections = {};\r\nconst reporters = {};\r\nfunction statsManagerGetCollection(repoInfo) {\r\n    const hashString = repoInfo.toString();\r\n    if (!collections[hashString]) {\r\n        collections[hashString] = new StatsCollection();\r\n    }\r\n    return collections[hashString];\r\n}\r\nfunction statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {\r\n    const hashString = repoInfo.toString();\r\n    if (!reporters[hashString]) {\r\n        reporters[hashString] = creatorFunction();\r\n    }\r\n    return reporters[hashString];\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class ensures the packets from the server arrive in order\r\n * This class takes data from the server and ensures it gets passed into the callbacks in order.\r\n */\r\nclass PacketReceiver {\r\n    /**\r\n     * @param onMessage_\r\n     */\r\n    constructor(onMessage_) {\r\n        this.onMessage_ = onMessage_;\r\n        this.pendingResponses = [];\r\n        this.currentResponseNum = 0;\r\n        this.closeAfterResponse = -1;\r\n        this.onClose = null;\r\n    }\r\n    closeAfter(responseNum, callback) {\r\n        this.closeAfterResponse = responseNum;\r\n        this.onClose = callback;\r\n        if (this.closeAfterResponse < this.currentResponseNum) {\r\n            this.onClose();\r\n            this.onClose = null;\r\n        }\r\n    }\r\n    /**\r\n     * Each message from the server comes with a response number, and an array of data. The responseNumber\r\n     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all\r\n     * browsers will respond in the same order as the requests we sent\r\n     */\r\n    handleResponse(requestNum, data) {\r\n        this.pendingResponses[requestNum] = data;\r\n        while (this.pendingResponses[this.currentResponseNum]) {\r\n            const toProcess = this.pendingResponses[this.currentResponseNum];\r\n            delete this.pendingResponses[this.currentResponseNum];\r\n            for (let i = 0; i < toProcess.length; ++i) {\r\n                if (toProcess[i]) {\r\n                    exceptionGuard(() => {\r\n                        this.onMessage_(toProcess[i]);\r\n                    });\r\n                }\r\n            }\r\n            if (this.currentResponseNum === this.closeAfterResponse) {\r\n                if (this.onClose) {\r\n                    this.onClose();\r\n                    this.onClose = null;\r\n                }\r\n                break;\r\n            }\r\n            this.currentResponseNum++;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// URL query parameters associated with longpolling\r\nconst FIREBASE_LONGPOLL_START_PARAM = 'start';\r\nconst FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\r\nconst FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\r\nconst FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\r\nconst FIREBASE_LONGPOLL_ID_PARAM = 'id';\r\nconst FIREBASE_LONGPOLL_PW_PARAM = 'pw';\r\nconst FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\r\nconst FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\r\nconst FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\r\nconst FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\r\nconst FIREBASE_LONGPOLL_DATA_PARAM = 'd';\r\nconst FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\r\n//Data size constants.\r\n//TODO: Perf: the maximum length actually differs from browser to browser.\r\n// We should check what browser we're on and set accordingly.\r\nconst MAX_URL_DATA_SIZE = 1870;\r\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\r\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\r\n/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n */\r\nconst KEEPALIVE_REQUEST_INTERVAL = 25000;\r\n/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n */\r\nconst LP_CONNECT_TIMEOUT = 30000;\r\n/**\r\n * This class manages a single long-polling connection.\r\n */\r\nclass BrowserPollConnection {\r\n    /**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The AppCheck token for this client.\r\n     * @param authToken The AuthToken to use for this connection.\r\n     * @param transportSessionId Optional transportSessionid if we are\r\n     * reconnecting for an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has\r\n     * already created a connection previously\r\n     */\r\n    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {\r\n        this.connId = connId;\r\n        this.repoInfo = repoInfo;\r\n        this.applicationId = applicationId;\r\n        this.appCheckToken = appCheckToken;\r\n        this.authToken = authToken;\r\n        this.transportSessionId = transportSessionId;\r\n        this.lastSessionId = lastSessionId;\r\n        this.bytesSent = 0;\r\n        this.bytesReceived = 0;\r\n        this.everConnected_ = false;\r\n        this.log_ = logWrapper(connId);\r\n        this.stats_ = statsManagerGetCollection(repoInfo);\r\n        this.urlFn = (params) => {\r\n            // Always add the token if we have one.\r\n            if (this.appCheckToken) {\r\n                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\r\n            }\r\n            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);\r\n        };\r\n    }\r\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */\r\n    open(onMessage, onDisconnect) {\r\n        this.curSegmentNum = 0;\r\n        this.onDisconnect_ = onDisconnect;\r\n        this.myPacketOrderer = new PacketReceiver(onMessage);\r\n        this.isClosed_ = false;\r\n        this.connectTimeoutTimer_ = setTimeout(() => {\r\n            this.log_('Timed out trying to connect.');\r\n            // Make sure we clear the host cache\r\n            this.onClosed_();\r\n            this.connectTimeoutTimer_ = null;\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(LP_CONNECT_TIMEOUT));\r\n        // Ensure we delay the creation of the iframe until the DOM is loaded.\r\n        executeWhenDOMReady(() => {\r\n            if (this.isClosed_) {\r\n                return;\r\n            }\r\n            //Set up a callback that gets triggered once a connection is set up.\r\n            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args) => {\r\n                const [command, arg1, arg2, arg3, arg4] = args;\r\n                this.incrementIncomingBytes_(args);\r\n                if (!this.scriptTagHolder) {\r\n                    return; // we closed the connection.\r\n                }\r\n                if (this.connectTimeoutTimer_) {\r\n                    clearTimeout(this.connectTimeoutTimer_);\r\n                    this.connectTimeoutTimer_ = null;\r\n                }\r\n                this.everConnected_ = true;\r\n                if (command === FIREBASE_LONGPOLL_START_PARAM) {\r\n                    this.id = arg1;\r\n                    this.password = arg2;\r\n                }\r\n                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\r\n                    // Don't clear the host cache. We got a response from the server, so we know it's reachable\r\n                    if (arg1) {\r\n                        // We aren't expecting any more data (other than what the server's already in the process of sending us\r\n                        // through our already open polls), so don't send any more.\r\n                        this.scriptTagHolder.sendNewPolls = false;\r\n                        // arg1 in this case is the last response number sent by the server. We should try to receive\r\n                        // all of the responses up to this one before closing\r\n                        this.myPacketOrderer.closeAfter(arg1, () => {\r\n                            this.onClosed_();\r\n                        });\r\n                    }\r\n                    else {\r\n                        this.onClosed_();\r\n                    }\r\n                }\r\n                else {\r\n                    throw new Error('Unrecognized command received: ' + command);\r\n                }\r\n            }, (...args) => {\r\n                const [pN, data] = args;\r\n                this.incrementIncomingBytes_(args);\r\n                this.myPacketOrderer.handleResponse(pN, data);\r\n            }, () => {\r\n                this.onClosed_();\r\n            }, this.urlFn);\r\n            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\r\n            //from cache.\r\n            const urlParams = {};\r\n            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\r\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\r\n            if (this.scriptTagHolder.uniqueCallbackIdentifier) {\r\n                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] =\r\n                    this.scriptTagHolder.uniqueCallbackIdentifier;\r\n            }\r\n            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\r\n            if (this.transportSessionId) {\r\n                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\r\n            }\r\n            if (this.lastSessionId) {\r\n                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\r\n            }\r\n            if (this.applicationId) {\r\n                urlParams[APPLICATION_ID_PARAM] = this.applicationId;\r\n            }\r\n            if (this.appCheckToken) {\r\n                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\r\n            }\r\n            if (typeof location !== 'undefined' &&\r\n                location.hostname &&\r\n                FORGE_DOMAIN_RE.test(location.hostname)) {\r\n                urlParams[REFERER_PARAM] = FORGE_REF;\r\n            }\r\n            const connectURL = this.urlFn(urlParams);\r\n            this.log_('Connecting via long-poll to ' + connectURL);\r\n            this.scriptTagHolder.addTag(connectURL, () => {\r\n                /* do nothing */\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */\r\n    start() {\r\n        this.scriptTagHolder.startLongPoll(this.id, this.password);\r\n        this.addDisconnectPingFrame(this.id, this.password);\r\n    }\r\n    /**\r\n     * Forces long polling to be considered as a potential transport\r\n     */\r\n    static forceAllow() {\r\n        BrowserPollConnection.forceAllow_ = true;\r\n    }\r\n    /**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */\r\n    static forceDisallow() {\r\n        BrowserPollConnection.forceDisallow_ = true;\r\n    }\r\n    // Static method, use string literal so it can be accessed in a generic way\r\n    static isAvailable() {\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            return false;\r\n        }\r\n        else if (BrowserPollConnection.forceAllow_) {\r\n            return true;\r\n        }\r\n        else {\r\n            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\r\n            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\r\n            return (!BrowserPollConnection.forceDisallow_ &&\r\n                typeof document !== 'undefined' &&\r\n                document.createElement != null &&\r\n                !isChromeExtensionContentScript() &&\r\n                !isWindowsStoreApp());\r\n        }\r\n    }\r\n    /**\r\n     * No-op for polling\r\n     */\r\n    markConnectionHealthy() { }\r\n    /**\r\n     * Stops polling and cleans up the iframe\r\n     */\r\n    shutdown_() {\r\n        this.isClosed_ = true;\r\n        if (this.scriptTagHolder) {\r\n            this.scriptTagHolder.close();\r\n            this.scriptTagHolder = null;\r\n        }\r\n        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\r\n        if (this.myDisconnFrame) {\r\n            document.body.removeChild(this.myDisconnFrame);\r\n            this.myDisconnFrame = null;\r\n        }\r\n        if (this.connectTimeoutTimer_) {\r\n            clearTimeout(this.connectTimeoutTimer_);\r\n            this.connectTimeoutTimer_ = null;\r\n        }\r\n    }\r\n    /**\r\n     * Triggered when this transport is closed\r\n     */\r\n    onClosed_() {\r\n        if (!this.isClosed_) {\r\n            this.log_('Longpoll is closing itself');\r\n            this.shutdown_();\r\n            if (this.onDisconnect_) {\r\n                this.onDisconnect_(this.everConnected_);\r\n                this.onDisconnect_ = null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */\r\n    close() {\r\n        if (!this.isClosed_) {\r\n            this.log_('Longpoll is being closed.');\r\n            this.shutdown_();\r\n        }\r\n    }\r\n    /**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param data - The JSON data to transmit.\r\n     */\r\n    send(data) {\r\n        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data);\r\n        this.bytesSent += dataStr.length;\r\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\r\n        //first, lets get the base64-encoded data\r\n        const base64data = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64Encode)(dataStr);\r\n        //We can only fit a certain amount in each URL, so we need to split this request\r\n        //up into multiple pieces if it doesn't fit in one request.\r\n        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\r\n        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\r\n        //of segments so that we can reassemble the packet on the server.\r\n        for (let i = 0; i < dataSegs.length; i++) {\r\n            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\r\n            this.curSegmentNum++;\r\n        }\r\n    }\r\n    /**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     */\r\n    addDisconnectPingFrame(id, pw) {\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            return;\r\n        }\r\n        this.myDisconnFrame = document.createElement('iframe');\r\n        const urlParams = {};\r\n        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\r\n        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\r\n        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\r\n        this.myDisconnFrame.src = this.urlFn(urlParams);\r\n        this.myDisconnFrame.style.display = 'none';\r\n        document.body.appendChild(this.myDisconnFrame);\r\n    }\r\n    /**\r\n     * Used to track the bytes received by this client\r\n     */\r\n    incrementIncomingBytes_(args) {\r\n        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\r\n        const bytesReceived = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(args).length;\r\n        this.bytesReceived += bytesReceived;\r\n        this.stats_.incrementCounter('bytes_received', bytesReceived);\r\n    }\r\n}\r\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n *********************************************************************************************/\r\nclass FirebaseIFrameScriptHolder {\r\n    /**\r\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */\r\n    constructor(commandCB, onMessageCB, onDisconnect, urlFn) {\r\n        this.onDisconnect = onDisconnect;\r\n        this.urlFn = urlFn;\r\n        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\r\n        //problems in some browsers.\r\n        this.outstandingRequests = new Set();\r\n        //A queue of the pending segments waiting for transmission to the server.\r\n        this.pendingSegs = [];\r\n        //A serial number. We use this for two things:\r\n        // 1) A way to ensure the browser doesn't cache responses to polls\r\n        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\r\n        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\r\n        //    JSONP code in the order it was added to the iframe.\r\n        this.currentSerial = Math.floor(Math.random() * 100000000);\r\n        // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\r\n        // incoming data from the server that we're waiting for).\r\n        this.sendNewPolls = true;\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\r\n            //iframes where we put the long-polling script tags. We have two callbacks:\r\n            //   1) Command Callback - Triggered for control issues, like starting a connection.\r\n            //   2) Message Callback - Triggered when new data arrives.\r\n            this.uniqueCallbackIdentifier = LUIDGenerator();\r\n            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\r\n            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] =\r\n                onMessageCB;\r\n            //Create an iframe for us to add script tags to.\r\n            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\r\n            // Set the iframe's contents.\r\n            let script = '';\r\n            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\r\n            // for ie9, but ie8 needs to do it again in the document itself.\r\n            if (this.myIFrame.src &&\r\n                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {\r\n                const currentDomain = document.domain;\r\n                script = '<script>document.domain=\"' + currentDomain + '\";</script>';\r\n            }\r\n            const iframeContents = '<html><body>' + script + '</body></html>';\r\n            try {\r\n                this.myIFrame.doc.open();\r\n                this.myIFrame.doc.write(iframeContents);\r\n                this.myIFrame.doc.close();\r\n            }\r\n            catch (e) {\r\n                log('frame writing exception');\r\n                if (e.stack) {\r\n                    log(e.stack);\r\n                }\r\n                log(e);\r\n            }\r\n        }\r\n        else {\r\n            this.commandCB = commandCB;\r\n            this.onMessageCB = onMessageCB;\r\n        }\r\n    }\r\n    /**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     */\r\n    static createIFrame_() {\r\n        const iframe = document.createElement('iframe');\r\n        iframe.style.display = 'none';\r\n        // This is necessary in order to initialize the document inside the iframe\r\n        if (document.body) {\r\n            document.body.appendChild(iframe);\r\n            try {\r\n                // If document.domain has been modified in IE, this will throw an error, and we need to set the\r\n                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\r\n                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\r\n                const a = iframe.contentWindow.document;\r\n                if (!a) {\r\n                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\r\n                    log('No IE domain setting required');\r\n                }\r\n            }\r\n            catch (e) {\r\n                const domain = document.domain;\r\n                iframe.src =\r\n                    \"javascript:void((function(){document.open();document.domain='\" +\r\n                        domain +\r\n                        \"';document.close();})())\";\r\n            }\r\n        }\r\n        else {\r\n            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\r\n            // never gets hit.\r\n            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\r\n        }\r\n        // Get the document of the iframe in a browser-specific way.\r\n        if (iframe.contentDocument) {\r\n            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\r\n        }\r\n        else if (iframe.contentWindow) {\r\n            iframe.doc = iframe.contentWindow.document; // Internet Explorer\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }\r\n        else if (iframe.document) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            iframe.doc = iframe.document; //others?\r\n        }\r\n        return iframe;\r\n    }\r\n    /**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */\r\n    close() {\r\n        //Mark this iframe as dead, so no new requests are sent.\r\n        this.alive = false;\r\n        if (this.myIFrame) {\r\n            //We have to actually remove all of the html inside this iframe before removing it from the\r\n            //window, or IE will continue loading and executing the script tags we've already added, which\r\n            //can lead to some errors being thrown. Setting textContent seems to be the safest way to do this.\r\n            this.myIFrame.doc.body.textContent = '';\r\n            setTimeout(() => {\r\n                if (this.myIFrame !== null) {\r\n                    document.body.removeChild(this.myIFrame);\r\n                    this.myIFrame = null;\r\n                }\r\n            }, Math.floor(0));\r\n        }\r\n        // Protect from being called recursively.\r\n        const onDisconnect = this.onDisconnect;\r\n        if (onDisconnect) {\r\n            this.onDisconnect = null;\r\n            onDisconnect();\r\n        }\r\n    }\r\n    /**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param id - The ID of this connection\r\n     * @param pw - The password for this connection\r\n     */\r\n    startLongPoll(id, pw) {\r\n        this.myID = id;\r\n        this.myPW = pw;\r\n        this.alive = true;\r\n        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\r\n        while (this.newRequest_()) { }\r\n    }\r\n    /**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */\r\n    newRequest_() {\r\n        // We keep one outstanding request open all the time to receive data, but if we need to send data\r\n        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\r\n        // close the old request.\r\n        if (this.alive &&\r\n            this.sendNewPolls &&\r\n            this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {\r\n            //construct our url\r\n            this.currentSerial++;\r\n            const urlParams = {};\r\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\r\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\r\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\r\n            let theURL = this.urlFn(urlParams);\r\n            //Now add as much data as we can.\r\n            let curDataString = '';\r\n            let i = 0;\r\n            while (this.pendingSegs.length > 0) {\r\n                //first, lets see if the next segment will fit.\r\n                const nextSeg = this.pendingSegs[0];\r\n                if (nextSeg.d.length +\r\n                    SEG_HEADER_SIZE +\r\n                    curDataString.length <=\r\n                    MAX_URL_DATA_SIZE) {\r\n                    //great, the segment will fit. Lets append it.\r\n                    const theSeg = this.pendingSegs.shift();\r\n                    curDataString =\r\n                        curDataString +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.seg +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.ts +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_DATA_PARAM +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.d;\r\n                    i++;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            theURL = theURL + curDataString;\r\n            this.addLongPollTag_(theURL, this.currentSerial);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */\r\n    enqueueSegment(segnum, totalsegs, data) {\r\n        //add this to the queue of segments to send.\r\n        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\r\n        //send the data immediately if there isn't already data being transmitted, unless\r\n        //startLongPoll hasn't been called yet.\r\n        if (this.alive) {\r\n            this.newRequest_();\r\n        }\r\n    }\r\n    /**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param url - The URL of the script tag.\r\n     * @param serial - The serial number of the request.\r\n     */\r\n    addLongPollTag_(url, serial) {\r\n        //remember that we sent this request.\r\n        this.outstandingRequests.add(serial);\r\n        const doNewRequest = () => {\r\n            this.outstandingRequests.delete(serial);\r\n            this.newRequest_();\r\n        };\r\n        // If this request doesn't return on its own accord (by the server sending us some data), we'll\r\n        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\r\n        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\r\n        const readyStateCB = () => {\r\n            // Request completed.  Cancel the keepalive.\r\n            clearTimeout(keepaliveTimeout);\r\n            // Trigger a new request so we can continue receiving data.\r\n            doNewRequest();\r\n        };\r\n        this.addTag(url, readyStateCB);\r\n    }\r\n    /**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param url - The URL for the script tag source.\r\n     * @param loadCB - A callback to be triggered once the script has loaded.\r\n     */\r\n    addTag(url, loadCB) {\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            this.doNodeLongPoll(url, loadCB);\r\n        }\r\n        else {\r\n            setTimeout(() => {\r\n                try {\r\n                    // if we're already closed, don't add this poll\r\n                    if (!this.sendNewPolls) {\r\n                        return;\r\n                    }\r\n                    const newScript = this.myIFrame.doc.createElement('script');\r\n                    newScript.type = 'text/javascript';\r\n                    newScript.async = true;\r\n                    newScript.src = url;\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    newScript.onload = newScript.onreadystatechange =\r\n                        function () {\r\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                            const rstate = newScript.readyState;\r\n                            if (!rstate || rstate === 'loaded' || rstate === 'complete') {\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                newScript.onload = newScript.onreadystatechange = null;\r\n                                if (newScript.parentNode) {\r\n                                    newScript.parentNode.removeChild(newScript);\r\n                                }\r\n                                loadCB();\r\n                            }\r\n                        };\r\n                    newScript.onerror = () => {\r\n                        log('Long-poll script failed to load: ' + url);\r\n                        this.sendNewPolls = false;\r\n                        this.close();\r\n                    };\r\n                    this.myIFrame.doc.body.appendChild(newScript);\r\n                }\r\n                catch (e) {\r\n                    // TODO: we should make this error visible somehow\r\n                }\r\n            }, Math.floor(1));\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst WEBSOCKET_MAX_FRAME_SIZE = 16384;\r\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\r\nlet WebSocketImpl = null;\r\nif (typeof MozWebSocket !== 'undefined') {\r\n    WebSocketImpl = MozWebSocket;\r\n}\r\nelse if (typeof WebSocket !== 'undefined') {\r\n    WebSocketImpl = WebSocket;\r\n}\r\n/**\r\n * Create a new websocket connection with the given callbacks.\r\n */\r\nclass WebSocketConnection {\r\n    /**\r\n     * @param connId identifier for this transport\r\n     * @param repoInfo The info for the websocket endpoint.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The App Check Token for this client.\r\n     * @param authToken The Auth Token for this client.\r\n     * @param transportSessionId Optional transportSessionId if this is connecting\r\n     * to an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if there was a previous\r\n     * connection\r\n     */\r\n    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {\r\n        this.connId = connId;\r\n        this.applicationId = applicationId;\r\n        this.appCheckToken = appCheckToken;\r\n        this.authToken = authToken;\r\n        this.keepaliveTimer = null;\r\n        this.frames = null;\r\n        this.totalFrames = 0;\r\n        this.bytesSent = 0;\r\n        this.bytesReceived = 0;\r\n        this.log_ = logWrapper(this.connId);\r\n        this.stats_ = statsManagerGetCollection(repoInfo);\r\n        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);\r\n        this.nodeAdmin = repoInfo.nodeAdmin;\r\n    }\r\n    /**\r\n     * @param repoInfo - The info for the websocket endpoint.\r\n     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport\r\n     *                                         session\r\n     * @param lastSessionId - Optional lastSessionId if there was a previous connection\r\n     * @returns connection url\r\n     */\r\n    static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) {\r\n        const urlParams = {};\r\n        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)() &&\r\n            typeof location !== 'undefined' &&\r\n            location.hostname &&\r\n            FORGE_DOMAIN_RE.test(location.hostname)) {\r\n            urlParams[REFERER_PARAM] = FORGE_REF;\r\n        }\r\n        if (transportSessionId) {\r\n            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\r\n        }\r\n        if (lastSessionId) {\r\n            urlParams[LAST_SESSION_PARAM] = lastSessionId;\r\n        }\r\n        if (appCheckToken) {\r\n            urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;\r\n        }\r\n        if (applicationId) {\r\n            urlParams[APPLICATION_ID_PARAM] = applicationId;\r\n        }\r\n        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);\r\n    }\r\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */\r\n    open(onMessage, onDisconnect) {\r\n        this.onDisconnect = onDisconnect;\r\n        this.onMessage = onMessage;\r\n        this.log_('Websocket connecting to ' + this.connURL);\r\n        this.everConnected_ = false;\r\n        // Assume failure until proven otherwise.\r\n        PersistentStorage.set('previous_websocket_failure', true);\r\n        try {\r\n            let options;\r\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n                const device = this.nodeAdmin ? 'AdminNode' : 'Node';\r\n                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\r\n                options = {\r\n                    headers: {\r\n                        'User-Agent': `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`,\r\n                        'X-Firebase-GMPID': this.applicationId || ''\r\n                    }\r\n                };\r\n                // If using Node with admin creds, AppCheck-related checks are unnecessary.\r\n                // Note that we send the credentials here even if they aren't admin credentials, which is\r\n                // not a problem.\r\n                // Note that this header is just used to bypass appcheck, and the token should still be sent\r\n                // through the websocket connection once it is established.\r\n                if (this.authToken) {\r\n                    options.headers['Authorization'] = `Bearer ${this.authToken}`;\r\n                }\r\n                if (this.appCheckToken) {\r\n                    options.headers['X-Firebase-AppCheck'] = this.appCheckToken;\r\n                }\r\n                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\r\n                const env = process['env'];\r\n                const proxy = this.connURL.indexOf('wss://') === 0\r\n                    ? env['HTTPS_PROXY'] || env['https_proxy']\r\n                    : env['HTTP_PROXY'] || env['http_proxy'];\r\n                if (proxy) {\r\n                    options['proxy'] = { origin: proxy };\r\n                }\r\n            }\r\n            this.mySock = new WebSocketImpl(this.connURL, [], options);\r\n        }\r\n        catch (e) {\r\n            this.log_('Error instantiating WebSocket.');\r\n            const error = e.message || e.data;\r\n            if (error) {\r\n                this.log_(error);\r\n            }\r\n            this.onClosed_();\r\n            return;\r\n        }\r\n        this.mySock.onopen = () => {\r\n            this.log_('Websocket connected.');\r\n            this.everConnected_ = true;\r\n        };\r\n        this.mySock.onclose = () => {\r\n            this.log_('Websocket connection was disconnected.');\r\n            this.mySock = null;\r\n            this.onClosed_();\r\n        };\r\n        this.mySock.onmessage = m => {\r\n            this.handleIncomingFrame(m);\r\n        };\r\n        this.mySock.onerror = e => {\r\n            this.log_('WebSocket error.  Closing connection.');\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const error = e.message || e.data;\r\n            if (error) {\r\n                this.log_(error);\r\n            }\r\n            this.onClosed_();\r\n        };\r\n    }\r\n    /**\r\n     * No-op for websockets, we don't need to do anything once the connection is confirmed as open\r\n     */\r\n    start() { }\r\n    static forceDisallow() {\r\n        WebSocketConnection.forceDisallow_ = true;\r\n    }\r\n    static isAvailable() {\r\n        let isOldAndroid = false;\r\n        if (typeof navigator !== 'undefined' && navigator.userAgent) {\r\n            const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\r\n            const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\r\n            if (oldAndroidMatch && oldAndroidMatch.length > 1) {\r\n                if (parseFloat(oldAndroidMatch[1]) < 4.4) {\r\n                    isOldAndroid = true;\r\n                }\r\n            }\r\n        }\r\n        return (!isOldAndroid &&\r\n            WebSocketImpl !== null &&\r\n            !WebSocketConnection.forceDisallow_);\r\n    }\r\n    /**\r\n     * Returns true if we previously failed to connect with this transport.\r\n     */\r\n    static previouslyFailed() {\r\n        // If our persistent storage is actually only in-memory storage,\r\n        // we default to assuming that it previously failed to be safe.\r\n        return (PersistentStorage.isInMemoryStorage ||\r\n            PersistentStorage.get('previous_websocket_failure') === true);\r\n    }\r\n    markConnectionHealthy() {\r\n        PersistentStorage.remove('previous_websocket_failure');\r\n    }\r\n    appendFrame_(data) {\r\n        this.frames.push(data);\r\n        if (this.frames.length === this.totalFrames) {\r\n            const fullMess = this.frames.join('');\r\n            this.frames = null;\r\n            const jsonMess = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(fullMess);\r\n            //handle the message\r\n            this.onMessage(jsonMess);\r\n        }\r\n    }\r\n    /**\r\n     * @param frameCount - The number of frames we are expecting from the server\r\n     */\r\n    handleNewFrameCount_(frameCount) {\r\n        this.totalFrames = frameCount;\r\n        this.frames = [];\r\n    }\r\n    /**\r\n     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\r\n     * @returns Any remaining data to be process, or null if there is none\r\n     */\r\n    extractFrameCount_(data) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.frames === null, 'We already have a frame buffer');\r\n        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\r\n        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\r\n        if (data.length <= 6) {\r\n            const frameCount = Number(data);\r\n            if (!isNaN(frameCount)) {\r\n                this.handleNewFrameCount_(frameCount);\r\n                return null;\r\n            }\r\n        }\r\n        this.handleNewFrameCount_(1);\r\n        return data;\r\n    }\r\n    /**\r\n     * Process a websocket frame that has arrived from the server.\r\n     * @param mess - The frame data\r\n     */\r\n    handleIncomingFrame(mess) {\r\n        if (this.mySock === null) {\r\n            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\r\n        }\r\n        const data = mess['data'];\r\n        this.bytesReceived += data.length;\r\n        this.stats_.incrementCounter('bytes_received', data.length);\r\n        this.resetKeepAlive();\r\n        if (this.frames !== null) {\r\n            // we're buffering\r\n            this.appendFrame_(data);\r\n        }\r\n        else {\r\n            // try to parse out a frame count, otherwise, assume 1 and process it\r\n            const remainingData = this.extractFrameCount_(data);\r\n            if (remainingData !== null) {\r\n                this.appendFrame_(remainingData);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Send a message to the server\r\n     * @param data - The JSON object to transmit\r\n     */\r\n    send(data) {\r\n        this.resetKeepAlive();\r\n        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data);\r\n        this.bytesSent += dataStr.length;\r\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\r\n        //We can only fit a certain amount in each websocket frame, so we need to split this request\r\n        //up into multiple pieces if it doesn't fit in one request.\r\n        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\r\n        //Send the length header\r\n        if (dataSegs.length > 1) {\r\n            this.sendString_(String(dataSegs.length));\r\n        }\r\n        //Send the actual data in segments.\r\n        for (let i = 0; i < dataSegs.length; i++) {\r\n            this.sendString_(dataSegs[i]);\r\n        }\r\n    }\r\n    shutdown_() {\r\n        this.isClosed_ = true;\r\n        if (this.keepaliveTimer) {\r\n            clearInterval(this.keepaliveTimer);\r\n            this.keepaliveTimer = null;\r\n        }\r\n        if (this.mySock) {\r\n            this.mySock.close();\r\n            this.mySock = null;\r\n        }\r\n    }\r\n    onClosed_() {\r\n        if (!this.isClosed_) {\r\n            this.log_('WebSocket is closing itself');\r\n            this.shutdown_();\r\n            // since this is an internal close, trigger the close listener\r\n            if (this.onDisconnect) {\r\n                this.onDisconnect(this.everConnected_);\r\n                this.onDisconnect = null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * External-facing close handler.\r\n     * Close the websocket and kill the connection.\r\n     */\r\n    close() {\r\n        if (!this.isClosed_) {\r\n            this.log_('WebSocket is being closed');\r\n            this.shutdown_();\r\n        }\r\n    }\r\n    /**\r\n     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\r\n     * the last activity.\r\n     */\r\n    resetKeepAlive() {\r\n        clearInterval(this.keepaliveTimer);\r\n        this.keepaliveTimer = setInterval(() => {\r\n            //If there has been no websocket activity for a while, send a no-op\r\n            if (this.mySock) {\r\n                this.sendString_('0');\r\n            }\r\n            this.resetKeepAlive();\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\r\n    }\r\n    /**\r\n     * Send a string over the websocket.\r\n     *\r\n     * @param str - String to send.\r\n     */\r\n    sendString_(str) {\r\n        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\r\n        // calls for some unknown reason.  We treat these as an error and disconnect.\r\n        // See https://app.asana.com/0/58926111402292/68021340250410\r\n        try {\r\n            this.mySock.send(str);\r\n        }\r\n        catch (e) {\r\n            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');\r\n            setTimeout(this.onClosed_.bind(this), 0);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Number of response before we consider the connection \"healthy.\"\r\n */\r\nWebSocketConnection.responsesRequiredToBeHealthy = 2;\r\n/**\r\n * Time to wait for the connection te become healthy before giving up.\r\n */\r\nWebSocketConnection.healthyTimeout = 30000;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n */\r\nclass TransportManager {\r\n    /**\r\n     * @param repoInfo - Metadata around the namespace we're connecting to\r\n     */\r\n    constructor(repoInfo) {\r\n        this.initTransports_(repoInfo);\r\n    }\r\n    static get ALL_TRANSPORTS() {\r\n        return [BrowserPollConnection, WebSocketConnection];\r\n    }\r\n    /**\r\n     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after\r\n     * TransportManager has already set up transports_\r\n     */\r\n    static get IS_TRANSPORT_INITIALIZED() {\r\n        return this.globalTransportInitialized_;\r\n    }\r\n    initTransports_(repoInfo) {\r\n        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection['isAvailable']();\r\n        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\r\n        if (repoInfo.webSocketOnly) {\r\n            if (!isWebSocketsAvailable) {\r\n                warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\r\n            }\r\n            isSkipPollConnection = true;\r\n        }\r\n        if (isSkipPollConnection) {\r\n            this.transports_ = [WebSocketConnection];\r\n        }\r\n        else {\r\n            const transports = (this.transports_ = []);\r\n            for (const transport of TransportManager.ALL_TRANSPORTS) {\r\n                if (transport && transport['isAvailable']()) {\r\n                    transports.push(transport);\r\n                }\r\n            }\r\n            TransportManager.globalTransportInitialized_ = true;\r\n        }\r\n    }\r\n    /**\r\n     * @returns The constructor for the initial transport to use\r\n     */\r\n    initialTransport() {\r\n        if (this.transports_.length > 0) {\r\n            return this.transports_[0];\r\n        }\r\n        else {\r\n            throw new Error('No transports available');\r\n        }\r\n    }\r\n    /**\r\n     * @returns The constructor for the next transport, or null\r\n     */\r\n    upgradeTransport() {\r\n        if (this.transports_.length > 1) {\r\n            return this.transports_[1];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n// Keeps track of whether the TransportManager has already chosen a transport to use\r\nTransportManager.globalTransportInitialized_ = false;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Abort upgrade attempt if it takes longer than 60s.\r\nconst UPGRADE_TIMEOUT = 60000;\r\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\r\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\r\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\r\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\r\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\r\n// but we've sent/received enough bytes, we don't cancel the connection.\r\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\r\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\r\nconst MESSAGE_TYPE = 't';\r\nconst MESSAGE_DATA = 'd';\r\nconst CONTROL_SHUTDOWN = 's';\r\nconst CONTROL_RESET = 'r';\r\nconst CONTROL_ERROR = 'e';\r\nconst CONTROL_PONG = 'o';\r\nconst SWITCH_ACK = 'a';\r\nconst END_TRANSMISSION = 'n';\r\nconst PING = 'p';\r\nconst SERVER_HELLO = 'h';\r\n/**\r\n * Creates a new real-time connection to the server using whichever method works\r\n * best in the current browser.\r\n */\r\nclass Connection {\r\n    /**\r\n     * @param id - an id for this connection\r\n     * @param repoInfo_ - the info for the endpoint to connect to\r\n     * @param applicationId_ - the Firebase App ID for this project\r\n     * @param appCheckToken_ - The App Check Token for this device.\r\n     * @param authToken_ - The auth token for this session.\r\n     * @param onMessage_ - the callback to be triggered when a server-push message arrives\r\n     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.\r\n     * @param onDisconnect_ - the callback to be triggered when a connection was lost\r\n     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.\r\n     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\r\n     */\r\n    constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {\r\n        this.id = id;\r\n        this.repoInfo_ = repoInfo_;\r\n        this.applicationId_ = applicationId_;\r\n        this.appCheckToken_ = appCheckToken_;\r\n        this.authToken_ = authToken_;\r\n        this.onMessage_ = onMessage_;\r\n        this.onReady_ = onReady_;\r\n        this.onDisconnect_ = onDisconnect_;\r\n        this.onKill_ = onKill_;\r\n        this.lastSessionId = lastSessionId;\r\n        this.connectionCount = 0;\r\n        this.pendingDataMessages = [];\r\n        this.state_ = 0 /* RealtimeState.CONNECTING */;\r\n        this.log_ = logWrapper('c:' + this.id + ':');\r\n        this.transportManager_ = new TransportManager(repoInfo_);\r\n        this.log_('Connection created');\r\n        this.start_();\r\n    }\r\n    /**\r\n     * Starts a connection attempt\r\n     */\r\n    start_() {\r\n        const conn = this.transportManager_.initialTransport();\r\n        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);\r\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\r\n        // can consider the transport healthy.\r\n        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\r\n        const onMessageReceived = this.connReceiver_(this.conn_);\r\n        const onConnectionLost = this.disconnReceiver_(this.conn_);\r\n        this.tx_ = this.conn_;\r\n        this.rx_ = this.conn_;\r\n        this.secondaryConn_ = null;\r\n        this.isHealthy_ = false;\r\n        /*\r\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\r\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\r\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\r\n         * still have the context of your originating frame.\r\n         */\r\n        setTimeout(() => {\r\n            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\r\n            this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\r\n        }, Math.floor(0));\r\n        const healthyTimeoutMS = conn['healthyTimeout'] || 0;\r\n        if (healthyTimeoutMS > 0) {\r\n            this.healthyTimeout_ = setTimeoutNonBlocking(() => {\r\n                this.healthyTimeout_ = null;\r\n                if (!this.isHealthy_) {\r\n                    if (this.conn_ &&\r\n                        this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\r\n                        this.log_('Connection exceeded healthy timeout but has received ' +\r\n                            this.conn_.bytesReceived +\r\n                            ' bytes.  Marking connection healthy.');\r\n                        this.isHealthy_ = true;\r\n                        this.conn_.markConnectionHealthy();\r\n                    }\r\n                    else if (this.conn_ &&\r\n                        this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\r\n                        this.log_('Connection exceeded healthy timeout but has sent ' +\r\n                            this.conn_.bytesSent +\r\n                            ' bytes.  Leaving connection alive.');\r\n                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\r\n                        // the server.\r\n                    }\r\n                    else {\r\n                        this.log_('Closing unhealthy connection after timeout.');\r\n                        this.close();\r\n                    }\r\n                }\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            }, Math.floor(healthyTimeoutMS));\r\n        }\r\n    }\r\n    nextTransportId_() {\r\n        return 'c:' + this.id + ':' + this.connectionCount++;\r\n    }\r\n    disconnReceiver_(conn) {\r\n        return everConnected => {\r\n            if (conn === this.conn_) {\r\n                this.onConnectionLost_(everConnected);\r\n            }\r\n            else if (conn === this.secondaryConn_) {\r\n                this.log_('Secondary connection lost.');\r\n                this.onSecondaryConnectionLost_();\r\n            }\r\n            else {\r\n                this.log_('closing an old connection');\r\n            }\r\n        };\r\n    }\r\n    connReceiver_(conn) {\r\n        return (message) => {\r\n            if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */) {\r\n                if (conn === this.rx_) {\r\n                    this.onPrimaryMessageReceived_(message);\r\n                }\r\n                else if (conn === this.secondaryConn_) {\r\n                    this.onSecondaryMessageReceived_(message);\r\n                }\r\n                else {\r\n                    this.log_('message on old connection');\r\n                }\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * @param dataMsg - An arbitrary data message to be sent to the server\r\n     */\r\n    sendRequest(dataMsg) {\r\n        // wrap in a data message envelope and send it on\r\n        const msg = { t: 'd', d: dataMsg };\r\n        this.sendData_(msg);\r\n    }\r\n    tryCleanupConnection() {\r\n        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\r\n            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);\r\n            this.conn_ = this.secondaryConn_;\r\n            this.secondaryConn_ = null;\r\n            // the server will shutdown the old connection\r\n        }\r\n    }\r\n    onSecondaryControl_(controlData) {\r\n        if (MESSAGE_TYPE in controlData) {\r\n            const cmd = controlData[MESSAGE_TYPE];\r\n            if (cmd === SWITCH_ACK) {\r\n                this.upgradeIfSecondaryHealthy_();\r\n            }\r\n            else if (cmd === CONTROL_RESET) {\r\n                // Most likely the session wasn't valid. Abandon the switch attempt\r\n                this.log_('Got a reset on secondary, closing it');\r\n                this.secondaryConn_.close();\r\n                // If we were already using this connection for something, than we need to fully close\r\n                if (this.tx_ === this.secondaryConn_ ||\r\n                    this.rx_ === this.secondaryConn_) {\r\n                    this.close();\r\n                }\r\n            }\r\n            else if (cmd === CONTROL_PONG) {\r\n                this.log_('got pong on secondary.');\r\n                this.secondaryResponsesRequired_--;\r\n                this.upgradeIfSecondaryHealthy_();\r\n            }\r\n        }\r\n    }\r\n    onSecondaryMessageReceived_(parsedData) {\r\n        const layer = requireKey('t', parsedData);\r\n        const data = requireKey('d', parsedData);\r\n        if (layer === 'c') {\r\n            this.onSecondaryControl_(data);\r\n        }\r\n        else if (layer === 'd') {\r\n            // got a data message, but we're still second connection. Need to buffer it up\r\n            this.pendingDataMessages.push(data);\r\n        }\r\n        else {\r\n            throw new Error('Unknown protocol layer: ' + layer);\r\n        }\r\n    }\r\n    upgradeIfSecondaryHealthy_() {\r\n        if (this.secondaryResponsesRequired_ <= 0) {\r\n            this.log_('Secondary connection is healthy.');\r\n            this.isHealthy_ = true;\r\n            this.secondaryConn_.markConnectionHealthy();\r\n            this.proceedWithUpgrade_();\r\n        }\r\n        else {\r\n            // Send a ping to make sure the connection is healthy.\r\n            this.log_('sending ping on secondary.');\r\n            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\r\n        }\r\n    }\r\n    proceedWithUpgrade_() {\r\n        // tell this connection to consider itself open\r\n        this.secondaryConn_.start();\r\n        // send ack\r\n        this.log_('sending client ack on secondary');\r\n        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\r\n        // send end packet on primary transport, switch to sending on this one\r\n        // can receive on this one, buffer responses until end received on primary transport\r\n        this.log_('Ending transmission on primary');\r\n        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\r\n        this.tx_ = this.secondaryConn_;\r\n        this.tryCleanupConnection();\r\n    }\r\n    onPrimaryMessageReceived_(parsedData) {\r\n        // Must refer to parsedData properties in quotes, so closure doesn't touch them.\r\n        const layer = requireKey('t', parsedData);\r\n        const data = requireKey('d', parsedData);\r\n        if (layer === 'c') {\r\n            this.onControl_(data);\r\n        }\r\n        else if (layer === 'd') {\r\n            this.onDataMessage_(data);\r\n        }\r\n    }\r\n    onDataMessage_(message) {\r\n        this.onPrimaryResponse_();\r\n        // We don't do anything with data messages, just kick them up a level\r\n        this.onMessage_(message);\r\n    }\r\n    onPrimaryResponse_() {\r\n        if (!this.isHealthy_) {\r\n            this.primaryResponsesRequired_--;\r\n            if (this.primaryResponsesRequired_ <= 0) {\r\n                this.log_('Primary connection is healthy.');\r\n                this.isHealthy_ = true;\r\n                this.conn_.markConnectionHealthy();\r\n            }\r\n        }\r\n    }\r\n    onControl_(controlData) {\r\n        const cmd = requireKey(MESSAGE_TYPE, controlData);\r\n        if (MESSAGE_DATA in controlData) {\r\n            const payload = controlData[MESSAGE_DATA];\r\n            if (cmd === SERVER_HELLO) {\r\n                const handshakePayload = Object.assign({}, payload);\r\n                if (this.repoInfo_.isUsingEmulator) {\r\n                    // Upon connecting, the emulator will pass the hostname that it's aware of, but we prefer the user's set hostname via `connectDatabaseEmulator` over what the emulator passes.\r\n                    handshakePayload.h = this.repoInfo_.host;\r\n                }\r\n                this.onHandshake_(handshakePayload);\r\n            }\r\n            else if (cmd === END_TRANSMISSION) {\r\n                this.log_('recvd end transmission on primary');\r\n                this.rx_ = this.secondaryConn_;\r\n                for (let i = 0; i < this.pendingDataMessages.length; ++i) {\r\n                    this.onDataMessage_(this.pendingDataMessages[i]);\r\n                }\r\n                this.pendingDataMessages = [];\r\n                this.tryCleanupConnection();\r\n            }\r\n            else if (cmd === CONTROL_SHUTDOWN) {\r\n                // This was previously the 'onKill' callback passed to the lower-level connection\r\n                // payload in this case is the reason for the shutdown. Generally a human-readable error\r\n                this.onConnectionShutdown_(payload);\r\n            }\r\n            else if (cmd === CONTROL_RESET) {\r\n                // payload in this case is the host we should contact\r\n                this.onReset_(payload);\r\n            }\r\n            else if (cmd === CONTROL_ERROR) {\r\n                error('Server Error: ' + payload);\r\n            }\r\n            else if (cmd === CONTROL_PONG) {\r\n                this.log_('got pong on primary.');\r\n                this.onPrimaryResponse_();\r\n                this.sendPingOnPrimaryIfNecessary_();\r\n            }\r\n            else {\r\n                error('Unknown control packet command: ' + cmd);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @param handshake - The handshake data returned from the server\r\n     */\r\n    onHandshake_(handshake) {\r\n        const timestamp = handshake.ts;\r\n        const version = handshake.v;\r\n        const host = handshake.h;\r\n        this.sessionId = handshake.s;\r\n        this.repoInfo_.host = host;\r\n        // if we've already closed the connection, then don't bother trying to progress further\r\n        if (this.state_ === 0 /* RealtimeState.CONNECTING */) {\r\n            this.conn_.start();\r\n            this.onConnectionEstablished_(this.conn_, timestamp);\r\n            if (PROTOCOL_VERSION !== version) {\r\n                warn('Protocol version mismatch detected');\r\n            }\r\n            // TODO: do we want to upgrade? when? maybe a delay?\r\n            this.tryStartUpgrade_();\r\n        }\r\n    }\r\n    tryStartUpgrade_() {\r\n        const conn = this.transportManager_.upgradeTransport();\r\n        if (conn) {\r\n            this.startUpgrade_(conn);\r\n        }\r\n    }\r\n    startUpgrade_(conn) {\r\n        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);\r\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\r\n        // can consider the transport healthy.\r\n        this.secondaryResponsesRequired_ =\r\n            conn['responsesRequiredToBeHealthy'] || 0;\r\n        const onMessage = this.connReceiver_(this.secondaryConn_);\r\n        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\r\n        this.secondaryConn_.open(onMessage, onDisconnect);\r\n        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\r\n        setTimeoutNonBlocking(() => {\r\n            if (this.secondaryConn_) {\r\n                this.log_('Timed out trying to upgrade.');\r\n                this.secondaryConn_.close();\r\n            }\r\n        }, Math.floor(UPGRADE_TIMEOUT));\r\n    }\r\n    onReset_(host) {\r\n        this.log_('Reset packet received.  New host: ' + host);\r\n        this.repoInfo_.host = host;\r\n        // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\r\n        // We don't currently support resets after the connection has already been established\r\n        if (this.state_ === 1 /* RealtimeState.CONNECTED */) {\r\n            this.close();\r\n        }\r\n        else {\r\n            // Close whatever connections we have open and start again.\r\n            this.closeConnections_();\r\n            this.start_();\r\n        }\r\n    }\r\n    onConnectionEstablished_(conn, timestamp) {\r\n        this.log_('Realtime connection established.');\r\n        this.conn_ = conn;\r\n        this.state_ = 1 /* RealtimeState.CONNECTED */;\r\n        if (this.onReady_) {\r\n            this.onReady_(timestamp, this.sessionId);\r\n            this.onReady_ = null;\r\n        }\r\n        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\r\n        // send some pings.\r\n        if (this.primaryResponsesRequired_ === 0) {\r\n            this.log_('Primary connection is healthy.');\r\n            this.isHealthy_ = true;\r\n        }\r\n        else {\r\n            setTimeoutNonBlocking(() => {\r\n                this.sendPingOnPrimaryIfNecessary_();\r\n            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\r\n        }\r\n    }\r\n    sendPingOnPrimaryIfNecessary_() {\r\n        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\r\n        if (!this.isHealthy_ && this.state_ === 1 /* RealtimeState.CONNECTED */) {\r\n            this.log_('sending ping on primary.');\r\n            this.sendData_({ t: 'c', d: { t: PING, d: {} } });\r\n        }\r\n    }\r\n    onSecondaryConnectionLost_() {\r\n        const conn = this.secondaryConn_;\r\n        this.secondaryConn_ = null;\r\n        if (this.tx_ === conn || this.rx_ === conn) {\r\n            // we are relying on this connection already in some capacity. Therefore, a failure is real\r\n            this.close();\r\n        }\r\n    }\r\n    /**\r\n     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if\r\n     * we should flush the host cache\r\n     */\r\n    onConnectionLost_(everConnected) {\r\n        this.conn_ = null;\r\n        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\r\n        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\r\n        if (!everConnected && this.state_ === 0 /* RealtimeState.CONNECTING */) {\r\n            this.log_('Realtime connection failed.');\r\n            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\r\n            if (this.repoInfo_.isCacheableHost()) {\r\n                PersistentStorage.remove('host:' + this.repoInfo_.host);\r\n                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\r\n                this.repoInfo_.internalHost = this.repoInfo_.host;\r\n            }\r\n        }\r\n        else if (this.state_ === 1 /* RealtimeState.CONNECTED */) {\r\n            this.log_('Realtime connection lost.');\r\n        }\r\n        this.close();\r\n    }\r\n    onConnectionShutdown_(reason) {\r\n        this.log_('Connection shutdown command received. Shutting down...');\r\n        if (this.onKill_) {\r\n            this.onKill_(reason);\r\n            this.onKill_ = null;\r\n        }\r\n        // We intentionally don't want to fire onDisconnect (kill is a different case),\r\n        // so clear the callback.\r\n        this.onDisconnect_ = null;\r\n        this.close();\r\n    }\r\n    sendData_(data) {\r\n        if (this.state_ !== 1 /* RealtimeState.CONNECTED */) {\r\n            throw 'Connection is not connected';\r\n        }\r\n        else {\r\n            this.tx_.send(data);\r\n        }\r\n    }\r\n    /**\r\n     * Cleans up this connection, calling the appropriate callbacks\r\n     */\r\n    close() {\r\n        if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */) {\r\n            this.log_('Closing realtime connection.');\r\n            this.state_ = 2 /* RealtimeState.DISCONNECTED */;\r\n            this.closeConnections_();\r\n            if (this.onDisconnect_) {\r\n                this.onDisconnect_();\r\n                this.onDisconnect_ = null;\r\n            }\r\n        }\r\n    }\r\n    closeConnections_() {\r\n        this.log_('Shutting down all connections');\r\n        if (this.conn_) {\r\n            this.conn_.close();\r\n            this.conn_ = null;\r\n        }\r\n        if (this.secondaryConn_) {\r\n            this.secondaryConn_.close();\r\n            this.secondaryConn_ = null;\r\n        }\r\n        if (this.healthyTimeout_) {\r\n            clearTimeout(this.healthyTimeout_);\r\n            this.healthyTimeout_ = null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Interface defining the set of actions that can be performed against the Firebase server\r\n * (basically corresponds to our wire protocol).\r\n *\r\n * @interface\r\n */\r\nclass ServerActions {\r\n    put(pathString, data, onComplete, hash) { }\r\n    merge(pathString, data, onComplete, hash) { }\r\n    /**\r\n     * Refreshes the auth token for the current connection.\r\n     * @param token - The authentication token\r\n     */\r\n    refreshAuthToken(token) { }\r\n    /**\r\n     * Refreshes the app check token for the current connection.\r\n     * @param token The app check token\r\n     */\r\n    refreshAppCheckToken(token) { }\r\n    onDisconnectPut(pathString, data, onComplete) { }\r\n    onDisconnectMerge(pathString, data, onComplete) { }\r\n    onDisconnectCancel(pathString, onComplete) { }\r\n    reportStats(stats) { }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Base class to be used if you want to emit events. Call the constructor with\r\n * the set of allowed event names.\r\n */\r\nclass EventEmitter {\r\n    constructor(allowedEvents_) {\r\n        this.allowedEvents_ = allowedEvents_;\r\n        this.listeners_ = {};\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');\r\n    }\r\n    /**\r\n     * To be called by derived classes to trigger events.\r\n     */\r\n    trigger(eventType, ...varArgs) {\r\n        if (Array.isArray(this.listeners_[eventType])) {\r\n            // Clone the list, since callbacks could add/remove listeners.\r\n            const listeners = [...this.listeners_[eventType]];\r\n            for (let i = 0; i < listeners.length; i++) {\r\n                listeners[i].callback.apply(listeners[i].context, varArgs);\r\n            }\r\n        }\r\n    }\r\n    on(eventType, callback, context) {\r\n        this.validateEventType_(eventType);\r\n        this.listeners_[eventType] = this.listeners_[eventType] || [];\r\n        this.listeners_[eventType].push({ callback, context });\r\n        const eventData = this.getInitialEvent(eventType);\r\n        if (eventData) {\r\n            callback.apply(context, eventData);\r\n        }\r\n    }\r\n    off(eventType, callback, context) {\r\n        this.validateEventType_(eventType);\r\n        const listeners = this.listeners_[eventType] || [];\r\n        for (let i = 0; i < listeners.length; i++) {\r\n            if (listeners[i].callback === callback &&\r\n                (!context || context === listeners[i].context)) {\r\n                listeners.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    validateEventType_(eventType) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.allowedEvents_.find(et => {\r\n            return et === eventType;\r\n        }), 'Unknown event: ' + eventType);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Monitors online state (as reported by window.online/offline events).\r\n *\r\n * The expectation is that this could have many false positives (thinks we are online\r\n * when we're not), but no false negatives.  So we can safely use it to determine when\r\n * we definitely cannot reach the internet.\r\n */\r\nclass OnlineMonitor extends EventEmitter {\r\n    constructor() {\r\n        super(['online']);\r\n        this.online_ = true;\r\n        // We've had repeated complaints that Cordova apps can get stuck \"offline\", e.g.\r\n        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810\r\n        // It would seem that the 'online' event does not always fire consistently. So we disable it\r\n        // for Cordova.\r\n        if (typeof window !== 'undefined' &&\r\n            typeof window.addEventListener !== 'undefined' &&\r\n            !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isMobileCordova)()) {\r\n            window.addEventListener('online', () => {\r\n                if (!this.online_) {\r\n                    this.online_ = true;\r\n                    this.trigger('online', true);\r\n                }\r\n            }, false);\r\n            window.addEventListener('offline', () => {\r\n                if (this.online_) {\r\n                    this.online_ = false;\r\n                    this.trigger('online', false);\r\n                }\r\n            }, false);\r\n        }\r\n    }\r\n    static getInstance() {\r\n        return new OnlineMonitor();\r\n    }\r\n    getInitialEvent(eventType) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventType === 'online', 'Unknown event type: ' + eventType);\r\n        return [this.online_];\r\n    }\r\n    currentlyOnline() {\r\n        return this.online_;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Maximum key depth. */\r\nconst MAX_PATH_DEPTH = 32;\r\n/** Maximum number of (UTF8) bytes in a Firebase path. */\r\nconst MAX_PATH_LENGTH_BYTES = 768;\r\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */\r\nclass Path {\r\n    /**\r\n     * @param pathOrString - Path string to parse, or another path, or the raw\r\n     * tokens array\r\n     */\r\n    constructor(pathOrString, pieceNum) {\r\n        if (pieceNum === void 0) {\r\n            this.pieces_ = pathOrString.split('/');\r\n            // Remove empty pieces.\r\n            let copyTo = 0;\r\n            for (let i = 0; i < this.pieces_.length; i++) {\r\n                if (this.pieces_[i].length > 0) {\r\n                    this.pieces_[copyTo] = this.pieces_[i];\r\n                    copyTo++;\r\n                }\r\n            }\r\n            this.pieces_.length = copyTo;\r\n            this.pieceNum_ = 0;\r\n        }\r\n        else {\r\n            this.pieces_ = pathOrString;\r\n            this.pieceNum_ = pieceNum;\r\n        }\r\n    }\r\n    toString() {\r\n        let pathString = '';\r\n        for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\r\n            if (this.pieces_[i] !== '') {\r\n                pathString += '/' + this.pieces_[i];\r\n            }\r\n        }\r\n        return pathString || '/';\r\n    }\r\n}\r\nfunction newEmptyPath() {\r\n    return new Path('');\r\n}\r\nfunction pathGetFront(path) {\r\n    if (path.pieceNum_ >= path.pieces_.length) {\r\n        return null;\r\n    }\r\n    return path.pieces_[path.pieceNum_];\r\n}\r\n/**\r\n * @returns The number of segments in this path\r\n */\r\nfunction pathGetLength(path) {\r\n    return path.pieces_.length - path.pieceNum_;\r\n}\r\nfunction pathPopFront(path) {\r\n    let pieceNum = path.pieceNum_;\r\n    if (pieceNum < path.pieces_.length) {\r\n        pieceNum++;\r\n    }\r\n    return new Path(path.pieces_, pieceNum);\r\n}\r\nfunction pathGetBack(path) {\r\n    if (path.pieceNum_ < path.pieces_.length) {\r\n        return path.pieces_[path.pieces_.length - 1];\r\n    }\r\n    return null;\r\n}\r\nfunction pathToUrlEncodedString(path) {\r\n    let pathString = '';\r\n    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {\r\n        if (path.pieces_[i] !== '') {\r\n            pathString += '/' + encodeURIComponent(String(path.pieces_[i]));\r\n        }\r\n    }\r\n    return pathString || '/';\r\n}\r\n/**\r\n * Shallow copy of the parts of the path.\r\n *\r\n */\r\nfunction pathSlice(path, begin = 0) {\r\n    return path.pieces_.slice(path.pieceNum_ + begin);\r\n}\r\nfunction pathParent(path) {\r\n    if (path.pieceNum_ >= path.pieces_.length) {\r\n        return null;\r\n    }\r\n    const pieces = [];\r\n    for (let i = path.pieceNum_; i < path.pieces_.length - 1; i++) {\r\n        pieces.push(path.pieces_[i]);\r\n    }\r\n    return new Path(pieces, 0);\r\n}\r\nfunction pathChild(path, childPathObj) {\r\n    const pieces = [];\r\n    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {\r\n        pieces.push(path.pieces_[i]);\r\n    }\r\n    if (childPathObj instanceof Path) {\r\n        for (let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {\r\n            pieces.push(childPathObj.pieces_[i]);\r\n        }\r\n    }\r\n    else {\r\n        const childPieces = childPathObj.split('/');\r\n        for (let i = 0; i < childPieces.length; i++) {\r\n            if (childPieces[i].length > 0) {\r\n                pieces.push(childPieces[i]);\r\n            }\r\n        }\r\n    }\r\n    return new Path(pieces, 0);\r\n}\r\n/**\r\n * @returns True if there are no segments in this path\r\n */\r\nfunction pathIsEmpty(path) {\r\n    return path.pieceNum_ >= path.pieces_.length;\r\n}\r\n/**\r\n * @returns The path from outerPath to innerPath\r\n */\r\nfunction newRelativePath(outerPath, innerPath) {\r\n    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);\r\n    if (outer === null) {\r\n        return innerPath;\r\n    }\r\n    else if (outer === inner) {\r\n        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));\r\n    }\r\n    else {\r\n        throw new Error('INTERNAL ERROR: innerPath (' +\r\n            innerPath +\r\n            ') is not within ' +\r\n            'outerPath (' +\r\n            outerPath +\r\n            ')');\r\n    }\r\n}\r\n/**\r\n * @returns -1, 0, 1 if left is less, equal, or greater than the right.\r\n */\r\nfunction pathCompare(left, right) {\r\n    const leftKeys = pathSlice(left, 0);\r\n    const rightKeys = pathSlice(right, 0);\r\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\r\n        const cmp = nameCompare(leftKeys[i], rightKeys[i]);\r\n        if (cmp !== 0) {\r\n            return cmp;\r\n        }\r\n    }\r\n    if (leftKeys.length === rightKeys.length) {\r\n        return 0;\r\n    }\r\n    return leftKeys.length < rightKeys.length ? -1 : 1;\r\n}\r\n/**\r\n * @returns true if paths are the same.\r\n */\r\nfunction pathEquals(path, other) {\r\n    if (pathGetLength(path) !== pathGetLength(other)) {\r\n        return false;\r\n    }\r\n    for (let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) {\r\n        if (path.pieces_[i] !== other.pieces_[j]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * @returns True if this path is a parent of (or the same as) other\r\n */\r\nfunction pathContains(path, other) {\r\n    let i = path.pieceNum_;\r\n    let j = other.pieceNum_;\r\n    if (pathGetLength(path) > pathGetLength(other)) {\r\n        return false;\r\n    }\r\n    while (i < path.pieces_.length) {\r\n        if (path.pieces_[i] !== other.pieces_[j]) {\r\n            return false;\r\n        }\r\n        ++i;\r\n        ++j;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */\r\nclass ValidationPath {\r\n    /**\r\n     * @param path - Initial Path.\r\n     * @param errorPrefix_ - Prefix for any error messages.\r\n     */\r\n    constructor(path, errorPrefix_) {\r\n        this.errorPrefix_ = errorPrefix_;\r\n        this.parts_ = pathSlice(path, 0);\r\n        /** Initialize to number of '/' chars needed in path. */\r\n        this.byteLength_ = Math.max(1, this.parts_.length);\r\n        for (let i = 0; i < this.parts_.length; i++) {\r\n            this.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(this.parts_[i]);\r\n        }\r\n        validationPathCheckValid(this);\r\n    }\r\n}\r\nfunction validationPathPush(validationPath, child) {\r\n    // Count the needed '/'\r\n    if (validationPath.parts_.length > 0) {\r\n        validationPath.byteLength_ += 1;\r\n    }\r\n    validationPath.parts_.push(child);\r\n    validationPath.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(child);\r\n    validationPathCheckValid(validationPath);\r\n}\r\nfunction validationPathPop(validationPath) {\r\n    const last = validationPath.parts_.pop();\r\n    validationPath.byteLength_ -= (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(last);\r\n    // Un-count the previous '/'\r\n    if (validationPath.parts_.length > 0) {\r\n        validationPath.byteLength_ -= 1;\r\n    }\r\n}\r\nfunction validationPathCheckValid(validationPath) {\r\n    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {\r\n        throw new Error(validationPath.errorPrefix_ +\r\n            'has a key path longer than ' +\r\n            MAX_PATH_LENGTH_BYTES +\r\n            ' bytes (' +\r\n            validationPath.byteLength_ +\r\n            ').');\r\n    }\r\n    if (validationPath.parts_.length > MAX_PATH_DEPTH) {\r\n        throw new Error(validationPath.errorPrefix_ +\r\n            'path specified exceeds the maximum depth that can be written (' +\r\n            MAX_PATH_DEPTH +\r\n            ') or object contains a cycle ' +\r\n            validationPathToErrorString(validationPath));\r\n    }\r\n}\r\n/**\r\n * String for use in error messages - uses '.' notation for path.\r\n */\r\nfunction validationPathToErrorString(validationPath) {\r\n    if (validationPath.parts_.length === 0) {\r\n        return '';\r\n    }\r\n    return \"in property '\" + validationPath.parts_.join('.') + \"'\";\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass VisibilityMonitor extends EventEmitter {\r\n    constructor() {\r\n        super(['visible']);\r\n        let hidden;\r\n        let visibilityChange;\r\n        if (typeof document !== 'undefined' &&\r\n            typeof document.addEventListener !== 'undefined') {\r\n            if (typeof document['hidden'] !== 'undefined') {\r\n                // Opera 12.10 and Firefox 18 and later support\r\n                visibilityChange = 'visibilitychange';\r\n                hidden = 'hidden';\r\n            }\r\n            else if (typeof document['mozHidden'] !== 'undefined') {\r\n                visibilityChange = 'mozvisibilitychange';\r\n                hidden = 'mozHidden';\r\n            }\r\n            else if (typeof document['msHidden'] !== 'undefined') {\r\n                visibilityChange = 'msvisibilitychange';\r\n                hidden = 'msHidden';\r\n            }\r\n            else if (typeof document['webkitHidden'] !== 'undefined') {\r\n                visibilityChange = 'webkitvisibilitychange';\r\n                hidden = 'webkitHidden';\r\n            }\r\n        }\r\n        // Initially, we always assume we are visible. This ensures that in browsers\r\n        // without page visibility support or in cases where we are never visible\r\n        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay\r\n        // reconnects\r\n        this.visible_ = true;\r\n        if (visibilityChange) {\r\n            document.addEventListener(visibilityChange, () => {\r\n                const visible = !document[hidden];\r\n                if (visible !== this.visible_) {\r\n                    this.visible_ = visible;\r\n                    this.trigger('visible', visible);\r\n                }\r\n            }, false);\r\n        }\r\n    }\r\n    static getInstance() {\r\n        return new VisibilityMonitor();\r\n    }\r\n    getInitialEvent(eventType) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventType === 'visible', 'Unknown event type: ' + eventType);\r\n        return [this.visible_];\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst RECONNECT_MIN_DELAY = 1000;\r\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\r\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\r\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\r\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\r\nconst SERVER_KILL_INTERRUPT_REASON = 'server_kill';\r\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\r\nconst INVALID_TOKEN_THRESHOLD = 3;\r\n/**\r\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\r\n *\r\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\r\n * in quotes to make sure the closure compiler does not minify them.\r\n */\r\nclass PersistentConnection extends ServerActions {\r\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param applicationId_ - The Firebase App ID for this project\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */\r\n    constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {\r\n        super();\r\n        this.repoInfo_ = repoInfo_;\r\n        this.applicationId_ = applicationId_;\r\n        this.onDataUpdate_ = onDataUpdate_;\r\n        this.onConnectStatus_ = onConnectStatus_;\r\n        this.onServerInfoUpdate_ = onServerInfoUpdate_;\r\n        this.authTokenProvider_ = authTokenProvider_;\r\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\r\n        this.authOverride_ = authOverride_;\r\n        // Used for diagnostic logging.\r\n        this.id = PersistentConnection.nextPersistentConnectionId_++;\r\n        this.log_ = logWrapper('p:' + this.id + ':');\r\n        this.interruptReasons_ = {};\r\n        this.listens = new Map();\r\n        this.outstandingPuts_ = [];\r\n        this.outstandingGets_ = [];\r\n        this.outstandingPutCount_ = 0;\r\n        this.outstandingGetCount_ = 0;\r\n        this.onDisconnectRequestQueue_ = [];\r\n        this.connected_ = false;\r\n        this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\r\n        this.securityDebugCallback_ = null;\r\n        this.lastSessionId = null;\r\n        this.establishConnectionTimer_ = null;\r\n        this.visible_ = false;\r\n        // Before we get connected, we keep a queue of pending messages to send.\r\n        this.requestCBHash_ = {};\r\n        this.requestNumber_ = 0;\r\n        this.realtime_ = null;\r\n        this.authToken_ = null;\r\n        this.appCheckToken_ = null;\r\n        this.forceTokenRefresh_ = false;\r\n        this.invalidAuthTokenCount_ = 0;\r\n        this.invalidAppCheckTokenCount_ = 0;\r\n        this.firstConnection_ = true;\r\n        this.lastConnectionAttemptTime_ = null;\r\n        this.lastConnectionEstablishedTime_ = null;\r\n        if (authOverride_ && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');\r\n        }\r\n        VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);\r\n        if (repoInfo_.host.indexOf('fblocal') === -1) {\r\n            OnlineMonitor.getInstance().on('online', this.onOnline_, this);\r\n        }\r\n    }\r\n    sendRequest(action, body, onResponse) {\r\n        const curReqNum = ++this.requestNumber_;\r\n        const msg = { r: curReqNum, a: action, b: body };\r\n        this.log_((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(msg));\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected_, \"sendRequest call when we're not connected not allowed.\");\r\n        this.realtime_.sendRequest(msg);\r\n        if (onResponse) {\r\n            this.requestCBHash_[curReqNum] = onResponse;\r\n        }\r\n    }\r\n    get(query) {\r\n        this.initConnection_();\r\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        const request = {\r\n            p: query._path.toString(),\r\n            q: query._queryObject\r\n        };\r\n        const outstandingGet = {\r\n            action: 'g',\r\n            request,\r\n            onComplete: (message) => {\r\n                const payload = message['d'];\r\n                if (message['s'] === 'ok') {\r\n                    deferred.resolve(payload);\r\n                }\r\n                else {\r\n                    deferred.reject(payload);\r\n                }\r\n            }\r\n        };\r\n        this.outstandingGets_.push(outstandingGet);\r\n        this.outstandingGetCount_++;\r\n        const index = this.outstandingGets_.length - 1;\r\n        if (this.connected_) {\r\n            this.sendGet_(index);\r\n        }\r\n        return deferred.promise;\r\n    }\r\n    listen(query, currentHashFn, tag, onComplete) {\r\n        this.initConnection_();\r\n        const queryId = query._queryIdentifier;\r\n        const pathString = query._path.toString();\r\n        this.log_('Listen called for ' + pathString + ' ' + queryId);\r\n        if (!this.listens.has(pathString)) {\r\n            this.listens.set(pathString, new Map());\r\n        }\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'listen() called for non-default but complete query');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);\r\n        const listenSpec = {\r\n            onComplete,\r\n            hashFn: currentHashFn,\r\n            query,\r\n            tag\r\n        };\r\n        this.listens.get(pathString).set(queryId, listenSpec);\r\n        if (this.connected_) {\r\n            this.sendListen_(listenSpec);\r\n        }\r\n    }\r\n    sendGet_(index) {\r\n        const get = this.outstandingGets_[index];\r\n        this.sendRequest('g', get.request, (message) => {\r\n            delete this.outstandingGets_[index];\r\n            this.outstandingGetCount_--;\r\n            if (this.outstandingGetCount_ === 0) {\r\n                this.outstandingGets_ = [];\r\n            }\r\n            if (get.onComplete) {\r\n                get.onComplete(message);\r\n            }\r\n        });\r\n    }\r\n    sendListen_(listenSpec) {\r\n        const query = listenSpec.query;\r\n        const pathString = query._path.toString();\r\n        const queryId = query._queryIdentifier;\r\n        this.log_('Listen on ' + pathString + ' for ' + queryId);\r\n        const req = { /*path*/ p: pathString };\r\n        const action = 'q';\r\n        // Only bother to send query if it's non-default.\r\n        if (listenSpec.tag) {\r\n            req['q'] = query._queryObject;\r\n            req['t'] = listenSpec.tag;\r\n        }\r\n        req[ /*hash*/'h'] = listenSpec.hashFn();\r\n        this.sendRequest(action, req, (message) => {\r\n            const payload = message[ /*data*/'d'];\r\n            const status = message[ /*status*/'s'];\r\n            // print warnings in any case...\r\n            PersistentConnection.warnOnListenWarnings_(payload, query);\r\n            const currentListenSpec = this.listens.get(pathString) &&\r\n                this.listens.get(pathString).get(queryId);\r\n            // only trigger actions if the listen hasn't been removed and readded\r\n            if (currentListenSpec === listenSpec) {\r\n                this.log_('listen response', message);\r\n                if (status !== 'ok') {\r\n                    this.removeListen_(pathString, queryId);\r\n                }\r\n                if (listenSpec.onComplete) {\r\n                    listenSpec.onComplete(status, payload);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    static warnOnListenWarnings_(payload, query) {\r\n        if (payload && typeof payload === 'object' && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(payload, 'w')) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const warnings = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(payload, 'w');\r\n            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\r\n                const indexSpec = '\".indexOn\": \"' + query._queryParams.getIndex().toString() + '\"';\r\n                const indexPath = query._path.toString();\r\n                warn(`Using an unspecified index. Your data will be downloaded and ` +\r\n                    `filtered on the client. Consider adding ${indexSpec} at ` +\r\n                    `${indexPath} to your security rules for better performance.`);\r\n            }\r\n        }\r\n    }\r\n    refreshAuthToken(token) {\r\n        this.authToken_ = token;\r\n        this.log_('Auth token refreshed');\r\n        if (this.authToken_) {\r\n            this.tryAuth();\r\n        }\r\n        else {\r\n            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\r\n            //the credential so we dont become authenticated next time we connect.\r\n            if (this.connected_) {\r\n                this.sendRequest('unauth', {}, () => { });\r\n            }\r\n        }\r\n        this.reduceReconnectDelayIfAdminCredential_(token);\r\n    }\r\n    reduceReconnectDelayIfAdminCredential_(credential) {\r\n        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\r\n        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\r\n        const isFirebaseSecret = credential && credential.length === 40;\r\n        if (isFirebaseSecret || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isAdmin)(credential)) {\r\n            this.log_('Admin auth credential detected.  Reducing max reconnect time.');\r\n            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\r\n        }\r\n    }\r\n    refreshAppCheckToken(token) {\r\n        this.appCheckToken_ = token;\r\n        this.log_('App check token refreshed');\r\n        if (this.appCheckToken_) {\r\n            this.tryAppCheck();\r\n        }\r\n        else {\r\n            //If we're connected we want to let the server know to unauthenticate us.\r\n            //If we're not connected, simply delete the credential so we dont become\r\n            // authenticated next time we connect.\r\n            if (this.connected_) {\r\n                this.sendRequest('unappeck', {}, () => { });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\r\n     * a auth revoked (the connection is closed).\r\n     */\r\n    tryAuth() {\r\n        if (this.connected_ && this.authToken_) {\r\n            const token = this.authToken_;\r\n            const authMethod = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isValidFormat)(token) ? 'auth' : 'gauth';\r\n            const requestData = { cred: token };\r\n            if (this.authOverride_ === null) {\r\n                requestData['noauth'] = true;\r\n            }\r\n            else if (typeof this.authOverride_ === 'object') {\r\n                requestData['authvar'] = this.authOverride_;\r\n            }\r\n            this.sendRequest(authMethod, requestData, (res) => {\r\n                const status = res[ /*status*/'s'];\r\n                const data = res[ /*data*/'d'] || 'error';\r\n                if (this.authToken_ === token) {\r\n                    if (status === 'ok') {\r\n                        this.invalidAuthTokenCount_ = 0;\r\n                    }\r\n                    else {\r\n                        // Triggers reconnect and force refresh for auth token\r\n                        this.onAuthRevoked_(status, data);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to authenticate with the given token. If the authentication\r\n     * attempt fails, it's triggered like the token was revoked (the connection is\r\n     * closed).\r\n     */\r\n    tryAppCheck() {\r\n        if (this.connected_ && this.appCheckToken_) {\r\n            this.sendRequest('appcheck', { 'token': this.appCheckToken_ }, (res) => {\r\n                const status = res[ /*status*/'s'];\r\n                const data = res[ /*data*/'d'] || 'error';\r\n                if (status === 'ok') {\r\n                    this.invalidAppCheckTokenCount_ = 0;\r\n                }\r\n                else {\r\n                    this.onAppCheckRevoked_(status, data);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    unlisten(query, tag) {\r\n        const pathString = query._path.toString();\r\n        const queryId = query._queryIdentifier;\r\n        this.log_('Unlisten called for ' + pathString + ' ' + queryId);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'unlisten() called for non-default but complete query');\r\n        const listen = this.removeListen_(pathString, queryId);\r\n        if (listen && this.connected_) {\r\n            this.sendUnlisten_(pathString, queryId, query._queryObject, tag);\r\n        }\r\n    }\r\n    sendUnlisten_(pathString, queryId, queryObj, tag) {\r\n        this.log_('Unlisten on ' + pathString + ' for ' + queryId);\r\n        const req = { /*path*/ p: pathString };\r\n        const action = 'n';\r\n        // Only bother sending queryId if it's non-default.\r\n        if (tag) {\r\n            req['q'] = queryObj;\r\n            req['t'] = tag;\r\n        }\r\n        this.sendRequest(action, req);\r\n    }\r\n    onDisconnectPut(pathString, data, onComplete) {\r\n        this.initConnection_();\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('o', pathString, data, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString,\r\n                action: 'o',\r\n                data,\r\n                onComplete\r\n            });\r\n        }\r\n    }\r\n    onDisconnectMerge(pathString, data, onComplete) {\r\n        this.initConnection_();\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('om', pathString, data, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString,\r\n                action: 'om',\r\n                data,\r\n                onComplete\r\n            });\r\n        }\r\n    }\r\n    onDisconnectCancel(pathString, onComplete) {\r\n        this.initConnection_();\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('oc', pathString, null, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString,\r\n                action: 'oc',\r\n                data: null,\r\n                onComplete\r\n            });\r\n        }\r\n    }\r\n    sendOnDisconnect_(action, pathString, data, onComplete) {\r\n        const request = { /*path*/ p: pathString, /*data*/ d: data };\r\n        this.log_('onDisconnect ' + action, request);\r\n        this.sendRequest(action, request, (response) => {\r\n            if (onComplete) {\r\n                setTimeout(() => {\r\n                    onComplete(response[ /*status*/'s'], response[ /* data */'d']);\r\n                }, Math.floor(0));\r\n            }\r\n        });\r\n    }\r\n    put(pathString, data, onComplete, hash) {\r\n        this.putInternal('p', pathString, data, onComplete, hash);\r\n    }\r\n    merge(pathString, data, onComplete, hash) {\r\n        this.putInternal('m', pathString, data, onComplete, hash);\r\n    }\r\n    putInternal(action, pathString, data, onComplete, hash) {\r\n        this.initConnection_();\r\n        const request = {\r\n            /*path*/ p: pathString,\r\n            /*data*/ d: data\r\n        };\r\n        if (hash !== undefined) {\r\n            request[ /*hash*/'h'] = hash;\r\n        }\r\n        // TODO: Only keep track of the most recent put for a given path?\r\n        this.outstandingPuts_.push({\r\n            action,\r\n            request,\r\n            onComplete\r\n        });\r\n        this.outstandingPutCount_++;\r\n        const index = this.outstandingPuts_.length - 1;\r\n        if (this.connected_) {\r\n            this.sendPut_(index);\r\n        }\r\n        else {\r\n            this.log_('Buffering put: ' + pathString);\r\n        }\r\n    }\r\n    sendPut_(index) {\r\n        const action = this.outstandingPuts_[index].action;\r\n        const request = this.outstandingPuts_[index].request;\r\n        const onComplete = this.outstandingPuts_[index].onComplete;\r\n        this.outstandingPuts_[index].queued = this.connected_;\r\n        this.sendRequest(action, request, (message) => {\r\n            this.log_(action + ' response', message);\r\n            delete this.outstandingPuts_[index];\r\n            this.outstandingPutCount_--;\r\n            // Clean up array occasionally.\r\n            if (this.outstandingPutCount_ === 0) {\r\n                this.outstandingPuts_ = [];\r\n            }\r\n            if (onComplete) {\r\n                onComplete(message[ /*status*/'s'], message[ /* data */'d']);\r\n            }\r\n        });\r\n    }\r\n    reportStats(stats) {\r\n        // If we're not connected, we just drop the stats.\r\n        if (this.connected_) {\r\n            const request = { /*counters*/ c: stats };\r\n            this.log_('reportStats', request);\r\n            this.sendRequest(/*stats*/ 's', request, result => {\r\n                const status = result[ /*status*/'s'];\r\n                if (status !== 'ok') {\r\n                    const errorReason = result[ /* data */'d'];\r\n                    this.log_('reportStats', 'Error sending stats: ' + errorReason);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    onDataMessage_(message) {\r\n        if ('r' in message) {\r\n            // this is a response\r\n            this.log_('from server: ' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(message));\r\n            const reqNum = message['r'];\r\n            const onResponse = this.requestCBHash_[reqNum];\r\n            if (onResponse) {\r\n                delete this.requestCBHash_[reqNum];\r\n                onResponse(message[ /*body*/'b']);\r\n            }\r\n        }\r\n        else if ('error' in message) {\r\n            throw 'A server-side error has occurred: ' + message['error'];\r\n        }\r\n        else if ('a' in message) {\r\n            // a and b are action and body, respectively\r\n            this.onDataPush_(message['a'], message['b']);\r\n        }\r\n    }\r\n    onDataPush_(action, body) {\r\n        this.log_('handleServerMessage', action, body);\r\n        if (action === 'd') {\r\n            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], \r\n            /*isMerge*/ false, body['t']);\r\n        }\r\n        else if (action === 'm') {\r\n            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], \r\n            /*isMerge=*/ true, body['t']);\r\n        }\r\n        else if (action === 'c') {\r\n            this.onListenRevoked_(body[ /*path*/'p'], body[ /*query*/'q']);\r\n        }\r\n        else if (action === 'ac') {\r\n            this.onAuthRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);\r\n        }\r\n        else if (action === 'apc') {\r\n            this.onAppCheckRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);\r\n        }\r\n        else if (action === 'sd') {\r\n            this.onSecurityDebugPacket_(body);\r\n        }\r\n        else {\r\n            error('Unrecognized action received from server: ' +\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(action) +\r\n                '\\nAre you using the latest client?');\r\n        }\r\n    }\r\n    onReady_(timestamp, sessionId) {\r\n        this.log_('connection ready');\r\n        this.connected_ = true;\r\n        this.lastConnectionEstablishedTime_ = new Date().getTime();\r\n        this.handleTimestamp_(timestamp);\r\n        this.lastSessionId = sessionId;\r\n        if (this.firstConnection_) {\r\n            this.sendConnectStats_();\r\n        }\r\n        this.restoreState_();\r\n        this.firstConnection_ = false;\r\n        this.onConnectStatus_(true);\r\n    }\r\n    scheduleConnect_(timeout) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\r\n        if (this.establishConnectionTimer_) {\r\n            clearTimeout(this.establishConnectionTimer_);\r\n        }\r\n        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\r\n        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\r\n        this.establishConnectionTimer_ = setTimeout(() => {\r\n            this.establishConnectionTimer_ = null;\r\n            this.establishConnection_();\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(timeout));\r\n    }\r\n    initConnection_() {\r\n        if (!this.realtime_ && this.firstConnection_) {\r\n            this.scheduleConnect_(0);\r\n        }\r\n    }\r\n    onVisible_(visible) {\r\n        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\r\n        if (visible &&\r\n            !this.visible_ &&\r\n            this.reconnectDelay_ === this.maxReconnectDelay_) {\r\n            this.log_('Window became visible.  Reducing delay.');\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n        this.visible_ = visible;\r\n    }\r\n    onOnline_(online) {\r\n        if (online) {\r\n            this.log_('Browser went online.');\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n        else {\r\n            this.log_('Browser went offline.  Killing connection.');\r\n            if (this.realtime_) {\r\n                this.realtime_.close();\r\n            }\r\n        }\r\n    }\r\n    onRealtimeDisconnect_() {\r\n        this.log_('data client disconnected');\r\n        this.connected_ = false;\r\n        this.realtime_ = null;\r\n        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\r\n        this.cancelSentTransactions_();\r\n        // Clear out the pending requests.\r\n        this.requestCBHash_ = {};\r\n        if (this.shouldReconnect_()) {\r\n            if (!this.visible_) {\r\n                this.log_(\"Window isn't visible.  Delaying reconnect.\");\r\n                this.reconnectDelay_ = this.maxReconnectDelay_;\r\n                this.lastConnectionAttemptTime_ = new Date().getTime();\r\n            }\r\n            else if (this.lastConnectionEstablishedTime_) {\r\n                // If we've been connected long enough, reset reconnect delay to minimum.\r\n                const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\r\n                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {\r\n                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n                }\r\n                this.lastConnectionEstablishedTime_ = null;\r\n            }\r\n            const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\r\n            let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\r\n            reconnectDelay = Math.random() * reconnectDelay;\r\n            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\r\n            this.scheduleConnect_(reconnectDelay);\r\n            // Adjust reconnect delay for next time.\r\n            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\r\n        }\r\n        this.onConnectStatus_(false);\r\n    }\r\n    async establishConnection_() {\r\n        if (this.shouldReconnect_()) {\r\n            this.log_('Making a connection attempt');\r\n            this.lastConnectionAttemptTime_ = new Date().getTime();\r\n            this.lastConnectionEstablishedTime_ = null;\r\n            const onDataMessage = this.onDataMessage_.bind(this);\r\n            const onReady = this.onReady_.bind(this);\r\n            const onDisconnect = this.onRealtimeDisconnect_.bind(this);\r\n            const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;\r\n            const lastSessionId = this.lastSessionId;\r\n            let canceled = false;\r\n            let connection = null;\r\n            const closeFn = function () {\r\n                if (connection) {\r\n                    connection.close();\r\n                }\r\n                else {\r\n                    canceled = true;\r\n                    onDisconnect();\r\n                }\r\n            };\r\n            const sendRequestFn = function (msg) {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(connection, \"sendRequest call when we're not connected not allowed.\");\r\n                connection.sendRequest(msg);\r\n            };\r\n            this.realtime_ = {\r\n                close: closeFn,\r\n                sendRequest: sendRequestFn\r\n            };\r\n            const forceRefresh = this.forceTokenRefresh_;\r\n            this.forceTokenRefresh_ = false;\r\n            try {\r\n                // First fetch auth and app check token, and establish connection after\r\n                // fetching the token was successful\r\n                const [authToken, appCheckToken] = await Promise.all([\r\n                    this.authTokenProvider_.getToken(forceRefresh),\r\n                    this.appCheckTokenProvider_.getToken(forceRefresh)\r\n                ]);\r\n                if (!canceled) {\r\n                    log('getToken() completed. Creating connection.');\r\n                    this.authToken_ = authToken && authToken.accessToken;\r\n                    this.appCheckToken_ = appCheckToken && appCheckToken.token;\r\n                    connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, \r\n                    /* onKill= */ reason => {\r\n                        warn(reason + ' (' + this.repoInfo_.toString() + ')');\r\n                        this.interrupt(SERVER_KILL_INTERRUPT_REASON);\r\n                    }, lastSessionId);\r\n                }\r\n                else {\r\n                    log('getToken() completed but was canceled');\r\n                }\r\n            }\r\n            catch (error) {\r\n                this.log_('Failed to get token: ' + error);\r\n                if (!canceled) {\r\n                    if (this.repoInfo_.nodeAdmin) {\r\n                        // This may be a critical error for the Admin Node.js SDK, so log a warning.\r\n                        // But getToken() may also just have temporarily failed, so we still want to\r\n                        // continue retrying.\r\n                        warn(error);\r\n                    }\r\n                    closeFn();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    interrupt(reason) {\r\n        log('Interrupting connection for reason: ' + reason);\r\n        this.interruptReasons_[reason] = true;\r\n        if (this.realtime_) {\r\n            this.realtime_.close();\r\n        }\r\n        else {\r\n            if (this.establishConnectionTimer_) {\r\n                clearTimeout(this.establishConnectionTimer_);\r\n                this.establishConnectionTimer_ = null;\r\n            }\r\n            if (this.connected_) {\r\n                this.onRealtimeDisconnect_();\r\n            }\r\n        }\r\n    }\r\n    resume(reason) {\r\n        log('Resuming connection for reason: ' + reason);\r\n        delete this.interruptReasons_[reason];\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.interruptReasons_)) {\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n    }\r\n    handleTimestamp_(timestamp) {\r\n        const delta = timestamp - new Date().getTime();\r\n        this.onServerInfoUpdate_({ serverTimeOffset: delta });\r\n    }\r\n    cancelSentTransactions_() {\r\n        for (let i = 0; i < this.outstandingPuts_.length; i++) {\r\n            const put = this.outstandingPuts_[i];\r\n            if (put && /*hash*/ 'h' in put.request && put.queued) {\r\n                if (put.onComplete) {\r\n                    put.onComplete('disconnect');\r\n                }\r\n                delete this.outstandingPuts_[i];\r\n                this.outstandingPutCount_--;\r\n            }\r\n        }\r\n        // Clean up array occasionally.\r\n        if (this.outstandingPutCount_ === 0) {\r\n            this.outstandingPuts_ = [];\r\n        }\r\n    }\r\n    onListenRevoked_(pathString, query) {\r\n        // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\r\n        let queryId;\r\n        if (!query) {\r\n            queryId = 'default';\r\n        }\r\n        else {\r\n            queryId = query.map(q => ObjectToUniqueKey(q)).join('$');\r\n        }\r\n        const listen = this.removeListen_(pathString, queryId);\r\n        if (listen && listen.onComplete) {\r\n            listen.onComplete('permission_denied');\r\n        }\r\n    }\r\n    removeListen_(pathString, queryId) {\r\n        const normalizedPathString = new Path(pathString).toString(); // normalize path.\r\n        let listen;\r\n        if (this.listens.has(normalizedPathString)) {\r\n            const map = this.listens.get(normalizedPathString);\r\n            listen = map.get(queryId);\r\n            map.delete(queryId);\r\n            if (map.size === 0) {\r\n                this.listens.delete(normalizedPathString);\r\n            }\r\n        }\r\n        else {\r\n            // all listens for this path has already been removed\r\n            listen = undefined;\r\n        }\r\n        return listen;\r\n    }\r\n    onAuthRevoked_(statusCode, explanation) {\r\n        log('Auth token revoked: ' + statusCode + '/' + explanation);\r\n        this.authToken_ = null;\r\n        this.forceTokenRefresh_ = true;\r\n        this.realtime_.close();\r\n        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\r\n            // We'll wait a couple times before logging the warning / increasing the\r\n            // retry period since oauth tokens will report as \"invalid\" if they're\r\n            // just expired. Plus there may be transient issues that resolve themselves.\r\n            this.invalidAuthTokenCount_++;\r\n            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\r\n                // Set a long reconnect delay because recovery is unlikely\r\n                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\r\n                // Notify the auth token provider that the token is invalid, which will log\r\n                // a warning\r\n                this.authTokenProvider_.notifyForInvalidToken();\r\n            }\r\n        }\r\n    }\r\n    onAppCheckRevoked_(statusCode, explanation) {\r\n        log('App check token revoked: ' + statusCode + '/' + explanation);\r\n        this.appCheckToken_ = null;\r\n        this.forceTokenRefresh_ = true;\r\n        // Note: We don't close the connection as the developer may not have\r\n        // enforcement enabled. The backend closes connections with enforcements.\r\n        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\r\n            // We'll wait a couple times before logging the warning / increasing the\r\n            // retry period since oauth tokens will report as \"invalid\" if they're\r\n            // just expired. Plus there may be transient issues that resolve themselves.\r\n            this.invalidAppCheckTokenCount_++;\r\n            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\r\n                this.appCheckTokenProvider_.notifyForInvalidToken();\r\n            }\r\n        }\r\n    }\r\n    onSecurityDebugPacket_(body) {\r\n        if (this.securityDebugCallback_) {\r\n            this.securityDebugCallback_(body);\r\n        }\r\n        else {\r\n            if ('msg' in body) {\r\n                console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\r\n            }\r\n        }\r\n    }\r\n    restoreState_() {\r\n        //Re-authenticate ourselves if we have a credential stored.\r\n        this.tryAuth();\r\n        this.tryAppCheck();\r\n        // Puts depend on having received the corresponding data update from the server before they complete, so we must\r\n        // make sure to send listens before puts.\r\n        for (const queries of this.listens.values()) {\r\n            for (const listenSpec of queries.values()) {\r\n                this.sendListen_(listenSpec);\r\n            }\r\n        }\r\n        for (let i = 0; i < this.outstandingPuts_.length; i++) {\r\n            if (this.outstandingPuts_[i]) {\r\n                this.sendPut_(i);\r\n            }\r\n        }\r\n        while (this.onDisconnectRequestQueue_.length) {\r\n            const request = this.onDisconnectRequestQueue_.shift();\r\n            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\r\n        }\r\n        for (let i = 0; i < this.outstandingGets_.length; i++) {\r\n            if (this.outstandingGets_[i]) {\r\n                this.sendGet_(i);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Sends client stats for first connection\r\n     */\r\n    sendConnectStats_() {\r\n        const stats = {};\r\n        let clientName = 'js';\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            if (this.repoInfo_.nodeAdmin) {\r\n                clientName = 'admin_node';\r\n            }\r\n            else {\r\n                clientName = 'node';\r\n            }\r\n        }\r\n        stats['sdk.' + clientName + '.' + SDK_VERSION.replace(/\\./g, '-')] = 1;\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isMobileCordova)()) {\r\n            stats['framework.cordova'] = 1;\r\n        }\r\n        else if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isReactNative)()) {\r\n            stats['framework.reactnative'] = 1;\r\n        }\r\n        this.reportStats(stats);\r\n    }\r\n    shouldReconnect_() {\r\n        const online = OnlineMonitor.getInstance().currentlyOnline();\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.interruptReasons_) && online;\r\n    }\r\n}\r\nPersistentConnection.nextPersistentConnectionId_ = 0;\r\n/**\r\n * Counter for number of connections created. Mainly used for tagging in the logs\r\n */\r\nPersistentConnection.nextConnectionId_ = 0;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass NamedNode {\r\n    constructor(name, node) {\r\n        this.name = name;\r\n        this.node = node;\r\n    }\r\n    static Wrap(name, node) {\r\n        return new NamedNode(name, node);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Index {\r\n    /**\r\n     * @returns A standalone comparison function for\r\n     * this index\r\n     */\r\n    getCompare() {\r\n        return this.compare.bind(this);\r\n    }\r\n    /**\r\n     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,\r\n     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.\r\n     *\r\n     *\r\n     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode\r\n     */\r\n    indexedValueChanged(oldNode, newNode) {\r\n        const oldWrapped = new NamedNode(MIN_NAME, oldNode);\r\n        const newWrapped = new NamedNode(MIN_NAME, newNode);\r\n        return this.compare(oldWrapped, newWrapped) !== 0;\r\n    }\r\n    /**\r\n     * @returns a node wrapper that will sort equal to or less than\r\n     * any other node wrapper, using this index\r\n     */\r\n    minPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet __EMPTY_NODE;\r\nclass KeyIndex extends Index {\r\n    static get __EMPTY_NODE() {\r\n        return __EMPTY_NODE;\r\n    }\r\n    static set __EMPTY_NODE(val) {\r\n        __EMPTY_NODE = val;\r\n    }\r\n    compare(a, b) {\r\n        return nameCompare(a.name, b.name);\r\n    }\r\n    isDefinedOn(node) {\r\n        // We could probably return true here (since every node has a key), but it's never called\r\n        // so just leaving unimplemented for now.\r\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('KeyIndex.isDefinedOn not expected to be called.');\r\n    }\r\n    indexedValueChanged(oldNode, newNode) {\r\n        return false; // The key for a node never changes.\r\n    }\r\n    minPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    }\r\n    maxPost() {\r\n        // TODO: This should really be created once and cached in a static property, but\r\n        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\r\n        return new NamedNode(MAX_NAME, __EMPTY_NODE);\r\n    }\r\n    makePost(indexValue, name) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');\r\n        // We just use empty node, but it'll never be compared, since our comparator only looks at name.\r\n        return new NamedNode(indexValue, __EMPTY_NODE);\r\n    }\r\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */\r\n    toString() {\r\n        return '.key';\r\n    }\r\n}\r\nconst KEY_INDEX = new KeyIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An iterator over an LLRBNode.\r\n */\r\nclass SortedMapIterator {\r\n    /**\r\n     * @param node - Node to iterate.\r\n     * @param isReverse_ - Whether or not to iterate in reverse\r\n     */\r\n    constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null) {\r\n        this.isReverse_ = isReverse_;\r\n        this.resultGenerator_ = resultGenerator_;\r\n        this.nodeStack_ = [];\r\n        let cmp = 1;\r\n        while (!node.isEmpty()) {\r\n            node = node;\r\n            cmp = startKey ? comparator(node.key, startKey) : 1;\r\n            // flip the comparison if we're going in reverse\r\n            if (isReverse_) {\r\n                cmp *= -1;\r\n            }\r\n            if (cmp < 0) {\r\n                // This node is less than our start key. ignore it\r\n                if (this.isReverse_) {\r\n                    node = node.left;\r\n                }\r\n                else {\r\n                    node = node.right;\r\n                }\r\n            }\r\n            else if (cmp === 0) {\r\n                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\r\n                this.nodeStack_.push(node);\r\n                break;\r\n            }\r\n            else {\r\n                // This node is greater than our start key, add it to the stack and move to the next one\r\n                this.nodeStack_.push(node);\r\n                if (this.isReverse_) {\r\n                    node = node.right;\r\n                }\r\n                else {\r\n                    node = node.left;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getNext() {\r\n        if (this.nodeStack_.length === 0) {\r\n            return null;\r\n        }\r\n        let node = this.nodeStack_.pop();\r\n        let result;\r\n        if (this.resultGenerator_) {\r\n            result = this.resultGenerator_(node.key, node.value);\r\n        }\r\n        else {\r\n            result = { key: node.key, value: node.value };\r\n        }\r\n        if (this.isReverse_) {\r\n            node = node.left;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack_.push(node);\r\n                node = node.right;\r\n            }\r\n        }\r\n        else {\r\n            node = node.right;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack_.push(node);\r\n                node = node.left;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    hasNext() {\r\n        return this.nodeStack_.length > 0;\r\n    }\r\n    peek() {\r\n        if (this.nodeStack_.length === 0) {\r\n            return null;\r\n        }\r\n        const node = this.nodeStack_[this.nodeStack_.length - 1];\r\n        if (this.resultGenerator_) {\r\n            return this.resultGenerator_(node.key, node.value);\r\n        }\r\n        else {\r\n            return { key: node.key, value: node.value };\r\n        }\r\n    }\r\n}\r\n/**\r\n * Represents a node in a Left-leaning Red-Black tree.\r\n */\r\nclass LLRBNode {\r\n    /**\r\n     * @param key - Key associated with this node.\r\n     * @param value - Value associated with this node.\r\n     * @param color - Whether this node is red.\r\n     * @param left - Left child.\r\n     * @param right - Right child.\r\n     */\r\n    constructor(key, value, color, left, right) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.color = color != null ? color : LLRBNode.RED;\r\n        this.left =\r\n            left != null ? left : SortedMap.EMPTY_NODE;\r\n        this.right =\r\n            right != null ? right : SortedMap.EMPTY_NODE;\r\n    }\r\n    /**\r\n     * Returns a copy of the current node, optionally replacing pieces of it.\r\n     *\r\n     * @param key - New key for the node, or null.\r\n     * @param value - New value for the node, or null.\r\n     * @param color - New color for the node, or null.\r\n     * @param left - New left child for the node, or null.\r\n     * @param right - New right child for the node, or null.\r\n     * @returns The node copy.\r\n     */\r\n    copy(key, value, color, left, right) {\r\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\r\n    }\r\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */\r\n    count() {\r\n        return this.left.count() + 1 + this.right.count();\r\n    }\r\n    /**\r\n     * @returns True if the tree is empty.\r\n     */\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     *   node.  If it returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */\r\n    inorderTraversal(action) {\r\n        return (this.left.inorderTraversal(action) ||\r\n            !!action(this.key, this.value) ||\r\n            this.right.inorderTraversal(action));\r\n    }\r\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */\r\n    reverseTraversal(action) {\r\n        return (this.right.reverseTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.left.reverseTraversal(action));\r\n    }\r\n    /**\r\n     * @returns The minimum node in the tree.\r\n     */\r\n    min_() {\r\n        if (this.left.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            return this.left.min_();\r\n        }\r\n    }\r\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */\r\n    minKey() {\r\n        return this.min_().key;\r\n    }\r\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */\r\n    maxKey() {\r\n        if (this.right.isEmpty()) {\r\n            return this.key;\r\n        }\r\n        else {\r\n            return this.right.maxKey();\r\n        }\r\n    }\r\n    /**\r\n     * @param key - Key to insert.\r\n     * @param value - Value to insert.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the key/value added.\r\n     */\r\n    insert(key, value, comparator) {\r\n        let n = this;\r\n        const cmp = comparator(key, n.key);\r\n        if (cmp < 0) {\r\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\r\n        }\r\n        else if (cmp === 0) {\r\n            n = n.copy(null, value, null, null, null);\r\n        }\r\n        else {\r\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\r\n        }\r\n        return n.fixUp_();\r\n    }\r\n    /**\r\n     * @returns New tree, with the minimum key removed.\r\n     */\r\n    removeMin_() {\r\n        if (this.left.isEmpty()) {\r\n            return SortedMap.EMPTY_NODE;\r\n        }\r\n        let n = this;\r\n        if (!n.left.isRed_() && !n.left.left.isRed_()) {\r\n            n = n.moveRedLeft_();\r\n        }\r\n        n = n.copy(null, null, null, n.left.removeMin_(), null);\r\n        return n.fixUp_();\r\n    }\r\n    /**\r\n     * @param key - The key of the item to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the specified item removed.\r\n     */\r\n    remove(key, comparator) {\r\n        let n, smallest;\r\n        n = this;\r\n        if (comparator(key, n.key) < 0) {\r\n            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\r\n                n = n.moveRedLeft_();\r\n            }\r\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\r\n        }\r\n        else {\r\n            if (n.left.isRed_()) {\r\n                n = n.rotateRight_();\r\n            }\r\n            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\r\n                n = n.moveRedRight_();\r\n            }\r\n            if (comparator(key, n.key) === 0) {\r\n                if (n.right.isEmpty()) {\r\n                    return SortedMap.EMPTY_NODE;\r\n                }\r\n                else {\r\n                    smallest = n.right.min_();\r\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());\r\n                }\r\n            }\r\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\r\n        }\r\n        return n.fixUp_();\r\n    }\r\n    /**\r\n     * @returns Whether this is a RED node.\r\n     */\r\n    isRed_() {\r\n        return this.color;\r\n    }\r\n    /**\r\n     * @returns New tree after performing any needed rotations.\r\n     */\r\n    fixUp_() {\r\n        let n = this;\r\n        if (n.right.isRed_() && !n.left.isRed_()) {\r\n            n = n.rotateLeft_();\r\n        }\r\n        if (n.left.isRed_() && n.left.left.isRed_()) {\r\n            n = n.rotateRight_();\r\n        }\r\n        if (n.left.isRed_() && n.right.isRed_()) {\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    }\r\n    /**\r\n     * @returns New tree, after moveRedLeft.\r\n     */\r\n    moveRedLeft_() {\r\n        let n = this.colorFlip_();\r\n        if (n.right.left.isRed_()) {\r\n            n = n.copy(null, null, null, null, n.right.rotateRight_());\r\n            n = n.rotateLeft_();\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    }\r\n    /**\r\n     * @returns New tree, after moveRedRight.\r\n     */\r\n    moveRedRight_() {\r\n        let n = this.colorFlip_();\r\n        if (n.left.left.isRed_()) {\r\n            n = n.rotateRight_();\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    }\r\n    /**\r\n     * @returns New tree, after rotateLeft.\r\n     */\r\n    rotateLeft_() {\r\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\r\n        return this.right.copy(null, null, this.color, nl, null);\r\n    }\r\n    /**\r\n     * @returns New tree, after rotateRight.\r\n     */\r\n    rotateRight_() {\r\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\r\n        return this.left.copy(null, null, this.color, null, nr);\r\n    }\r\n    /**\r\n     * @returns Newt ree, after colorFlip.\r\n     */\r\n    colorFlip_() {\r\n        const left = this.left.copy(null, null, !this.left.color, null, null);\r\n        const right = this.right.copy(null, null, !this.right.color, null, null);\r\n        return this.copy(null, null, !this.color, left, right);\r\n    }\r\n    /**\r\n     * For testing.\r\n     *\r\n     * @returns True if all is well.\r\n     */\r\n    checkMaxDepth_() {\r\n        const blackDepth = this.check_();\r\n        return Math.pow(2.0, blackDepth) <= this.count() + 1;\r\n    }\r\n    check_() {\r\n        if (this.isRed_() && this.left.isRed_()) {\r\n            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');\r\n        }\r\n        if (this.right.isRed_()) {\r\n            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');\r\n        }\r\n        const blackDepth = this.left.check_();\r\n        if (blackDepth !== this.right.check_()) {\r\n            throw new Error('Black depths differ');\r\n        }\r\n        else {\r\n            return blackDepth + (this.isRed_() ? 0 : 1);\r\n        }\r\n    }\r\n}\r\nLLRBNode.RED = true;\r\nLLRBNode.BLACK = false;\r\n/**\r\n * Represents an empty node (a leaf node in the Red-Black Tree).\r\n */\r\nclass LLRBEmptyNode {\r\n    /**\r\n     * Returns a copy of the current node.\r\n     *\r\n     * @returns The node copy.\r\n     */\r\n    copy(key, value, color, left, right) {\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a copy of the tree, with the specified key/value added.\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item added.\r\n     */\r\n    insert(key, value, comparator) {\r\n        return new LLRBNode(key, value, null);\r\n    }\r\n    /**\r\n     * Returns a copy of the tree, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item removed.\r\n     */\r\n    remove(key, comparator) {\r\n        return this;\r\n    }\r\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */\r\n    count() {\r\n        return 0;\r\n    }\r\n    /**\r\n     * @returns True if the tree is empty.\r\n     */\r\n    isEmpty() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */\r\n    inorderTraversal(action) {\r\n        return false;\r\n    }\r\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */\r\n    reverseTraversal(action) {\r\n        return false;\r\n    }\r\n    minKey() {\r\n        return null;\r\n    }\r\n    maxKey() {\r\n        return null;\r\n    }\r\n    check_() {\r\n        return 0;\r\n    }\r\n    /**\r\n     * @returns Whether this node is red.\r\n     */\r\n    isRed_() {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n * tree.\r\n */\r\nclass SortedMap {\r\n    /**\r\n     * @param comparator_ - Key comparator.\r\n     * @param root_ - Optional root node for the map.\r\n     */\r\n    constructor(comparator_, root_ = SortedMap.EMPTY_NODE) {\r\n        this.comparator_ = comparator_;\r\n        this.root_ = root_;\r\n    }\r\n    /**\r\n     * Returns a copy of the map, with the specified key/value added or replaced.\r\n     * (TODO: We should perhaps rename this method to 'put')\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @returns New map, with item added.\r\n     */\r\n    insert(key, value) {\r\n        return new SortedMap(this.comparator_, this.root_\r\n            .insert(key, value, this.comparator_)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    /**\r\n     * Returns a copy of the map, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @returns New map, with item removed.\r\n     */\r\n    remove(key) {\r\n        return new SortedMap(this.comparator_, this.root_\r\n            .remove(key, this.comparator_)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    /**\r\n     * Returns the value of the node with the given key, or null.\r\n     *\r\n     * @param key - The key to look up.\r\n     * @returns The value of the node with the given key, or null if the\r\n     * key doesn't exist.\r\n     */\r\n    get(key) {\r\n        let cmp;\r\n        let node = this.root_;\r\n        while (!node.isEmpty()) {\r\n            cmp = this.comparator_(key, node.key);\r\n            if (cmp === 0) {\r\n                return node.value;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                node = node.right;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns the key of the item *before* the specified key, or null if key is the first item.\r\n     * @param key - The key to find the predecessor of\r\n     * @returns The predecessor key.\r\n     */\r\n    getPredecessorKey(key) {\r\n        let cmp, node = this.root_, rightParent = null;\r\n        while (!node.isEmpty()) {\r\n            cmp = this.comparator_(key, node.key);\r\n            if (cmp === 0) {\r\n                if (!node.left.isEmpty()) {\r\n                    node = node.left;\r\n                    while (!node.right.isEmpty()) {\r\n                        node = node.right;\r\n                    }\r\n                    return node.key;\r\n                }\r\n                else if (rightParent) {\r\n                    return rightParent.key;\r\n                }\r\n                else {\r\n                    return null; // first item.\r\n                }\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                rightParent = node;\r\n                node = node.right;\r\n            }\r\n        }\r\n        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');\r\n    }\r\n    /**\r\n     * @returns True if the map is empty.\r\n     */\r\n    isEmpty() {\r\n        return this.root_.isEmpty();\r\n    }\r\n    /**\r\n     * @returns The total number of nodes in the map.\r\n     */\r\n    count() {\r\n        return this.root_.count();\r\n    }\r\n    /**\r\n     * @returns The minimum key in the map.\r\n     */\r\n    minKey() {\r\n        return this.root_.minKey();\r\n    }\r\n    /**\r\n     * @returns The maximum key in the map.\r\n     */\r\n    maxKey() {\r\n        return this.root_.maxKey();\r\n    }\r\n    /**\r\n     * Traverses the map in key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */\r\n    inorderTraversal(action) {\r\n        return this.root_.inorderTraversal(action);\r\n    }\r\n    /**\r\n     * Traverses the map in reverse key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns True if the traversal was aborted.\r\n     */\r\n    reverseTraversal(action) {\r\n        return this.root_.reverseTraversal(action);\r\n    }\r\n    /**\r\n     * Returns an iterator over the SortedMap.\r\n     * @returns The iterator.\r\n     */\r\n    getIterator(resultGenerator) {\r\n        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);\r\n    }\r\n    getIteratorFrom(key, resultGenerator) {\r\n        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);\r\n    }\r\n    getReverseIteratorFrom(key, resultGenerator) {\r\n        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);\r\n    }\r\n    getReverseIterator(resultGenerator) {\r\n        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);\r\n    }\r\n}\r\n/**\r\n * Always use the same empty node, to reduce memory.\r\n */\r\nSortedMap.EMPTY_NODE = new LLRBEmptyNode();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction NAME_ONLY_COMPARATOR(left, right) {\r\n    return nameCompare(left.name, right.name);\r\n}\r\nfunction NAME_COMPARATOR(left, right) {\r\n    return nameCompare(left, right);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet MAX_NODE$2;\r\nfunction setMaxNode$1(val) {\r\n    MAX_NODE$2 = val;\r\n}\r\nconst priorityHashText = function (priority) {\r\n    if (typeof priority === 'number') {\r\n        return 'number:' + doubleToIEEE754String(priority);\r\n    }\r\n    else {\r\n        return 'string:' + priority;\r\n    }\r\n};\r\n/**\r\n * Validates that a priority snapshot Node is valid.\r\n */\r\nconst validatePriorityNode = function (priorityNode) {\r\n    if (priorityNode.isLeafNode()) {\r\n        const val = priorityNode.val();\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof val === 'string' ||\r\n            typeof val === 'number' ||\r\n            (typeof val === 'object' && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(val, '.sv')), 'Priority must be a string or number.');\r\n    }\r\n    else {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), 'priority of unexpected type.');\r\n    }\r\n    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), \"Priority nodes can't have a priority of their own.\");\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet __childrenNodeConstructor;\r\n/**\r\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\r\n * implements Node and stores the value of the node (a string,\r\n * number, or boolean) accessible via getValue().\r\n */\r\nclass LeafNode {\r\n    /**\r\n     * @param value_ - The value to store in this leaf node. The object type is\r\n     * possible in the event of a deferred value\r\n     * @param priorityNode_ - The priority of this node.\r\n     */\r\n    constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\r\n        this.value_ = value_;\r\n        this.priorityNode_ = priorityNode_;\r\n        this.lazyHash_ = null;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\r\n        validatePriorityNode(this.priorityNode_);\r\n    }\r\n    static set __childrenNodeConstructor(val) {\r\n        __childrenNodeConstructor = val;\r\n    }\r\n    static get __childrenNodeConstructor() {\r\n        return __childrenNodeConstructor;\r\n    }\r\n    /** @inheritDoc */\r\n    isLeafNode() {\r\n        return true;\r\n    }\r\n    /** @inheritDoc */\r\n    getPriority() {\r\n        return this.priorityNode_;\r\n    }\r\n    /** @inheritDoc */\r\n    updatePriority(newPriorityNode) {\r\n        return new LeafNode(this.value_, newPriorityNode);\r\n    }\r\n    /** @inheritDoc */\r\n    getImmediateChild(childName) {\r\n        // Hack to treat priority as a regular child\r\n        if (childName === '.priority') {\r\n            return this.priorityNode_;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    getChild(path) {\r\n        if (pathIsEmpty(path)) {\r\n            return this;\r\n        }\r\n        else if (pathGetFront(path) === '.priority') {\r\n            return this.priorityNode_;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\r\n        }\r\n    }\r\n    hasChild() {\r\n        return false;\r\n    }\r\n    /** @inheritDoc */\r\n    getPredecessorChildName(childName, childNode) {\r\n        return null;\r\n    }\r\n    /** @inheritDoc */\r\n    updateImmediateChild(childName, newChildNode) {\r\n        if (childName === '.priority') {\r\n            return this.updatePriority(newChildNode);\r\n        }\r\n        else if (newChildNode.isEmpty() && childName !== '.priority') {\r\n            return this;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    updateChild(path, newChildNode) {\r\n        const front = pathGetFront(path);\r\n        if (front === null) {\r\n            return newChildNode;\r\n        }\r\n        else if (newChildNode.isEmpty() && front !== '.priority') {\r\n            return this;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(front !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');\r\n            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n    /** @inheritDoc */\r\n    numChildren() {\r\n        return 0;\r\n    }\r\n    /** @inheritDoc */\r\n    forEachChild(index, action) {\r\n        return false;\r\n    }\r\n    val(exportFormat) {\r\n        if (exportFormat && !this.getPriority().isEmpty()) {\r\n            return {\r\n                '.value': this.getValue(),\r\n                '.priority': this.getPriority().val()\r\n            };\r\n        }\r\n        else {\r\n            return this.getValue();\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    hash() {\r\n        if (this.lazyHash_ === null) {\r\n            let toHash = '';\r\n            if (!this.priorityNode_.isEmpty()) {\r\n                toHash +=\r\n                    'priority:' +\r\n                        priorityHashText(this.priorityNode_.val()) +\r\n                        ':';\r\n            }\r\n            const type = typeof this.value_;\r\n            toHash += type + ':';\r\n            if (type === 'number') {\r\n                toHash += doubleToIEEE754String(this.value_);\r\n            }\r\n            else {\r\n                toHash += this.value_;\r\n            }\r\n            this.lazyHash_ = sha1(toHash);\r\n        }\r\n        return this.lazyHash_;\r\n    }\r\n    /**\r\n     * Returns the value of the leaf node.\r\n     * @returns The value of the node.\r\n     */\r\n    getValue() {\r\n        return this.value_;\r\n    }\r\n    compareTo(other) {\r\n        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\r\n            return 1;\r\n        }\r\n        else if (other instanceof LeafNode.__childrenNodeConstructor) {\r\n            return -1;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(other.isLeafNode(), 'Unknown node type');\r\n            return this.compareToLeafNode_(other);\r\n        }\r\n    }\r\n    /**\r\n     * Comparison specifically for two leaf nodes\r\n     */\r\n    compareToLeafNode_(otherLeaf) {\r\n        const otherLeafType = typeof otherLeaf.value_;\r\n        const thisLeafType = typeof this.value_;\r\n        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\r\n        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\r\n        if (otherIndex === thisIndex) {\r\n            // Same type, compare values\r\n            if (thisLeafType === 'object') {\r\n                // Deferred value nodes are all equal, but we should also never get to this point...\r\n                return 0;\r\n            }\r\n            else {\r\n                // Note that this works because true > false, all others are number or string comparisons\r\n                if (this.value_ < otherLeaf.value_) {\r\n                    return -1;\r\n                }\r\n                else if (this.value_ === otherLeaf.value_) {\r\n                    return 0;\r\n                }\r\n                else {\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return thisIndex - otherIndex;\r\n        }\r\n    }\r\n    withIndex() {\r\n        return this;\r\n    }\r\n    isIndexed() {\r\n        return true;\r\n    }\r\n    equals(other) {\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        else if (other.isLeafNode()) {\r\n            const otherLeaf = other;\r\n            return (this.value_ === otherLeaf.value_ &&\r\n                this.priorityNode_.equals(otherLeaf.priorityNode_));\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n/**\r\n * The sort order for comparing leaf nodes of different types. If two leaf nodes have\r\n * the same type, the comparison falls back to their value\r\n */\r\nLeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet nodeFromJSON$1;\r\nlet MAX_NODE$1;\r\nfunction setNodeFromJSON(val) {\r\n    nodeFromJSON$1 = val;\r\n}\r\nfunction setMaxNode(val) {\r\n    MAX_NODE$1 = val;\r\n}\r\nclass PriorityIndex extends Index {\r\n    compare(a, b) {\r\n        const aPriority = a.node.getPriority();\r\n        const bPriority = b.node.getPriority();\r\n        const indexCmp = aPriority.compareTo(bPriority);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    }\r\n    isDefinedOn(node) {\r\n        return !node.getPriority().isEmpty();\r\n    }\r\n    indexedValueChanged(oldNode, newNode) {\r\n        return !oldNode.getPriority().equals(newNode.getPriority());\r\n    }\r\n    minPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    }\r\n    maxPost() {\r\n        return new NamedNode(MAX_NAME, new LeafNode('[PRIORITY-POST]', MAX_NODE$1));\r\n    }\r\n    makePost(indexValue, name) {\r\n        const priorityNode = nodeFromJSON$1(indexValue);\r\n        return new NamedNode(name, new LeafNode('[PRIORITY-POST]', priorityNode));\r\n    }\r\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */\r\n    toString() {\r\n        return '.priority';\r\n    }\r\n}\r\nconst PRIORITY_INDEX = new PriorityIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_2 = Math.log(2);\r\nclass Base12Num {\r\n    constructor(length) {\r\n        const logBase2 = (num) => \r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        parseInt((Math.log(num) / LOG_2), 10);\r\n        const bitMask = (bits) => parseInt(Array(bits + 1).join('1'), 2);\r\n        this.count = logBase2(length + 1);\r\n        this.current_ = this.count - 1;\r\n        const mask = bitMask(this.count);\r\n        this.bits_ = (length + 1) & mask;\r\n    }\r\n    nextBitIsOne() {\r\n        //noinspection JSBitwiseOperatorUsage\r\n        const result = !(this.bits_ & (0x1 << this.current_));\r\n        this.current_--;\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\r\n * function\r\n *\r\n * Uses the algorithm described in the paper linked here:\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\r\n *\r\n * @param childList - Unsorted list of children\r\n * @param cmp - The comparison method to be used\r\n * @param keyFn - An optional function to extract K from a node wrapper, if K's\r\n * type is not NamedNode\r\n * @param mapSortFn - An optional override for comparator used by the generated sorted map\r\n */\r\nconst buildChildSet = function (childList, cmp, keyFn, mapSortFn) {\r\n    childList.sort(cmp);\r\n    const buildBalancedTree = function (low, high) {\r\n        const length = high - low;\r\n        let namedNode;\r\n        let key;\r\n        if (length === 0) {\r\n            return null;\r\n        }\r\n        else if (length === 1) {\r\n            namedNode = childList[low];\r\n            key = keyFn ? keyFn(namedNode) : namedNode;\r\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);\r\n        }\r\n        else {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const middle = parseInt((length / 2), 10) + low;\r\n            const left = buildBalancedTree(low, middle);\r\n            const right = buildBalancedTree(middle + 1, high);\r\n            namedNode = childList[middle];\r\n            key = keyFn ? keyFn(namedNode) : namedNode;\r\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);\r\n        }\r\n    };\r\n    const buildFrom12Array = function (base12) {\r\n        let node = null;\r\n        let root = null;\r\n        let index = childList.length;\r\n        const buildPennant = function (chunkSize, color) {\r\n            const low = index - chunkSize;\r\n            const high = index;\r\n            index -= chunkSize;\r\n            const childTree = buildBalancedTree(low + 1, high);\r\n            const namedNode = childList[low];\r\n            const key = keyFn ? keyFn(namedNode) : namedNode;\r\n            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));\r\n        };\r\n        const attachPennant = function (pennant) {\r\n            if (node) {\r\n                node.left = pennant;\r\n                node = pennant;\r\n            }\r\n            else {\r\n                root = pennant;\r\n                node = pennant;\r\n            }\r\n        };\r\n        for (let i = 0; i < base12.count; ++i) {\r\n            const isOne = base12.nextBitIsOne();\r\n            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\r\n            const chunkSize = Math.pow(2, base12.count - (i + 1));\r\n            if (isOne) {\r\n                buildPennant(chunkSize, LLRBNode.BLACK);\r\n            }\r\n            else {\r\n                // current == 2\r\n                buildPennant(chunkSize, LLRBNode.BLACK);\r\n                buildPennant(chunkSize, LLRBNode.RED);\r\n            }\r\n        }\r\n        return root;\r\n    };\r\n    const base12 = new Base12Num(childList.length);\r\n    const root = buildFrom12Array(base12);\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    return new SortedMap(mapSortFn || cmp, root);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet _defaultIndexMap;\r\nconst fallbackObject = {};\r\nclass IndexMap {\r\n    constructor(indexes_, indexSet_) {\r\n        this.indexes_ = indexes_;\r\n        this.indexSet_ = indexSet_;\r\n    }\r\n    /**\r\n     * The default IndexMap for nodes without a priority\r\n     */\r\n    static get Default() {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(fallbackObject && PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');\r\n        _defaultIndexMap =\r\n            _defaultIndexMap ||\r\n                new IndexMap({ '.priority': fallbackObject }, { '.priority': PRIORITY_INDEX });\r\n        return _defaultIndexMap;\r\n    }\r\n    get(indexKey) {\r\n        const sortedMap = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.indexes_, indexKey);\r\n        if (!sortedMap) {\r\n            throw new Error('No index defined for ' + indexKey);\r\n        }\r\n        if (sortedMap instanceof SortedMap) {\r\n            return sortedMap;\r\n        }\r\n        else {\r\n            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\r\n            // regular child map\r\n            return null;\r\n        }\r\n    }\r\n    hasIndex(indexDefinition) {\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.indexSet_, indexDefinition.toString());\r\n    }\r\n    addIndex(indexDefinition, existingChildren) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(indexDefinition !== KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\r\n        const childList = [];\r\n        let sawIndexedValue = false;\r\n        const iter = existingChildren.getIterator(NamedNode.Wrap);\r\n        let next = iter.getNext();\r\n        while (next) {\r\n            sawIndexedValue =\r\n                sawIndexedValue || indexDefinition.isDefinedOn(next.node);\r\n            childList.push(next);\r\n            next = iter.getNext();\r\n        }\r\n        let newIndex;\r\n        if (sawIndexedValue) {\r\n            newIndex = buildChildSet(childList, indexDefinition.getCompare());\r\n        }\r\n        else {\r\n            newIndex = fallbackObject;\r\n        }\r\n        const indexName = indexDefinition.toString();\r\n        const newIndexSet = Object.assign({}, this.indexSet_);\r\n        newIndexSet[indexName] = indexDefinition;\r\n        const newIndexes = Object.assign({}, this.indexes_);\r\n        newIndexes[indexName] = newIndex;\r\n        return new IndexMap(newIndexes, newIndexSet);\r\n    }\r\n    /**\r\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\r\n     */\r\n    addToIndexes(namedNode, existingChildren) {\r\n        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(this.indexes_, (indexedChildren, indexName) => {\r\n            const index = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.indexSet_, indexName);\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(index, 'Missing index implementation for ' + indexName);\r\n            if (indexedChildren === fallbackObject) {\r\n                // Check to see if we need to index everything\r\n                if (index.isDefinedOn(namedNode.node)) {\r\n                    // We need to build this index\r\n                    const childList = [];\r\n                    const iter = existingChildren.getIterator(NamedNode.Wrap);\r\n                    let next = iter.getNext();\r\n                    while (next) {\r\n                        if (next.name !== namedNode.name) {\r\n                            childList.push(next);\r\n                        }\r\n                        next = iter.getNext();\r\n                    }\r\n                    childList.push(namedNode);\r\n                    return buildChildSet(childList, index.getCompare());\r\n                }\r\n                else {\r\n                    // No change, this remains a fallback\r\n                    return fallbackObject;\r\n                }\r\n            }\r\n            else {\r\n                const existingSnap = existingChildren.get(namedNode.name);\r\n                let newChildren = indexedChildren;\r\n                if (existingSnap) {\r\n                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));\r\n                }\r\n                return newChildren.insert(namedNode, namedNode.node);\r\n            }\r\n        });\r\n        return new IndexMap(newIndexes, this.indexSet_);\r\n    }\r\n    /**\r\n     * Create a new IndexMap instance with the given value removed\r\n     */\r\n    removeFromIndexes(namedNode, existingChildren) {\r\n        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(this.indexes_, (indexedChildren) => {\r\n            if (indexedChildren === fallbackObject) {\r\n                // This is the fallback. Just return it, nothing to do in this case\r\n                return indexedChildren;\r\n            }\r\n            else {\r\n                const existingSnap = existingChildren.get(namedNode.name);\r\n                if (existingSnap) {\r\n                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));\r\n                }\r\n                else {\r\n                    // No record of this child\r\n                    return indexedChildren;\r\n                }\r\n            }\r\n        });\r\n        return new IndexMap(newIndexes, this.indexSet_);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\r\nlet EMPTY_NODE;\r\n/**\r\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\r\n * (i.e. nodes with children).  It implements Node and stores the\r\n * list of children in the children property, sorted by child name.\r\n */\r\nclass ChildrenNode {\r\n    /**\r\n     * @param children_ - List of children of this node..\r\n     * @param priorityNode_ - The priority of this node (as a snapshot node).\r\n     */\r\n    constructor(children_, priorityNode_, indexMap_) {\r\n        this.children_ = children_;\r\n        this.priorityNode_ = priorityNode_;\r\n        this.indexMap_ = indexMap_;\r\n        this.lazyHash_ = null;\r\n        /**\r\n         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\r\n         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\r\n         * class instead of an empty ChildrenNode.\r\n         */\r\n        if (this.priorityNode_) {\r\n            validatePriorityNode(this.priorityNode_);\r\n        }\r\n        if (this.children_.isEmpty()) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');\r\n        }\r\n    }\r\n    static get EMPTY_NODE() {\r\n        return (EMPTY_NODE ||\r\n            (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default)));\r\n    }\r\n    /** @inheritDoc */\r\n    isLeafNode() {\r\n        return false;\r\n    }\r\n    /** @inheritDoc */\r\n    getPriority() {\r\n        return this.priorityNode_ || EMPTY_NODE;\r\n    }\r\n    /** @inheritDoc */\r\n    updatePriority(newPriorityNode) {\r\n        if (this.children_.isEmpty()) {\r\n            // Don't allow priorities on empty nodes\r\n            return this;\r\n        }\r\n        else {\r\n            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    getImmediateChild(childName) {\r\n        // Hack to treat priority as a regular child\r\n        if (childName === '.priority') {\r\n            return this.getPriority();\r\n        }\r\n        else {\r\n            const child = this.children_.get(childName);\r\n            return child === null ? EMPTY_NODE : child;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    getChild(path) {\r\n        const front = pathGetFront(path);\r\n        if (front === null) {\r\n            return this;\r\n        }\r\n        return this.getImmediateChild(front).getChild(pathPopFront(path));\r\n    }\r\n    /** @inheritDoc */\r\n    hasChild(childName) {\r\n        return this.children_.get(childName) !== null;\r\n    }\r\n    /** @inheritDoc */\r\n    updateImmediateChild(childName, newChildNode) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(newChildNode, 'We should always be passing snapshot nodes');\r\n        if (childName === '.priority') {\r\n            return this.updatePriority(newChildNode);\r\n        }\r\n        else {\r\n            const namedNode = new NamedNode(childName, newChildNode);\r\n            let newChildren, newIndexMap;\r\n            if (newChildNode.isEmpty()) {\r\n                newChildren = this.children_.remove(childName);\r\n                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\r\n            }\r\n            else {\r\n                newChildren = this.children_.insert(childName, newChildNode);\r\n                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\r\n            }\r\n            const newPriority = newChildren.isEmpty()\r\n                ? EMPTY_NODE\r\n                : this.priorityNode_;\r\n            return new ChildrenNode(newChildren, newPriority, newIndexMap);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    updateChild(path, newChildNode) {\r\n        const front = pathGetFront(path);\r\n        if (front === null) {\r\n            return newChildNode;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(path) !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');\r\n            const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);\r\n            return this.updateImmediateChild(front, newImmediateChild);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    isEmpty() {\r\n        return this.children_.isEmpty();\r\n    }\r\n    /** @inheritDoc */\r\n    numChildren() {\r\n        return this.children_.count();\r\n    }\r\n    /** @inheritDoc */\r\n    val(exportFormat) {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        const obj = {};\r\n        let numKeys = 0, maxKey = 0, allIntegerKeys = true;\r\n        this.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n            obj[key] = childNode.val(exportFormat);\r\n            numKeys++;\r\n            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\r\n                maxKey = Math.max(maxKey, Number(key));\r\n            }\r\n            else {\r\n                allIntegerKeys = false;\r\n            }\r\n        });\r\n        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\r\n            // convert to array.\r\n            const array = [];\r\n            // eslint-disable-next-line guard-for-in\r\n            for (const key in obj) {\r\n                array[key] = obj[key];\r\n            }\r\n            return array;\r\n        }\r\n        else {\r\n            if (exportFormat && !this.getPriority().isEmpty()) {\r\n                obj['.priority'] = this.getPriority().val();\r\n            }\r\n            return obj;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    hash() {\r\n        if (this.lazyHash_ === null) {\r\n            let toHash = '';\r\n            if (!this.getPriority().isEmpty()) {\r\n                toHash +=\r\n                    'priority:' +\r\n                        priorityHashText(this.getPriority().val()) +\r\n                        ':';\r\n            }\r\n            this.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n                const childHash = childNode.hash();\r\n                if (childHash !== '') {\r\n                    toHash += ':' + key + ':' + childHash;\r\n                }\r\n            });\r\n            this.lazyHash_ = toHash === '' ? '' : sha1(toHash);\r\n        }\r\n        return this.lazyHash_;\r\n    }\r\n    /** @inheritDoc */\r\n    getPredecessorChildName(childName, childNode, index) {\r\n        const idx = this.resolveIndex_(index);\r\n        if (idx) {\r\n            const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));\r\n            return predecessor ? predecessor.name : null;\r\n        }\r\n        else {\r\n            return this.children_.getPredecessorKey(childName);\r\n        }\r\n    }\r\n    getFirstChildName(indexDefinition) {\r\n        const idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            const minKey = idx.minKey();\r\n            return minKey && minKey.name;\r\n        }\r\n        else {\r\n            return this.children_.minKey();\r\n        }\r\n    }\r\n    getFirstChild(indexDefinition) {\r\n        const minKey = this.getFirstChildName(indexDefinition);\r\n        if (minKey) {\r\n            return new NamedNode(minKey, this.children_.get(minKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Given an index, return the key name of the largest value we have, according to that index\r\n     */\r\n    getLastChildName(indexDefinition) {\r\n        const idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            const maxKey = idx.maxKey();\r\n            return maxKey && maxKey.name;\r\n        }\r\n        else {\r\n            return this.children_.maxKey();\r\n        }\r\n    }\r\n    getLastChild(indexDefinition) {\r\n        const maxKey = this.getLastChildName(indexDefinition);\r\n        if (maxKey) {\r\n            return new NamedNode(maxKey, this.children_.get(maxKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    forEachChild(index, action) {\r\n        const idx = this.resolveIndex_(index);\r\n        if (idx) {\r\n            return idx.inorderTraversal(wrappedNode => {\r\n                return action(wrappedNode.name, wrappedNode.node);\r\n            });\r\n        }\r\n        else {\r\n            return this.children_.inorderTraversal(action);\r\n        }\r\n    }\r\n    getIterator(indexDefinition) {\r\n        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\r\n    }\r\n    getIteratorFrom(startPost, indexDefinition) {\r\n        const idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            return idx.getIteratorFrom(startPost, key => key);\r\n        }\r\n        else {\r\n            const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);\r\n            let next = iterator.peek();\r\n            while (next != null && indexDefinition.compare(next, startPost) < 0) {\r\n                iterator.getNext();\r\n                next = iterator.peek();\r\n            }\r\n            return iterator;\r\n        }\r\n    }\r\n    getReverseIterator(indexDefinition) {\r\n        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\r\n    }\r\n    getReverseIteratorFrom(endPost, indexDefinition) {\r\n        const idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            return idx.getReverseIteratorFrom(endPost, key => {\r\n                return key;\r\n            });\r\n        }\r\n        else {\r\n            const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);\r\n            let next = iterator.peek();\r\n            while (next != null && indexDefinition.compare(next, endPost) > 0) {\r\n                iterator.getNext();\r\n                next = iterator.peek();\r\n            }\r\n            return iterator;\r\n        }\r\n    }\r\n    compareTo(other) {\r\n        if (this.isEmpty()) {\r\n            if (other.isEmpty()) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        else if (other.isLeafNode() || other.isEmpty()) {\r\n            return 1;\r\n        }\r\n        else if (other === MAX_NODE) {\r\n            return -1;\r\n        }\r\n        else {\r\n            // Must be another node with children.\r\n            return 0;\r\n        }\r\n    }\r\n    withIndex(indexDefinition) {\r\n        if (indexDefinition === KEY_INDEX ||\r\n            this.indexMap_.hasIndex(indexDefinition)) {\r\n            return this;\r\n        }\r\n        else {\r\n            const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\r\n            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\r\n        }\r\n    }\r\n    isIndexed(index) {\r\n        return index === KEY_INDEX || this.indexMap_.hasIndex(index);\r\n    }\r\n    equals(other) {\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        else if (other.isLeafNode()) {\r\n            return false;\r\n        }\r\n        else {\r\n            const otherChildrenNode = other;\r\n            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\r\n                return false;\r\n            }\r\n            else if (this.children_.count() === otherChildrenNode.children_.count()) {\r\n                const thisIter = this.getIterator(PRIORITY_INDEX);\r\n                const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\r\n                let thisCurrent = thisIter.getNext();\r\n                let otherCurrent = otherIter.getNext();\r\n                while (thisCurrent && otherCurrent) {\r\n                    if (thisCurrent.name !== otherCurrent.name ||\r\n                        !thisCurrent.node.equals(otherCurrent.node)) {\r\n                        return false;\r\n                    }\r\n                    thisCurrent = thisIter.getNext();\r\n                    otherCurrent = otherIter.getNext();\r\n                }\r\n                return thisCurrent === null && otherCurrent === null;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\r\n     * instead.\r\n     *\r\n     */\r\n    resolveIndex_(indexDefinition) {\r\n        if (indexDefinition === KEY_INDEX) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.indexMap_.get(indexDefinition.toString());\r\n        }\r\n    }\r\n}\r\nChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\r\nclass MaxNode extends ChildrenNode {\r\n    constructor() {\r\n        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);\r\n    }\r\n    compareTo(other) {\r\n        if (other === this) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    equals(other) {\r\n        // Not that we every compare it, but MAX_NODE is only ever equal to itself\r\n        return other === this;\r\n    }\r\n    getPriority() {\r\n        return this;\r\n    }\r\n    getImmediateChild(childName) {\r\n        return ChildrenNode.EMPTY_NODE;\r\n    }\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Marker that will sort higher than any other snapshot.\r\n */\r\nconst MAX_NODE = new MaxNode();\r\nObject.defineProperties(NamedNode, {\r\n    MIN: {\r\n        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\r\n    },\r\n    MAX: {\r\n        value: new NamedNode(MAX_NAME, MAX_NODE)\r\n    }\r\n});\r\n/**\r\n * Reference Extensions\r\n */\r\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\r\nLeafNode.__childrenNodeConstructor = ChildrenNode;\r\nsetMaxNode$1(MAX_NODE);\r\nsetMaxNode(MAX_NODE);\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst USE_HINZE = true;\r\n/**\r\n * Constructs a snapshot node representing the passed JSON and returns it.\r\n * @param json - JSON to create a node for.\r\n * @param priority - Optional priority to use.  This will be ignored if the\r\n * passed JSON contains a .priority property.\r\n */\r\nfunction nodeFromJSON(json, priority = null) {\r\n    if (json === null) {\r\n        return ChildrenNode.EMPTY_NODE;\r\n    }\r\n    if (typeof json === 'object' && '.priority' in json) {\r\n        priority = json['.priority'];\r\n    }\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priority === null ||\r\n        typeof priority === 'string' ||\r\n        typeof priority === 'number' ||\r\n        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);\r\n    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {\r\n        json = json['.value'];\r\n    }\r\n    // Valid leaf nodes include non-objects or server-value wrapper objects\r\n    if (typeof json !== 'object' || '.sv' in json) {\r\n        const jsonLeaf = json;\r\n        return new LeafNode(jsonLeaf, nodeFromJSON(priority));\r\n    }\r\n    if (!(json instanceof Array) && USE_HINZE) {\r\n        const children = [];\r\n        let childrenHavePriority = false;\r\n        const hinzeJsonObj = json;\r\n        each(hinzeJsonObj, (key, child) => {\r\n            if (key.substring(0, 1) !== '.') {\r\n                // Ignore metadata nodes\r\n                const childNode = nodeFromJSON(child);\r\n                if (!childNode.isEmpty()) {\r\n                    childrenHavePriority =\r\n                        childrenHavePriority || !childNode.getPriority().isEmpty();\r\n                    children.push(new NamedNode(key, childNode));\r\n                }\r\n            }\r\n        });\r\n        if (children.length === 0) {\r\n            return ChildrenNode.EMPTY_NODE;\r\n        }\r\n        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, namedNode => namedNode.name, NAME_COMPARATOR);\r\n        if (childrenHavePriority) {\r\n            const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());\r\n            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ '.priority': sortedChildSet }, { '.priority': PRIORITY_INDEX }));\r\n        }\r\n        else {\r\n            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);\r\n        }\r\n    }\r\n    else {\r\n        let node = ChildrenNode.EMPTY_NODE;\r\n        each(json, (key, childData) => {\r\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(json, key)) {\r\n                if (key.substring(0, 1) !== '.') {\r\n                    // ignore metadata nodes.\r\n                    const childNode = nodeFromJSON(childData);\r\n                    if (childNode.isLeafNode() || !childNode.isEmpty()) {\r\n                        node = node.updateImmediateChild(key, childNode);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return node.updatePriority(nodeFromJSON(priority));\r\n    }\r\n}\r\nsetNodeFromJSON(nodeFromJSON);\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass PathIndex extends Index {\r\n    constructor(indexPath_) {\r\n        super();\r\n        this.indexPath_ = indexPath_;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== '.priority', \"Can't create PathIndex with empty path or .priority key\");\r\n    }\r\n    extractChild(snap) {\r\n        return snap.getChild(this.indexPath_);\r\n    }\r\n    isDefinedOn(node) {\r\n        return !node.getChild(this.indexPath_).isEmpty();\r\n    }\r\n    compare(a, b) {\r\n        const aChild = this.extractChild(a.node);\r\n        const bChild = this.extractChild(b.node);\r\n        const indexCmp = aChild.compareTo(bChild);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    }\r\n    makePost(indexValue, name) {\r\n        const valueNode = nodeFromJSON(indexValue);\r\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);\r\n        return new NamedNode(name, node);\r\n    }\r\n    maxPost() {\r\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);\r\n        return new NamedNode(MAX_NAME, node);\r\n    }\r\n    toString() {\r\n        return pathSlice(this.indexPath_, 0).join('/');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ValueIndex extends Index {\r\n    compare(a, b) {\r\n        const indexCmp = a.node.compareTo(b.node);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    }\r\n    isDefinedOn(node) {\r\n        return true;\r\n    }\r\n    indexedValueChanged(oldNode, newNode) {\r\n        return !oldNode.equals(newNode);\r\n    }\r\n    minPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    }\r\n    maxPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MAX;\r\n    }\r\n    makePost(indexValue, name) {\r\n        const valueNode = nodeFromJSON(indexValue);\r\n        return new NamedNode(name, valueNode);\r\n    }\r\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */\r\n    toString() {\r\n        return '.value';\r\n    }\r\n}\r\nconst VALUE_INDEX = new ValueIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction changeValue(snapshotNode) {\r\n    return { type: \"value\" /* ChangeType.VALUE */, snapshotNode };\r\n}\r\nfunction changeChildAdded(childName, snapshotNode) {\r\n    return { type: \"child_added\" /* ChangeType.CHILD_ADDED */, snapshotNode, childName };\r\n}\r\nfunction changeChildRemoved(childName, snapshotNode) {\r\n    return { type: \"child_removed\" /* ChangeType.CHILD_REMOVED */, snapshotNode, childName };\r\n}\r\nfunction changeChildChanged(childName, snapshotNode, oldSnap) {\r\n    return {\r\n        type: \"child_changed\" /* ChangeType.CHILD_CHANGED */,\r\n        snapshotNode,\r\n        childName,\r\n        oldSnap\r\n    };\r\n}\r\nfunction changeChildMoved(childName, snapshotNode) {\r\n    return { type: \"child_moved\" /* ChangeType.CHILD_MOVED */, snapshotNode, childName };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\r\n */\r\nclass IndexedFilter {\r\n    constructor(index_) {\r\n        this.index_ = index_;\r\n    }\r\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\r\n        const oldChild = snap.getImmediateChild(key);\r\n        // Check if anything actually changed.\r\n        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\r\n            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\r\n            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\r\n            // to avoid treating these cases as \"nothing changed.\"\r\n            if (oldChild.isEmpty() === newChild.isEmpty()) {\r\n                // Nothing changed.\r\n                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\r\n                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\r\n                return snap;\r\n            }\r\n        }\r\n        if (optChangeAccumulator != null) {\r\n            if (newChild.isEmpty()) {\r\n                if (snap.hasChild(key)) {\r\n                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));\r\n                }\r\n                else {\r\n                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\r\n                }\r\n            }\r\n            else if (oldChild.isEmpty()) {\r\n                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));\r\n            }\r\n            else {\r\n                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));\r\n            }\r\n        }\r\n        if (snap.isLeafNode() && newChild.isEmpty()) {\r\n            return snap;\r\n        }\r\n        else {\r\n            // Make sure the node is indexed\r\n            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\r\n        }\r\n    }\r\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\r\n        if (optChangeAccumulator != null) {\r\n            if (!oldSnap.isLeafNode()) {\r\n                oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n                    if (!newSnap.hasChild(key)) {\r\n                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));\r\n                    }\r\n                });\r\n            }\r\n            if (!newSnap.isLeafNode()) {\r\n                newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n                    if (oldSnap.hasChild(key)) {\r\n                        const oldChild = oldSnap.getImmediateChild(key);\r\n                        if (!oldChild.equals(childNode)) {\r\n                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));\r\n                        }\r\n                    }\r\n                    else {\r\n                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return newSnap.withIndex(this.index_);\r\n    }\r\n    updatePriority(oldSnap, newPriority) {\r\n        if (oldSnap.isEmpty()) {\r\n            return ChildrenNode.EMPTY_NODE;\r\n        }\r\n        else {\r\n            return oldSnap.updatePriority(newPriority);\r\n        }\r\n    }\r\n    filtersNodes() {\r\n        return false;\r\n    }\r\n    getIndexedFilter() {\r\n        return this;\r\n    }\r\n    getIndex() {\r\n        return this.index_;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\r\n */\r\nclass RangedFilter {\r\n    constructor(params) {\r\n        this.indexedFilter_ = new IndexedFilter(params.getIndex());\r\n        this.index_ = params.getIndex();\r\n        this.startPost_ = RangedFilter.getStartPost_(params);\r\n        this.endPost_ = RangedFilter.getEndPost_(params);\r\n        this.startIsInclusive_ = !params.startAfterSet_;\r\n        this.endIsInclusive_ = !params.endBeforeSet_;\r\n    }\r\n    getStartPost() {\r\n        return this.startPost_;\r\n    }\r\n    getEndPost() {\r\n        return this.endPost_;\r\n    }\r\n    matches(node) {\r\n        const isWithinStart = this.startIsInclusive_\r\n            ? this.index_.compare(this.getStartPost(), node) <= 0\r\n            : this.index_.compare(this.getStartPost(), node) < 0;\r\n        const isWithinEnd = this.endIsInclusive_\r\n            ? this.index_.compare(node, this.getEndPost()) <= 0\r\n            : this.index_.compare(node, this.getEndPost()) < 0;\r\n        return isWithinStart && isWithinEnd;\r\n    }\r\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        if (!this.matches(new NamedNode(key, newChild))) {\r\n            newChild = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\r\n    }\r\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\r\n        if (newSnap.isLeafNode()) {\r\n            // Make sure we have a children node with the correct index, not a leaf node;\r\n            newSnap = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        let filtered = newSnap.withIndex(this.index_);\r\n        // Don't support priorities on queries\r\n        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\r\n        const self = this;\r\n        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n            if (!self.matches(new NamedNode(key, childNode))) {\r\n                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\r\n            }\r\n        });\r\n        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\r\n    }\r\n    updatePriority(oldSnap, newPriority) {\r\n        // Don't support priorities on queries\r\n        return oldSnap;\r\n    }\r\n    filtersNodes() {\r\n        return true;\r\n    }\r\n    getIndexedFilter() {\r\n        return this.indexedFilter_;\r\n    }\r\n    getIndex() {\r\n        return this.index_;\r\n    }\r\n    static getStartPost_(params) {\r\n        if (params.hasStart()) {\r\n            const startName = params.getIndexStartName();\r\n            return params.getIndex().makePost(params.getIndexStartValue(), startName);\r\n        }\r\n        else {\r\n            return params.getIndex().minPost();\r\n        }\r\n    }\r\n    static getEndPost_(params) {\r\n        if (params.hasEnd()) {\r\n            const endName = params.getIndexEndName();\r\n            return params.getIndex().makePost(params.getIndexEndValue(), endName);\r\n        }\r\n        else {\r\n            return params.getIndex().maxPost();\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\r\n */\r\nclass LimitedFilter {\r\n    constructor(params) {\r\n        this.withinDirectionalStart = (node) => this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);\r\n        this.withinDirectionalEnd = (node) => this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);\r\n        this.withinStartPost = (node) => {\r\n            const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);\r\n            return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;\r\n        };\r\n        this.withinEndPost = (node) => {\r\n            const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());\r\n            return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;\r\n        };\r\n        this.rangedFilter_ = new RangedFilter(params);\r\n        this.index_ = params.getIndex();\r\n        this.limit_ = params.getLimit();\r\n        this.reverse_ = !params.isViewFromLeft();\r\n        this.startIsInclusive_ = !params.startAfterSet_;\r\n        this.endIsInclusive_ = !params.endBeforeSet_;\r\n    }\r\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\r\n            newChild = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        if (snap.getImmediateChild(key).equals(newChild)) {\r\n            // No change\r\n            return snap;\r\n        }\r\n        else if (snap.numChildren() < this.limit_) {\r\n            return this.rangedFilter_\r\n                .getIndexedFilter()\r\n                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\r\n        }\r\n        else {\r\n            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\r\n        }\r\n    }\r\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\r\n        let filtered;\r\n        if (newSnap.isLeafNode() || newSnap.isEmpty()) {\r\n            // Make sure we have a children node with the correct index, not a leaf node;\r\n            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\r\n        }\r\n        else {\r\n            if (this.limit_ * 2 < newSnap.numChildren() &&\r\n                newSnap.isIndexed(this.index_)) {\r\n                // Easier to build up a snapshot, since what we're given has more than twice the elements we want\r\n                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\r\n                // anchor to the startPost, endPost, or last element as appropriate\r\n                let iterator;\r\n                if (this.reverse_) {\r\n                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\r\n                }\r\n                else {\r\n                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\r\n                }\r\n                let count = 0;\r\n                while (iterator.hasNext() && count < this.limit_) {\r\n                    const next = iterator.getNext();\r\n                    if (!this.withinDirectionalStart(next)) {\r\n                        // if we have not reached the start, skip to the next element\r\n                        continue;\r\n                    }\r\n                    else if (!this.withinDirectionalEnd(next)) {\r\n                        // if we have reached the end, stop adding elements\r\n                        break;\r\n                    }\r\n                    else {\r\n                        filtered = filtered.updateImmediateChild(next.name, next.node);\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\r\n                filtered = newSnap.withIndex(this.index_);\r\n                // Don't support priorities on queries\r\n                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\r\n                let iterator;\r\n                if (this.reverse_) {\r\n                    iterator = filtered.getReverseIterator(this.index_);\r\n                }\r\n                else {\r\n                    iterator = filtered.getIterator(this.index_);\r\n                }\r\n                let count = 0;\r\n                while (iterator.hasNext()) {\r\n                    const next = iterator.getNext();\r\n                    const inRange = count < this.limit_ &&\r\n                        this.withinDirectionalStart(next) &&\r\n                        this.withinDirectionalEnd(next);\r\n                    if (inRange) {\r\n                        count++;\r\n                    }\r\n                    else {\r\n                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this.rangedFilter_\r\n            .getIndexedFilter()\r\n            .updateFullNode(oldSnap, filtered, optChangeAccumulator);\r\n    }\r\n    updatePriority(oldSnap, newPriority) {\r\n        // Don't support priorities on queries\r\n        return oldSnap;\r\n    }\r\n    filtersNodes() {\r\n        return true;\r\n    }\r\n    getIndexedFilter() {\r\n        return this.rangedFilter_.getIndexedFilter();\r\n    }\r\n    getIndex() {\r\n        return this.index_;\r\n    }\r\n    fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) {\r\n        // TODO: rename all cache stuff etc to general snap terminology\r\n        let cmp;\r\n        if (this.reverse_) {\r\n            const indexCmp = this.index_.getCompare();\r\n            cmp = (a, b) => indexCmp(b, a);\r\n        }\r\n        else {\r\n            cmp = this.index_.getCompare();\r\n        }\r\n        const oldEventCache = snap;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(oldEventCache.numChildren() === this.limit_, '');\r\n        const newChildNamedNode = new NamedNode(childKey, childSnap);\r\n        const windowBoundary = this.reverse_\r\n            ? oldEventCache.getFirstChild(this.index_)\r\n            : oldEventCache.getLastChild(this.index_);\r\n        const inRange = this.rangedFilter_.matches(newChildNamedNode);\r\n        if (oldEventCache.hasChild(childKey)) {\r\n            const oldChildSnap = oldEventCache.getImmediateChild(childKey);\r\n            let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\r\n            while (nextChild != null &&\r\n                (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {\r\n                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\r\n                // been applied to the limited filter yet. Ignore this next child which will be updated later in\r\n                // the limited filter...\r\n                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\r\n            }\r\n            const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\r\n            const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\r\n            if (remainsInWindow) {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));\r\n                }\r\n                return oldEventCache.updateImmediateChild(childKey, childSnap);\r\n            }\r\n            else {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));\r\n                }\r\n                const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);\r\n                const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\r\n                if (nextChildInRange) {\r\n                    if (changeAccumulator != null) {\r\n                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));\r\n                    }\r\n                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\r\n                }\r\n                else {\r\n                    return newEventCache;\r\n                }\r\n            }\r\n        }\r\n        else if (childSnap.isEmpty()) {\r\n            // we're deleting a node, but it was not in the window, so ignore it\r\n            return snap;\r\n        }\r\n        else if (inRange) {\r\n            if (cmp(windowBoundary, newChildNamedNode) >= 0) {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));\r\n                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));\r\n                }\r\n                return oldEventCache\r\n                    .updateImmediateChild(childKey, childSnap)\r\n                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\r\n            }\r\n            else {\r\n                return snap;\r\n            }\r\n        }\r\n        else {\r\n            return snap;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a\r\n * range to be returned for a particular location. It is assumed that validation of parameters is done at the\r\n * user-facing API level, so it is not done here.\r\n *\r\n * @internal\r\n */\r\nclass QueryParams {\r\n    constructor() {\r\n        this.limitSet_ = false;\r\n        this.startSet_ = false;\r\n        this.startNameSet_ = false;\r\n        this.startAfterSet_ = false; // can only be true if startSet_ is true\r\n        this.endSet_ = false;\r\n        this.endNameSet_ = false;\r\n        this.endBeforeSet_ = false; // can only be true if endSet_ is true\r\n        this.limit_ = 0;\r\n        this.viewFrom_ = '';\r\n        this.indexStartValue_ = null;\r\n        this.indexStartName_ = '';\r\n        this.indexEndValue_ = null;\r\n        this.indexEndName_ = '';\r\n        this.index_ = PRIORITY_INDEX;\r\n    }\r\n    hasStart() {\r\n        return this.startSet_;\r\n    }\r\n    /**\r\n     * @returns True if it would return from left.\r\n     */\r\n    isViewFromLeft() {\r\n        if (this.viewFrom_ === '') {\r\n            // limit(), rather than limitToFirst or limitToLast was called.\r\n            // This means that only one of startSet_ and endSet_ is true. Use them\r\n            // to calculate which side of the view to anchor to. If neither is set,\r\n            // anchor to the end.\r\n            return this.startSet_;\r\n        }\r\n        else {\r\n            return this.viewFrom_ === \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;\r\n        }\r\n    }\r\n    /**\r\n     * Only valid to call if hasStart() returns true\r\n     */\r\n    getIndexStartValue() {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startSet_, 'Only valid if start has been set');\r\n        return this.indexStartValue_;\r\n    }\r\n    /**\r\n     * Only valid to call if hasStart() returns true.\r\n     * Returns the starting key name for the range defined by these query parameters\r\n     */\r\n    getIndexStartName() {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startSet_, 'Only valid if start has been set');\r\n        if (this.startNameSet_) {\r\n            return this.indexStartName_;\r\n        }\r\n        else {\r\n            return MIN_NAME;\r\n        }\r\n    }\r\n    hasEnd() {\r\n        return this.endSet_;\r\n    }\r\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     */\r\n    getIndexEndValue() {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.endSet_, 'Only valid if end has been set');\r\n        return this.indexEndValue_;\r\n    }\r\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     * Returns the end key name for the range defined by these query parameters\r\n     */\r\n    getIndexEndName() {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.endSet_, 'Only valid if end has been set');\r\n        if (this.endNameSet_) {\r\n            return this.indexEndName_;\r\n        }\r\n        else {\r\n            return MAX_NAME;\r\n        }\r\n    }\r\n    hasLimit() {\r\n        return this.limitSet_;\r\n    }\r\n    /**\r\n     * @returns True if a limit has been set and it has been explicitly anchored\r\n     */\r\n    hasAnchoredLimit() {\r\n        return this.limitSet_ && this.viewFrom_ !== '';\r\n    }\r\n    /**\r\n     * Only valid to call if hasLimit() returns true\r\n     */\r\n    getLimit() {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.limitSet_, 'Only valid if limit has been set');\r\n        return this.limit_;\r\n    }\r\n    getIndex() {\r\n        return this.index_;\r\n    }\r\n    loadsAllData() {\r\n        return !(this.startSet_ || this.endSet_ || this.limitSet_);\r\n    }\r\n    isDefault() {\r\n        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;\r\n    }\r\n    copy() {\r\n        const copy = new QueryParams();\r\n        copy.limitSet_ = this.limitSet_;\r\n        copy.limit_ = this.limit_;\r\n        copy.startSet_ = this.startSet_;\r\n        copy.startAfterSet_ = this.startAfterSet_;\r\n        copy.indexStartValue_ = this.indexStartValue_;\r\n        copy.startNameSet_ = this.startNameSet_;\r\n        copy.indexStartName_ = this.indexStartName_;\r\n        copy.endSet_ = this.endSet_;\r\n        copy.endBeforeSet_ = this.endBeforeSet_;\r\n        copy.indexEndValue_ = this.indexEndValue_;\r\n        copy.endNameSet_ = this.endNameSet_;\r\n        copy.indexEndName_ = this.indexEndName_;\r\n        copy.index_ = this.index_;\r\n        copy.viewFrom_ = this.viewFrom_;\r\n        return copy;\r\n    }\r\n}\r\nfunction queryParamsGetNodeFilter(queryParams) {\r\n    if (queryParams.loadsAllData()) {\r\n        return new IndexedFilter(queryParams.getIndex());\r\n    }\r\n    else if (queryParams.hasLimit()) {\r\n        return new LimitedFilter(queryParams);\r\n    }\r\n    else {\r\n        return new RangedFilter(queryParams);\r\n    }\r\n}\r\nfunction queryParamsLimitToFirst(queryParams, newLimit) {\r\n    const newParams = queryParams.copy();\r\n    newParams.limitSet_ = true;\r\n    newParams.limit_ = newLimit;\r\n    newParams.viewFrom_ = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;\r\n    return newParams;\r\n}\r\nfunction queryParamsLimitToLast(queryParams, newLimit) {\r\n    const newParams = queryParams.copy();\r\n    newParams.limitSet_ = true;\r\n    newParams.limit_ = newLimit;\r\n    newParams.viewFrom_ = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;\r\n    return newParams;\r\n}\r\nfunction queryParamsStartAt(queryParams, indexValue, key) {\r\n    const newParams = queryParams.copy();\r\n    newParams.startSet_ = true;\r\n    if (indexValue === undefined) {\r\n        indexValue = null;\r\n    }\r\n    newParams.indexStartValue_ = indexValue;\r\n    if (key != null) {\r\n        newParams.startNameSet_ = true;\r\n        newParams.indexStartName_ = key;\r\n    }\r\n    else {\r\n        newParams.startNameSet_ = false;\r\n        newParams.indexStartName_ = '';\r\n    }\r\n    return newParams;\r\n}\r\nfunction queryParamsStartAfter(queryParams, indexValue, key) {\r\n    let params;\r\n    if (queryParams.index_ === KEY_INDEX || !!key) {\r\n        params = queryParamsStartAt(queryParams, indexValue, key);\r\n    }\r\n    else {\r\n        params = queryParamsStartAt(queryParams, indexValue, MAX_NAME);\r\n    }\r\n    params.startAfterSet_ = true;\r\n    return params;\r\n}\r\nfunction queryParamsEndAt(queryParams, indexValue, key) {\r\n    const newParams = queryParams.copy();\r\n    newParams.endSet_ = true;\r\n    if (indexValue === undefined) {\r\n        indexValue = null;\r\n    }\r\n    newParams.indexEndValue_ = indexValue;\r\n    if (key !== undefined) {\r\n        newParams.endNameSet_ = true;\r\n        newParams.indexEndName_ = key;\r\n    }\r\n    else {\r\n        newParams.endNameSet_ = false;\r\n        newParams.indexEndName_ = '';\r\n    }\r\n    return newParams;\r\n}\r\nfunction queryParamsEndBefore(queryParams, indexValue, key) {\r\n    let params;\r\n    if (queryParams.index_ === KEY_INDEX || !!key) {\r\n        params = queryParamsEndAt(queryParams, indexValue, key);\r\n    }\r\n    else {\r\n        params = queryParamsEndAt(queryParams, indexValue, MIN_NAME);\r\n    }\r\n    params.endBeforeSet_ = true;\r\n    return params;\r\n}\r\nfunction queryParamsOrderBy(queryParams, index) {\r\n    const newParams = queryParams.copy();\r\n    newParams.index_ = index;\r\n    return newParams;\r\n}\r\n/**\r\n * Returns a set of REST query string parameters representing this query.\r\n *\r\n * @returns query string parameters\r\n */\r\nfunction queryParamsToRestQueryStringParameters(queryParams) {\r\n    const qs = {};\r\n    if (queryParams.isDefault()) {\r\n        return qs;\r\n    }\r\n    let orderBy;\r\n    if (queryParams.index_ === PRIORITY_INDEX) {\r\n        orderBy = \"$priority\" /* REST_QUERY_CONSTANTS.PRIORITY_INDEX */;\r\n    }\r\n    else if (queryParams.index_ === VALUE_INDEX) {\r\n        orderBy = \"$value\" /* REST_QUERY_CONSTANTS.VALUE_INDEX */;\r\n    }\r\n    else if (queryParams.index_ === KEY_INDEX) {\r\n        orderBy = \"$key\" /* REST_QUERY_CONSTANTS.KEY_INDEX */;\r\n    }\r\n    else {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queryParams.index_ instanceof PathIndex, 'Unrecognized index type!');\r\n        orderBy = queryParams.index_.toString();\r\n    }\r\n    qs[\"orderBy\" /* REST_QUERY_CONSTANTS.ORDER_BY */] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(orderBy);\r\n    if (queryParams.startSet_) {\r\n        const startParam = queryParams.startAfterSet_\r\n            ? \"startAfter\" /* REST_QUERY_CONSTANTS.START_AFTER */\r\n            : \"startAt\" /* REST_QUERY_CONSTANTS.START_AT */;\r\n        qs[startParam] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexStartValue_);\r\n        if (queryParams.startNameSet_) {\r\n            qs[startParam] += ',' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexStartName_);\r\n        }\r\n    }\r\n    if (queryParams.endSet_) {\r\n        const endParam = queryParams.endBeforeSet_\r\n            ? \"endBefore\" /* REST_QUERY_CONSTANTS.END_BEFORE */\r\n            : \"endAt\" /* REST_QUERY_CONSTANTS.END_AT */;\r\n        qs[endParam] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexEndValue_);\r\n        if (queryParams.endNameSet_) {\r\n            qs[endParam] += ',' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(queryParams.indexEndName_);\r\n        }\r\n    }\r\n    if (queryParams.limitSet_) {\r\n        if (queryParams.isViewFromLeft()) {\r\n            qs[\"limitToFirst\" /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */] = queryParams.limit_;\r\n        }\r\n        else {\r\n            qs[\"limitToLast\" /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */] = queryParams.limit_;\r\n        }\r\n    }\r\n    return qs;\r\n}\r\nfunction queryParamsGetQueryObject(queryParams) {\r\n    const obj = {};\r\n    if (queryParams.startSet_) {\r\n        obj[\"sp\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */] =\r\n            queryParams.indexStartValue_;\r\n        if (queryParams.startNameSet_) {\r\n            obj[\"sn\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */] =\r\n                queryParams.indexStartName_;\r\n        }\r\n        obj[\"sin\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */] =\r\n            !queryParams.startAfterSet_;\r\n    }\r\n    if (queryParams.endSet_) {\r\n        obj[\"ep\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */] = queryParams.indexEndValue_;\r\n        if (queryParams.endNameSet_) {\r\n            obj[\"en\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */] = queryParams.indexEndName_;\r\n        }\r\n        obj[\"ein\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */] =\r\n            !queryParams.endBeforeSet_;\r\n    }\r\n    if (queryParams.limitSet_) {\r\n        obj[\"l\" /* WIRE_PROTOCOL_CONSTANTS.LIMIT */] = queryParams.limit_;\r\n        let viewFrom = queryParams.viewFrom_;\r\n        if (viewFrom === '') {\r\n            if (queryParams.isViewFromLeft()) {\r\n                viewFrom = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;\r\n            }\r\n            else {\r\n                viewFrom = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;\r\n            }\r\n        }\r\n        obj[\"vf\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */] = viewFrom;\r\n    }\r\n    // For now, priority index is the default, so we only specify if it's some other index\r\n    if (queryParams.index_ !== PRIORITY_INDEX) {\r\n        obj[\"i\" /* WIRE_PROTOCOL_CONSTANTS.INDEX */] = queryParams.index_.toString();\r\n    }\r\n    return obj;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An implementation of ServerActions that communicates with the server via REST requests.\r\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\r\n * persistent connection (using WebSockets or long-polling)\r\n */\r\nclass ReadonlyRestClient extends ServerActions {\r\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */\r\n    constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {\r\n        super();\r\n        this.repoInfo_ = repoInfo_;\r\n        this.onDataUpdate_ = onDataUpdate_;\r\n        this.authTokenProvider_ = authTokenProvider_;\r\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\r\n        /** @private {function(...[*])} */\r\n        this.log_ = logWrapper('p:rest:');\r\n        /**\r\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\r\n         * that's been removed. :-/\r\n         */\r\n        this.listens_ = {};\r\n    }\r\n    reportStats(stats) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    static getListenId_(query, tag) {\r\n        if (tag !== undefined) {\r\n            return 'tag$' + tag;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query._queryParams.isDefault(), \"should have a tag if it's not a default query.\");\r\n            return query._path.toString();\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    listen(query, currentHashFn, tag, onComplete) {\r\n        const pathString = query._path.toString();\r\n        this.log_('Listen called for ' + pathString + ' ' + query._queryIdentifier);\r\n        // Mark this listener so we can tell if it's removed.\r\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\r\n        const thisListen = {};\r\n        this.listens_[listenId] = thisListen;\r\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\r\n        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => {\r\n            let data = result;\r\n            if (error === 404) {\r\n                data = null;\r\n                error = null;\r\n            }\r\n            if (error === null) {\r\n                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\r\n            }\r\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.listens_, listenId) === thisListen) {\r\n                let status;\r\n                if (!error) {\r\n                    status = 'ok';\r\n                }\r\n                else if (error === 401) {\r\n                    status = 'permission_denied';\r\n                }\r\n                else {\r\n                    status = 'rest_error:' + error;\r\n                }\r\n                onComplete(status, null);\r\n            }\r\n        });\r\n    }\r\n    /** @inheritDoc */\r\n    unlisten(query, tag) {\r\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\r\n        delete this.listens_[listenId];\r\n    }\r\n    get(query) {\r\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\r\n        const pathString = query._path.toString();\r\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => {\r\n            let data = result;\r\n            if (error === 404) {\r\n                data = null;\r\n                error = null;\r\n            }\r\n            if (error === null) {\r\n                this.onDataUpdate_(pathString, data, \r\n                /*isMerge=*/ false, \r\n                /*tag=*/ null);\r\n                deferred.resolve(data);\r\n            }\r\n            else {\r\n                deferred.reject(new Error(data));\r\n            }\r\n        });\r\n        return deferred.promise;\r\n    }\r\n    /** @inheritDoc */\r\n    refreshAuthToken(token) {\r\n        // no-op since we just always call getToken.\r\n    }\r\n    /**\r\n     * Performs a REST request to the given path, with the provided query string parameters,\r\n     * and any auth credentials we have.\r\n     */\r\n    restRequest_(pathString, queryStringParameters = {}, callback) {\r\n        queryStringParameters['format'] = 'export';\r\n        return Promise.all([\r\n            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),\r\n            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)\r\n        ]).then(([authToken, appCheckToken]) => {\r\n            if (authToken && authToken.accessToken) {\r\n                queryStringParameters['auth'] = authToken.accessToken;\r\n            }\r\n            if (appCheckToken && appCheckToken.token) {\r\n                queryStringParameters['ac'] = appCheckToken.token;\r\n            }\r\n            const url = (this.repoInfo_.secure ? 'https://' : 'http://') +\r\n                this.repoInfo_.host +\r\n                pathString +\r\n                '?' +\r\n                'ns=' +\r\n                this.repoInfo_.namespace +\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.querystring)(queryStringParameters);\r\n            this.log_('Sending REST request for ' + url);\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.onreadystatechange = () => {\r\n                if (callback && xhr.readyState === 4) {\r\n                    this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\r\n                    let res = null;\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        try {\r\n                            res = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(xhr.responseText);\r\n                        }\r\n                        catch (e) {\r\n                            warn('Failed to parse JSON response for ' +\r\n                                url +\r\n                                ': ' +\r\n                                xhr.responseText);\r\n                        }\r\n                        callback(null, res);\r\n                    }\r\n                    else {\r\n                        // 401 and 404 are expected.\r\n                        if (xhr.status !== 401 && xhr.status !== 404) {\r\n                            warn('Got unsuccessful REST response for ' +\r\n                                url +\r\n                                ' Status: ' +\r\n                                xhr.status);\r\n                        }\r\n                        callback(xhr.status);\r\n                    }\r\n                    callback = null;\r\n                }\r\n            };\r\n            xhr.open('GET', url, /*asynchronous=*/ true);\r\n            xhr.send();\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Mutable object which basically just stores a reference to the \"latest\" immutable snapshot.\r\n */\r\nclass SnapshotHolder {\r\n    constructor() {\r\n        this.rootNode_ = ChildrenNode.EMPTY_NODE;\r\n    }\r\n    getNode(path) {\r\n        return this.rootNode_.getChild(path);\r\n    }\r\n    updateSnapshot(path, newSnapshotNode) {\r\n        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newSparseSnapshotTree() {\r\n    return {\r\n        value: null,\r\n        children: new Map()\r\n    };\r\n}\r\n/**\r\n * Stores the given node at the specified path. If there is already a node\r\n * at a shallower path, it merges the new data into that snapshot node.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @param data - The new data, or null.\r\n */\r\nfunction sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {\r\n    if (pathIsEmpty(path)) {\r\n        sparseSnapshotTree.value = data;\r\n        sparseSnapshotTree.children.clear();\r\n    }\r\n    else if (sparseSnapshotTree.value !== null) {\r\n        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);\r\n    }\r\n    else {\r\n        const childKey = pathGetFront(path);\r\n        if (!sparseSnapshotTree.children.has(childKey)) {\r\n            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());\r\n        }\r\n        const child = sparseSnapshotTree.children.get(childKey);\r\n        path = pathPopFront(path);\r\n        sparseSnapshotTreeRemember(child, path, data);\r\n    }\r\n}\r\n/**\r\n * Purge the data at path from the cache.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns True if this node should now be removed.\r\n */\r\nfunction sparseSnapshotTreeForget(sparseSnapshotTree, path) {\r\n    if (pathIsEmpty(path)) {\r\n        sparseSnapshotTree.value = null;\r\n        sparseSnapshotTree.children.clear();\r\n        return true;\r\n    }\r\n    else {\r\n        if (sparseSnapshotTree.value !== null) {\r\n            if (sparseSnapshotTree.value.isLeafNode()) {\r\n                // We're trying to forget a node that doesn't exist\r\n                return false;\r\n            }\r\n            else {\r\n                const value = sparseSnapshotTree.value;\r\n                sparseSnapshotTree.value = null;\r\n                value.forEachChild(PRIORITY_INDEX, (key, tree) => {\r\n                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);\r\n                });\r\n                return sparseSnapshotTreeForget(sparseSnapshotTree, path);\r\n            }\r\n        }\r\n        else if (sparseSnapshotTree.children.size > 0) {\r\n            const childKey = pathGetFront(path);\r\n            path = pathPopFront(path);\r\n            if (sparseSnapshotTree.children.has(childKey)) {\r\n                const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);\r\n                if (safeToRemove) {\r\n                    sparseSnapshotTree.children.delete(childKey);\r\n                }\r\n            }\r\n            return sparseSnapshotTree.children.size === 0;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Recursively iterates through all of the stored tree and calls the\r\n * callback on each one.\r\n *\r\n * @param prefixPath - Path to look up node for.\r\n * @param func - The function to invoke for each tree.\r\n */\r\nfunction sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {\r\n    if (sparseSnapshotTree.value !== null) {\r\n        func(prefixPath, sparseSnapshotTree.value);\r\n    }\r\n    else {\r\n        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree) => {\r\n            const path = new Path(prefixPath.toString() + '/' + key);\r\n            sparseSnapshotTreeForEachTree(tree, path, func);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Iterates through each immediate child and triggers the callback.\r\n * Only seems to be used in tests.\r\n *\r\n * @param func - The function to invoke for each child.\r\n */\r\nfunction sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {\r\n    sparseSnapshotTree.children.forEach((tree, key) => {\r\n        func(key, tree);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns the delta from the previous call to get stats.\r\n *\r\n * @param collection_ - The collection to \"listen\" to.\r\n */\r\nclass StatsListener {\r\n    constructor(collection_) {\r\n        this.collection_ = collection_;\r\n        this.last_ = null;\r\n    }\r\n    get() {\r\n        const newStats = this.collection_.get();\r\n        const delta = Object.assign({}, newStats);\r\n        if (this.last_) {\r\n            each(this.last_, (stat, value) => {\r\n                delta[stat] = delta[stat] - value;\r\n            });\r\n        }\r\n        this.last_ = newStats;\r\n        return delta;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\r\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\r\n// seconds to try to ensure the Firebase connection is established / settled.\r\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\r\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\r\n// We'll continue to report stats on average every 5 minutes.\r\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\r\nclass StatsReporter {\r\n    constructor(collection, server_) {\r\n        this.server_ = server_;\r\n        this.statsToReport_ = {};\r\n        this.statsListener_ = new StatsListener(collection);\r\n        const timeout = FIRST_STATS_MIN_TIME +\r\n            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\r\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\r\n    }\r\n    reportStats_() {\r\n        const stats = this.statsListener_.get();\r\n        const reportedStats = {};\r\n        let haveStatsToReport = false;\r\n        each(stats, (stat, value) => {\r\n            if (value > 0 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.statsToReport_, stat)) {\r\n                reportedStats[stat] = value;\r\n                haveStatsToReport = true;\r\n            }\r\n        });\r\n        if (haveStatsToReport) {\r\n            this.server_.reportStats(reportedStats);\r\n        }\r\n        // queue our next run.\r\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n *\r\n * @enum\r\n */\r\nvar OperationType;\r\n(function (OperationType) {\r\n    OperationType[OperationType[\"OVERWRITE\"] = 0] = \"OVERWRITE\";\r\n    OperationType[OperationType[\"MERGE\"] = 1] = \"MERGE\";\r\n    OperationType[OperationType[\"ACK_USER_WRITE\"] = 2] = \"ACK_USER_WRITE\";\r\n    OperationType[OperationType[\"LISTEN_COMPLETE\"] = 3] = \"LISTEN_COMPLETE\";\r\n})(OperationType || (OperationType = {}));\r\nfunction newOperationSourceUser() {\r\n    return {\r\n        fromUser: true,\r\n        fromServer: false,\r\n        queryId: null,\r\n        tagged: false\r\n    };\r\n}\r\nfunction newOperationSourceServer() {\r\n    return {\r\n        fromUser: false,\r\n        fromServer: true,\r\n        queryId: null,\r\n        tagged: false\r\n    };\r\n}\r\nfunction newOperationSourceServerTaggedQuery(queryId) {\r\n    return {\r\n        fromUser: false,\r\n        fromServer: true,\r\n        queryId,\r\n        tagged: true\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AckUserWrite {\r\n    /**\r\n     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.\r\n     */\r\n    constructor(\r\n    /** @inheritDoc */ path, \r\n    /** @inheritDoc */ affectedTree, \r\n    /** @inheritDoc */ revert) {\r\n        this.path = path;\r\n        this.affectedTree = affectedTree;\r\n        this.revert = revert;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.ACK_USER_WRITE;\r\n        /** @inheritDoc */\r\n        this.source = newOperationSourceUser();\r\n    }\r\n    operationForChild(childName) {\r\n        if (!pathIsEmpty(this.path)) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(this.path) === childName, 'operationForChild called for unrelated child.');\r\n            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);\r\n        }\r\n        else if (this.affectedTree.value != null) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');\r\n            // All child locations are affected as well; just return same operation.\r\n            return this;\r\n        }\r\n        else {\r\n            const childTree = this.affectedTree.subtree(new Path(childName));\r\n            return new AckUserWrite(newEmptyPath(), childTree, this.revert);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ListenComplete {\r\n    constructor(source, path) {\r\n        this.source = source;\r\n        this.path = path;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.LISTEN_COMPLETE;\r\n    }\r\n    operationForChild(childName) {\r\n        if (pathIsEmpty(this.path)) {\r\n            return new ListenComplete(this.source, newEmptyPath());\r\n        }\r\n        else {\r\n            return new ListenComplete(this.source, pathPopFront(this.path));\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Overwrite {\r\n    constructor(source, path, snap) {\r\n        this.source = source;\r\n        this.path = path;\r\n        this.snap = snap;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.OVERWRITE;\r\n    }\r\n    operationForChild(childName) {\r\n        if (pathIsEmpty(this.path)) {\r\n            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));\r\n        }\r\n        else {\r\n            return new Overwrite(this.source, pathPopFront(this.path), this.snap);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Merge {\r\n    constructor(\r\n    /** @inheritDoc */ source, \r\n    /** @inheritDoc */ path, \r\n    /** @inheritDoc */ children) {\r\n        this.source = source;\r\n        this.path = path;\r\n        this.children = children;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.MERGE;\r\n    }\r\n    operationForChild(childName) {\r\n        if (pathIsEmpty(this.path)) {\r\n            const childTree = this.children.subtree(new Path(childName));\r\n            if (childTree.isEmpty()) {\r\n                // This child is unaffected\r\n                return null;\r\n            }\r\n            else if (childTree.value) {\r\n                // We have a snapshot for the child in question.  This becomes an overwrite of the child.\r\n                return new Overwrite(this.source, newEmptyPath(), childTree.value);\r\n            }\r\n            else {\r\n                // This is a merge at a deeper level\r\n                return new Merge(this.source, newEmptyPath(), childTree);\r\n            }\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetFront(this.path) === childName, \"Can't get a merge for a child not on the path of the operation\");\r\n            return new Merge(this.source, pathPopFront(this.path), this.children);\r\n        }\r\n    }\r\n    toString() {\r\n        return ('Operation(' +\r\n            this.path +\r\n            ': ' +\r\n            this.source.toString() +\r\n            ' merge: ' +\r\n            this.children.toString() +\r\n            ')');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully\r\n * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.\r\n * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks\r\n * whether a node potentially had children removed due to a filter.\r\n */\r\nclass CacheNode {\r\n    constructor(node_, fullyInitialized_, filtered_) {\r\n        this.node_ = node_;\r\n        this.fullyInitialized_ = fullyInitialized_;\r\n        this.filtered_ = filtered_;\r\n    }\r\n    /**\r\n     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client\r\n     */\r\n    isFullyInitialized() {\r\n        return this.fullyInitialized_;\r\n    }\r\n    /**\r\n     * Returns whether this node is potentially missing children due to a filter applied to the node\r\n     */\r\n    isFiltered() {\r\n        return this.filtered_;\r\n    }\r\n    isCompleteForPath(path) {\r\n        if (pathIsEmpty(path)) {\r\n            return this.isFullyInitialized() && !this.filtered_;\r\n        }\r\n        const childKey = pathGetFront(path);\r\n        return this.isCompleteForChild(childKey);\r\n    }\r\n    isCompleteForChild(key) {\r\n        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));\r\n    }\r\n    getNode() {\r\n        return this.node_;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An EventGenerator is used to convert \"raw\" changes (Change) as computed by the\r\n * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()\r\n * for details.\r\n *\r\n */\r\nclass EventGenerator {\r\n    constructor(query_) {\r\n        this.query_ = query_;\r\n        this.index_ = this.query_._queryParams.getIndex();\r\n    }\r\n}\r\n/**\r\n * Given a set of raw changes (no moved events and prevName not specified yet), and a set of\r\n * EventRegistrations that should be notified of these changes, generate the actual events to be raised.\r\n *\r\n * Notes:\r\n *  - child_moved events will be synthesized at this time for any child_changed events that affect\r\n *    our index.\r\n *  - prevName will be calculated based on the index ordering.\r\n */\r\nfunction eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {\r\n    const events = [];\r\n    const moves = [];\r\n    changes.forEach(change => {\r\n        if (change.type === \"child_changed\" /* ChangeType.CHILD_CHANGED */ &&\r\n            eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {\r\n            moves.push(changeChildMoved(change.childName, change.snapshotNode));\r\n        }\r\n    });\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_removed\" /* ChangeType.CHILD_REMOVED */, changes, eventRegistrations, eventCache);\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_added\" /* ChangeType.CHILD_ADDED */, changes, eventRegistrations, eventCache);\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_moved\" /* ChangeType.CHILD_MOVED */, moves, eventRegistrations, eventCache);\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_changed\" /* ChangeType.CHILD_CHANGED */, changes, eventRegistrations, eventCache);\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"value\" /* ChangeType.VALUE */, changes, eventRegistrations, eventCache);\r\n    return events;\r\n}\r\n/**\r\n * Given changes of a single change type, generate the corresponding events.\r\n */\r\nfunction eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {\r\n    const filteredChanges = changes.filter(change => change.type === eventType);\r\n    filteredChanges.sort((a, b) => eventGeneratorCompareChanges(eventGenerator, a, b));\r\n    filteredChanges.forEach(change => {\r\n        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);\r\n        registrations.forEach(registration => {\r\n            if (registration.respondsTo(change.type)) {\r\n                events.push(registration.createEvent(materializedChange, eventGenerator.query_));\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {\r\n    if (change.type === 'value' || change.type === 'child_removed') {\r\n        return change;\r\n    }\r\n    else {\r\n        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);\r\n        return change;\r\n    }\r\n}\r\nfunction eventGeneratorCompareChanges(eventGenerator, a, b) {\r\n    if (a.childName == null || b.childName == null) {\r\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Should only compare child_ events.');\r\n    }\r\n    const aWrapped = new NamedNode(a.childName, a.snapshotNode);\r\n    const bWrapped = new NamedNode(b.childName, b.snapshotNode);\r\n    return eventGenerator.index_.compare(aWrapped, bWrapped);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newViewCache(eventCache, serverCache) {\r\n    return { eventCache, serverCache };\r\n}\r\nfunction viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {\r\n    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);\r\n}\r\nfunction viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {\r\n    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));\r\n}\r\nfunction viewCacheGetCompleteEventSnap(viewCache) {\r\n    return viewCache.eventCache.isFullyInitialized()\r\n        ? viewCache.eventCache.getNode()\r\n        : null;\r\n}\r\nfunction viewCacheGetCompleteServerSnap(viewCache) {\r\n    return viewCache.serverCache.isFullyInitialized()\r\n        ? viewCache.serverCache.getNode()\r\n        : null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet emptyChildrenSingleton;\r\n/**\r\n * Singleton empty children collection.\r\n *\r\n */\r\nconst EmptyChildren = () => {\r\n    if (!emptyChildrenSingleton) {\r\n        emptyChildrenSingleton = new SortedMap(stringCompare);\r\n    }\r\n    return emptyChildrenSingleton;\r\n};\r\n/**\r\n * A tree with immutable elements.\r\n */\r\nclass ImmutableTree {\r\n    constructor(value, children = EmptyChildren()) {\r\n        this.value = value;\r\n        this.children = children;\r\n    }\r\n    static fromObject(obj) {\r\n        let tree = new ImmutableTree(null);\r\n        each(obj, (childPath, childSnap) => {\r\n            tree = tree.set(new Path(childPath), childSnap);\r\n        });\r\n        return tree;\r\n    }\r\n    /**\r\n     * True if the value is empty and there are no children\r\n     */\r\n    isEmpty() {\r\n        return this.value === null && this.children.isEmpty();\r\n    }\r\n    /**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`\r\n     * objects on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param relativePath - The remainder of the path\r\n     * @param predicate - The predicate to satisfy to return a node\r\n     */\r\n    findRootMostMatchingPathAndValue(relativePath, predicate) {\r\n        if (this.value != null && predicate(this.value)) {\r\n            return { path: newEmptyPath(), value: this.value };\r\n        }\r\n        else {\r\n            if (pathIsEmpty(relativePath)) {\r\n                return null;\r\n            }\r\n            else {\r\n                const front = pathGetFront(relativePath);\r\n                const child = this.children.get(front);\r\n                if (child !== null) {\r\n                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);\r\n                    if (childExistingPathAndValue != null) {\r\n                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);\r\n                        return { path: fullPath, value: childExistingPathAndValue.value };\r\n                    }\r\n                    else {\r\n                        return null;\r\n                    }\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     */\r\n    findRootMostValueAndPath(relativePath) {\r\n        return this.findRootMostMatchingPathAndValue(relativePath, () => true);\r\n    }\r\n    /**\r\n     * @returns The subtree at the given path\r\n     */\r\n    subtree(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return this;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const childTree = this.children.get(front);\r\n            if (childTree !== null) {\r\n                return childTree.subtree(pathPopFront(relativePath));\r\n            }\r\n            else {\r\n                return new ImmutableTree(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param relativePath - Path to set value at.\r\n     * @param toSet - Value to set.\r\n     * @returns Resulting tree.\r\n     */\r\n    set(relativePath, toSet) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return new ImmutableTree(toSet, this.children);\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front) || new ImmutableTree(null);\r\n            const newChild = child.set(pathPopFront(relativePath), toSet);\r\n            const newChildren = this.children.insert(front, newChild);\r\n            return new ImmutableTree(this.value, newChildren);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param relativePath - Path to value to remove.\r\n     * @returns Resulting tree.\r\n     */\r\n    remove(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            if (this.children.isEmpty()) {\r\n                return new ImmutableTree(null);\r\n            }\r\n            else {\r\n                return new ImmutableTree(null, this.children);\r\n            }\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front);\r\n            if (child) {\r\n                const newChild = child.remove(pathPopFront(relativePath));\r\n                let newChildren;\r\n                if (newChild.isEmpty()) {\r\n                    newChildren = this.children.remove(front);\r\n                }\r\n                else {\r\n                    newChildren = this.children.insert(front, newChild);\r\n                }\r\n                if (this.value === null && newChildren.isEmpty()) {\r\n                    return new ImmutableTree(null);\r\n                }\r\n                else {\r\n                    return new ImmutableTree(this.value, newChildren);\r\n                }\r\n            }\r\n            else {\r\n                return this;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param relativePath - Path to get value for.\r\n     * @returns Value at path, or null.\r\n     */\r\n    get(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return this.value;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front);\r\n            if (child) {\r\n                return child.get(pathPopFront(relativePath));\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param relativePath - Path to replace subtree for.\r\n     * @param newTree - New tree.\r\n     * @returns Resulting tree.\r\n     */\r\n    setTree(relativePath, newTree) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return newTree;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front) || new ImmutableTree(null);\r\n            const newChild = child.setTree(pathPopFront(relativePath), newTree);\r\n            let newChildren;\r\n            if (newChild.isEmpty()) {\r\n                newChildren = this.children.remove(front);\r\n            }\r\n            else {\r\n                newChildren = this.children.insert(front, newChild);\r\n            }\r\n            return new ImmutableTree(this.value, newChildren);\r\n        }\r\n    }\r\n    /**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     */\r\n    fold(fn) {\r\n        return this.fold_(newEmptyPath(), fn);\r\n    }\r\n    /**\r\n     * Recursive helper for public-facing fold() method\r\n     */\r\n    fold_(pathSoFar, fn) {\r\n        const accum = {};\r\n        this.children.inorderTraversal((childKey, childTree) => {\r\n            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);\r\n        });\r\n        return fn(pathSoFar, this.value, accum);\r\n    }\r\n    /**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     */\r\n    findOnPath(path, f) {\r\n        return this.findOnPath_(path, newEmptyPath(), f);\r\n    }\r\n    findOnPath_(pathToFollow, pathSoFar, f) {\r\n        const result = this.value ? f(pathSoFar, this.value) : false;\r\n        if (result) {\r\n            return result;\r\n        }\r\n        else {\r\n            if (pathIsEmpty(pathToFollow)) {\r\n                return null;\r\n            }\r\n            else {\r\n                const front = pathGetFront(pathToFollow);\r\n                const nextChild = this.children.get(front);\r\n                if (nextChild) {\r\n                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    foreachOnPath(path, f) {\r\n        return this.foreachOnPath_(path, newEmptyPath(), f);\r\n    }\r\n    foreachOnPath_(pathToFollow, currentRelativePath, f) {\r\n        if (pathIsEmpty(pathToFollow)) {\r\n            return this;\r\n        }\r\n        else {\r\n            if (this.value) {\r\n                f(currentRelativePath, this.value);\r\n            }\r\n            const front = pathGetFront(pathToFollow);\r\n            const nextChild = this.children.get(front);\r\n            if (nextChild) {\r\n                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);\r\n            }\r\n            else {\r\n                return new ImmutableTree(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param f - A function to be called with the path from the root of the tree to\r\n     * a node, and the value at that node. Called in depth-first order.\r\n     */\r\n    foreach(f) {\r\n        this.foreach_(newEmptyPath(), f);\r\n    }\r\n    foreach_(currentRelativePath, f) {\r\n        this.children.inorderTraversal((childName, childTree) => {\r\n            childTree.foreach_(pathChild(currentRelativePath, childName), f);\r\n        });\r\n        if (this.value) {\r\n            f(currentRelativePath, this.value);\r\n        }\r\n    }\r\n    foreachChild(f) {\r\n        this.children.inorderTraversal((childName, childTree) => {\r\n            if (childTree.value) {\r\n                f(childName, childTree.value);\r\n            }\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\r\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\r\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\r\n * to reflect the write added.\r\n */\r\nclass CompoundWrite {\r\n    constructor(writeTree_) {\r\n        this.writeTree_ = writeTree_;\r\n    }\r\n    static empty() {\r\n        return new CompoundWrite(new ImmutableTree(null));\r\n    }\r\n}\r\nfunction compoundWriteAddWrite(compoundWrite, path, node) {\r\n    if (pathIsEmpty(path)) {\r\n        return new CompoundWrite(new ImmutableTree(node));\r\n    }\r\n    else {\r\n        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\r\n        if (rootmost != null) {\r\n            const rootMostPath = rootmost.path;\r\n            let value = rootmost.value;\r\n            const relativePath = newRelativePath(rootMostPath, path);\r\n            value = value.updateChild(relativePath, node);\r\n            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));\r\n        }\r\n        else {\r\n            const subtree = new ImmutableTree(node);\r\n            const newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);\r\n            return new CompoundWrite(newWriteTree);\r\n        }\r\n    }\r\n}\r\nfunction compoundWriteAddWrites(compoundWrite, path, updates) {\r\n    let newWrite = compoundWrite;\r\n    each(updates, (childKey, node) => {\r\n        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);\r\n    });\r\n    return newWrite;\r\n}\r\n/**\r\n * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\r\n * location, which must be removed by calling this method with that path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to remove.\r\n * @param path - The path at which a write and all deeper writes should be removed\r\n * @returns The new CompoundWrite with the removed path\r\n */\r\nfunction compoundWriteRemoveWrite(compoundWrite, path) {\r\n    if (pathIsEmpty(path)) {\r\n        return CompoundWrite.empty();\r\n    }\r\n    else {\r\n        const newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));\r\n        return new CompoundWrite(newWriteTree);\r\n    }\r\n}\r\n/**\r\n * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\r\n * considered \"complete\".\r\n *\r\n * @param compoundWrite - The CompoundWrite to check.\r\n * @param path - The path to check for\r\n * @returns Whether there is a complete write at that path\r\n */\r\nfunction compoundWriteHasCompleteWrite(compoundWrite, path) {\r\n    return compoundWriteGetCompleteNode(compoundWrite, path) != null;\r\n}\r\n/**\r\n * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\r\n * writes from deeper paths, but will return child nodes from a more shallow path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get the node from.\r\n * @param path - The path to get a complete write\r\n * @returns The node if complete at that path, or null otherwise.\r\n */\r\nfunction compoundWriteGetCompleteNode(compoundWrite, path) {\r\n    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\r\n    if (rootmost != null) {\r\n        return compoundWrite.writeTree_\r\n            .get(rootmost.path)\r\n            .getChild(newRelativePath(rootmost.path, path));\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Returns all children that are guaranteed to be a complete overwrite.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get children from.\r\n * @returns A list of all complete children.\r\n */\r\nfunction compoundWriteGetCompleteChildren(compoundWrite) {\r\n    const children = [];\r\n    const node = compoundWrite.writeTree_.value;\r\n    if (node != null) {\r\n        // If it's a leaf node, it has no children; so nothing to do.\r\n        if (!node.isLeafNode()) {\r\n            node.forEachChild(PRIORITY_INDEX, (childName, childNode) => {\r\n                children.push(new NamedNode(childName, childNode));\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree) => {\r\n            if (childTree.value != null) {\r\n                children.push(new NamedNode(childName, childTree.value));\r\n            }\r\n        });\r\n    }\r\n    return children;\r\n}\r\nfunction compoundWriteChildCompoundWrite(compoundWrite, path) {\r\n    if (pathIsEmpty(path)) {\r\n        return compoundWrite;\r\n    }\r\n    else {\r\n        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);\r\n        if (shadowingNode != null) {\r\n            return new CompoundWrite(new ImmutableTree(shadowingNode));\r\n        }\r\n        else {\r\n            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\r\n * @returns Whether this CompoundWrite is empty\r\n */\r\nfunction compoundWriteIsEmpty(compoundWrite) {\r\n    return compoundWrite.writeTree_.isEmpty();\r\n}\r\n/**\r\n * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\r\n * node\r\n * @param node - The node to apply this CompoundWrite to\r\n * @returns The node with all writes applied\r\n */\r\nfunction compoundWriteApply(compoundWrite, node) {\r\n    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);\r\n}\r\nfunction applySubtreeWrite(relativePath, writeTree, node) {\r\n    if (writeTree.value != null) {\r\n        // Since there a write is always a leaf, we're done here\r\n        return node.updateChild(relativePath, writeTree.value);\r\n    }\r\n    else {\r\n        let priorityWrite = null;\r\n        writeTree.children.inorderTraversal((childKey, childTree) => {\r\n            if (childKey === '.priority') {\r\n                // Apply priorities at the end so we don't update priorities for either empty nodes or forget\r\n                // to apply priorities to empty nodes that are later filled\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(childTree.value !== null, 'Priority writes must always be leaf nodes');\r\n                priorityWrite = childTree.value;\r\n            }\r\n            else {\r\n                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);\r\n            }\r\n        });\r\n        // If there was a priority write, we only apply it if the node is not empty\r\n        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\r\n            node = node.updateChild(pathChild(relativePath, '.priority'), priorityWrite);\r\n        }\r\n        return node;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n *\r\n */\r\nfunction writeTreeChildWrites(writeTree, path) {\r\n    return newWriteTreeRef(path, writeTree);\r\n}\r\n/**\r\n * Record a new overwrite from user code.\r\n *\r\n * @param visible - This is set to false by some transactions. It should be excluded from event caches\r\n */\r\nfunction writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(writeId > writeTree.lastWriteId, 'Stacking an older write on top of newer ones');\r\n    if (visible === undefined) {\r\n        visible = true;\r\n    }\r\n    writeTree.allWrites.push({\r\n        path,\r\n        snap,\r\n        writeId,\r\n        visible\r\n    });\r\n    if (visible) {\r\n        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);\r\n    }\r\n    writeTree.lastWriteId = writeId;\r\n}\r\n/**\r\n * Record a new merge from user code.\r\n */\r\nfunction writeTreeAddMerge(writeTree, path, changedChildren, writeId) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(writeId > writeTree.lastWriteId, 'Stacking an older merge on top of newer ones');\r\n    writeTree.allWrites.push({\r\n        path,\r\n        children: changedChildren,\r\n        writeId,\r\n        visible: true\r\n    });\r\n    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);\r\n    writeTree.lastWriteId = writeId;\r\n}\r\nfunction writeTreeGetWrite(writeTree, writeId) {\r\n    for (let i = 0; i < writeTree.allWrites.length; i++) {\r\n        const record = writeTree.allWrites[i];\r\n        if (record.writeId === writeId) {\r\n            return record;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n *\r\n * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n * events as a result).\r\n */\r\nfunction writeTreeRemoveWrite(writeTree, writeId) {\r\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\r\n    // out of order.\r\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\r\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\r\n    const idx = writeTree.allWrites.findIndex(s => {\r\n        return s.writeId === writeId;\r\n    });\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(idx >= 0, 'removeWrite called with nonexistent writeId.');\r\n    const writeToRemove = writeTree.allWrites[idx];\r\n    writeTree.allWrites.splice(idx, 1);\r\n    let removedWriteWasVisible = writeToRemove.visible;\r\n    let removedWriteOverlapsWithOtherWrites = false;\r\n    let i = writeTree.allWrites.length - 1;\r\n    while (removedWriteWasVisible && i >= 0) {\r\n        const currentWrite = writeTree.allWrites[i];\r\n        if (currentWrite.visible) {\r\n            if (i >= idx &&\r\n                writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {\r\n                // The removed write was completely shadowed by a subsequent write.\r\n                removedWriteWasVisible = false;\r\n            }\r\n            else if (pathContains(writeToRemove.path, currentWrite.path)) {\r\n                // Either we're covering some writes or they're covering part of us (depending on which came first).\r\n                removedWriteOverlapsWithOtherWrites = true;\r\n            }\r\n        }\r\n        i--;\r\n    }\r\n    if (!removedWriteWasVisible) {\r\n        return false;\r\n    }\r\n    else if (removedWriteOverlapsWithOtherWrites) {\r\n        // There's some shadowing going on. Just rebuild the visible writes from scratch.\r\n        writeTreeResetTree_(writeTree);\r\n        return true;\r\n    }\r\n    else {\r\n        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\r\n        if (writeToRemove.snap) {\r\n            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);\r\n        }\r\n        else {\r\n            const children = writeToRemove.children;\r\n            each(children, (childName) => {\r\n                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));\r\n            });\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction writeTreeRecordContainsPath_(writeRecord, path) {\r\n    if (writeRecord.snap) {\r\n        return pathContains(writeRecord.path, path);\r\n    }\r\n    else {\r\n        for (const childName in writeRecord.children) {\r\n            if (writeRecord.children.hasOwnProperty(childName) &&\r\n                pathContains(pathChild(writeRecord.path, childName), path)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n */\r\nfunction writeTreeResetTree_(writeTree) {\r\n    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());\r\n    if (writeTree.allWrites.length > 0) {\r\n        writeTree.lastWriteId =\r\n            writeTree.allWrites[writeTree.allWrites.length - 1].writeId;\r\n    }\r\n    else {\r\n        writeTree.lastWriteId = -1;\r\n    }\r\n}\r\n/**\r\n * The default filter used when constructing the tree. Keep everything that's visible.\r\n */\r\nfunction writeTreeDefaultFilter_(write) {\r\n    return write.visible;\r\n}\r\n/**\r\n * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n * event data at that path.\r\n */\r\nfunction writeTreeLayerTree_(writes, filter, treeRoot) {\r\n    let compoundWrite = CompoundWrite.empty();\r\n    for (let i = 0; i < writes.length; ++i) {\r\n        const write = writes[i];\r\n        // Theory, a later set will either:\r\n        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\r\n        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\r\n        if (filter(write)) {\r\n            const writePath = write.path;\r\n            let relativePath;\r\n            if (write.snap) {\r\n                if (pathContains(treeRoot, writePath)) {\r\n                    relativePath = newRelativePath(treeRoot, writePath);\r\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);\r\n                }\r\n                else if (pathContains(writePath, treeRoot)) {\r\n                    relativePath = newRelativePath(writePath, treeRoot);\r\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));\r\n                }\r\n                else ;\r\n            }\r\n            else if (write.children) {\r\n                if (pathContains(treeRoot, writePath)) {\r\n                    relativePath = newRelativePath(treeRoot, writePath);\r\n                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);\r\n                }\r\n                else if (pathContains(writePath, treeRoot)) {\r\n                    relativePath = newRelativePath(writePath, treeRoot);\r\n                    if (pathIsEmpty(relativePath)) {\r\n                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);\r\n                    }\r\n                    else {\r\n                        const child = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(write.children, pathGetFront(relativePath));\r\n                        if (child) {\r\n                            // There exists a child in this node that matches the root path\r\n                            const deepNode = child.getChild(pathPopFront(relativePath));\r\n                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);\r\n                        }\r\n                    }\r\n                }\r\n                else ;\r\n            }\r\n            else {\r\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('WriteRecord should have .snap or .children');\r\n            }\r\n        }\r\n    }\r\n    return compoundWrite;\r\n}\r\n/**\r\n * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n * writes), attempt to calculate a complete snapshot for the given path\r\n *\r\n * @param writeIdsToExclude - An optional set to be excluded\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */\r\nfunction writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\r\n    if (!writeIdsToExclude && !includeHiddenWrites) {\r\n        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\r\n        if (shadowingNode != null) {\r\n            return shadowingNode;\r\n        }\r\n        else {\r\n            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n            if (compoundWriteIsEmpty(subMerge)) {\r\n                return completeServerCache;\r\n            }\r\n            else if (completeServerCache == null &&\r\n                !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {\r\n                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\r\n                return null;\r\n            }\r\n            else {\r\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\r\n                return compoundWriteApply(subMerge, layeredCache);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {\r\n            return completeServerCache;\r\n        }\r\n        else {\r\n            // If the server cache is null, and we don't have a complete cache, we need to return null\r\n            if (!includeHiddenWrites &&\r\n                completeServerCache == null &&\r\n                !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {\r\n                return null;\r\n            }\r\n            else {\r\n                const filter = function (write) {\r\n                    return ((write.visible || includeHiddenWrites) &&\r\n                        (!writeIdsToExclude ||\r\n                            !~writeIdsToExclude.indexOf(write.writeId)) &&\r\n                        (pathContains(write.path, treePath) ||\r\n                            pathContains(treePath, write.path)));\r\n                };\r\n                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);\r\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\r\n                return compoundWriteApply(mergeAtPath, layeredCache);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n * Used when creating new views, to pre-fill their complete event children snapshot.\r\n */\r\nfunction writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {\r\n    let completeChildren = ChildrenNode.EMPTY_NODE;\r\n    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\r\n    if (topLevelSet) {\r\n        if (!topLevelSet.isLeafNode()) {\r\n            // we're shadowing everything. Return the children.\r\n            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => {\r\n                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\r\n            });\r\n        }\r\n        return completeChildren;\r\n    }\r\n    else if (completeServerChildren) {\r\n        // Layer any children we have on top of this\r\n        // We know we don't have a top-level set, so just enumerate existing children\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => {\r\n            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);\r\n            completeChildren = completeChildren.updateImmediateChild(childName, node);\r\n        });\r\n        // Add any complete children we have from the set\r\n        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {\r\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\r\n        });\r\n        return completeChildren;\r\n    }\r\n    else {\r\n        // We don't have anything to layer on top of. Layer on any children we have\r\n        // Note that we can return an empty snap if we have a defined delete\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {\r\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\r\n        });\r\n        return completeChildren;\r\n    }\r\n}\r\n/**\r\n * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n * applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist\r\n */\r\nfunction writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');\r\n    const path = pathChild(treePath, childPath);\r\n    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {\r\n        // At this point we can probably guarantee that we're in case 2, meaning no events\r\n        // May need to check visibility while doing the findRootMostValueAndPath call\r\n        return null;\r\n    }\r\n    else {\r\n        // No complete shadowing. We're either partially shadowing or not shadowing at all.\r\n        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\r\n        if (compoundWriteIsEmpty(childMerge)) {\r\n            // We're not shadowing at all. Case 1\r\n            return existingServerSnap.getChild(childPath);\r\n        }\r\n        else {\r\n            // This could be more efficient if the serverNode + updates doesn't change the eventSnap\r\n            // However this is tricky to find out, since user updates don't necessary change the server\r\n            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\r\n            // adds nodes, but doesn't change any existing writes. It is therefore not enough to\r\n            // only check if the updates change the serverNode.\r\n            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\r\n            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */\r\nfunction writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {\r\n    const path = pathChild(treePath, childKey);\r\n    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\r\n    if (shadowingNode != null) {\r\n        return shadowingNode;\r\n    }\r\n    else {\r\n        if (existingServerSnap.isCompleteForChild(childKey)) {\r\n            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\r\n            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n */\r\nfunction writeTreeShadowingWrite(writeTree, path) {\r\n    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\r\n}\r\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window.\r\n */\r\nfunction writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {\r\n    let toIterate;\r\n    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());\r\n    if (shadowingNode != null) {\r\n        toIterate = shadowingNode;\r\n    }\r\n    else if (completeServerData != null) {\r\n        toIterate = compoundWriteApply(merge, completeServerData);\r\n    }\r\n    else {\r\n        // no children to iterate on\r\n        return [];\r\n    }\r\n    toIterate = toIterate.withIndex(index);\r\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\r\n        const nodes = [];\r\n        const cmp = index.getCompare();\r\n        const iter = reverse\r\n            ? toIterate.getReverseIteratorFrom(startPost, index)\r\n            : toIterate.getIteratorFrom(startPost, index);\r\n        let next = iter.getNext();\r\n        while (next && nodes.length < count) {\r\n            if (cmp(next, startPost) !== 0) {\r\n                nodes.push(next);\r\n            }\r\n            next = iter.getNext();\r\n        }\r\n        return nodes;\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nfunction newWriteTree() {\r\n    return {\r\n        visibleWrites: CompoundWrite.empty(),\r\n        allWrites: [],\r\n        lastWriteId: -1\r\n    };\r\n}\r\n/**\r\n * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n * can lead to a more expensive calculation.\r\n *\r\n * @param writeIdsToExclude - Optional writes to exclude.\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */\r\nfunction writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\r\n    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);\r\n}\r\n/**\r\n * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n * mix of the given server data and write data.\r\n *\r\n */\r\nfunction writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {\r\n    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);\r\n}\r\n/**\r\n * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n * if anything, needs to be applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events should be raised\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n *\r\n *\r\n */\r\nfunction writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {\r\n    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);\r\n}\r\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n *\r\n */\r\nfunction writeTreeRefShadowingWrite(writeTreeRef, path) {\r\n    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));\r\n}\r\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window\r\n */\r\nfunction writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {\r\n    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);\r\n}\r\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */\r\nfunction writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {\r\n    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);\r\n}\r\n/**\r\n * Return a WriteTreeRef for a child.\r\n */\r\nfunction writeTreeRefChild(writeTreeRef, childName) {\r\n    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);\r\n}\r\nfunction newWriteTreeRef(path, writeTree) {\r\n    return {\r\n        treePath: path,\r\n        writeTree\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ChildChangeAccumulator {\r\n    constructor() {\r\n        this.changeMap = new Map();\r\n    }\r\n    trackChildChange(change) {\r\n        const type = change.type;\r\n        const childKey = change.childName;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(type === \"child_added\" /* ChangeType.CHILD_ADDED */ ||\r\n            type === \"child_changed\" /* ChangeType.CHILD_CHANGED */ ||\r\n            type === \"child_removed\" /* ChangeType.CHILD_REMOVED */, 'Only child changes supported for tracking');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(childKey !== '.priority', 'Only non-priority child changes can be tracked.');\r\n        const oldChange = this.changeMap.get(childKey);\r\n        if (oldChange) {\r\n            const oldType = oldChange.type;\r\n            if (type === \"child_added\" /* ChangeType.CHILD_ADDED */ &&\r\n                oldType === \"child_removed\" /* ChangeType.CHILD_REMOVED */) {\r\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));\r\n            }\r\n            else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */ &&\r\n                oldType === \"child_added\" /* ChangeType.CHILD_ADDED */) {\r\n                this.changeMap.delete(childKey);\r\n            }\r\n            else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */ &&\r\n                oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */) {\r\n                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));\r\n            }\r\n            else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */ &&\r\n                oldType === \"child_added\" /* ChangeType.CHILD_ADDED */) {\r\n                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));\r\n            }\r\n            else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */ &&\r\n                oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */) {\r\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));\r\n            }\r\n            else {\r\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Illegal combination of changes: ' +\r\n                    change +\r\n                    ' occurred after ' +\r\n                    oldChange);\r\n            }\r\n        }\r\n        else {\r\n            this.changeMap.set(childKey, change);\r\n        }\r\n    }\r\n    getChanges() {\r\n        return Array.from(this.changeMap.values());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An implementation of CompleteChildSource that never returns any additional children\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass NoCompleteChildSource_ {\r\n    getCompleteChild(childKey) {\r\n        return null;\r\n    }\r\n    getChildAfterChild(index, child, reverse) {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Singleton instance.\r\n */\r\nconst NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();\r\n/**\r\n * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or\r\n * old event caches available to calculate complete children.\r\n */\r\nclass WriteTreeCompleteChildSource {\r\n    constructor(writes_, viewCache_, optCompleteServerCache_ = null) {\r\n        this.writes_ = writes_;\r\n        this.viewCache_ = viewCache_;\r\n        this.optCompleteServerCache_ = optCompleteServerCache_;\r\n    }\r\n    getCompleteChild(childKey) {\r\n        const node = this.viewCache_.eventCache;\r\n        if (node.isCompleteForChild(childKey)) {\r\n            return node.getNode().getImmediateChild(childKey);\r\n        }\r\n        else {\r\n            const serverNode = this.optCompleteServerCache_ != null\r\n                ? new CacheNode(this.optCompleteServerCache_, true, false)\r\n                : this.viewCache_.serverCache;\r\n            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);\r\n        }\r\n    }\r\n    getChildAfterChild(index, child, reverse) {\r\n        const completeServerData = this.optCompleteServerCache_ != null\r\n            ? this.optCompleteServerCache_\r\n            : viewCacheGetCompleteServerSnap(this.viewCache_);\r\n        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);\r\n        if (nodes.length === 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return nodes[0];\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newViewProcessor(filter) {\r\n    return { filter };\r\n}\r\nfunction viewProcessorAssertIndexed(viewProcessor, viewCache) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Event snap not indexed');\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Server snap not indexed');\r\n}\r\nfunction viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {\r\n    const accumulator = new ChildChangeAccumulator();\r\n    let newViewCache, filterServerNode;\r\n    if (operation.type === OperationType.OVERWRITE) {\r\n        const overwrite = operation;\r\n        if (overwrite.source.fromUser) {\r\n            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(overwrite.source.fromServer, 'Unknown source.');\r\n            // We filter the node if it's a tagged update or the node has been previously filtered  and the\r\n            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\r\n            // again\r\n            filterServerNode =\r\n                overwrite.source.tagged ||\r\n                    (oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path));\r\n            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n    }\r\n    else if (operation.type === OperationType.MERGE) {\r\n        const merge = operation;\r\n        if (merge.source.fromUser) {\r\n            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(merge.source.fromServer, 'Unknown source.');\r\n            // We filter the node if it's a tagged update or the node has been previously filtered\r\n            filterServerNode =\r\n                merge.source.tagged || oldViewCache.serverCache.isFiltered();\r\n            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n    }\r\n    else if (operation.type === OperationType.ACK_USER_WRITE) {\r\n        const ackUserWrite = operation;\r\n        if (!ackUserWrite.revert) {\r\n            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\r\n        }\r\n        else {\r\n            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\r\n        }\r\n    }\r\n    else if (operation.type === OperationType.LISTEN_COMPLETE) {\r\n        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);\r\n    }\r\n    else {\r\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Unknown operation type: ' + operation.type);\r\n    }\r\n    const changes = accumulator.getChanges();\r\n    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);\r\n    return { viewCache: newViewCache, changes };\r\n}\r\nfunction viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) {\r\n    const eventSnap = newViewCache.eventCache;\r\n    if (eventSnap.isFullyInitialized()) {\r\n        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\r\n        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);\r\n        if (accumulator.length > 0 ||\r\n            !oldViewCache.eventCache.isFullyInitialized() ||\r\n            (isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap)) ||\r\n            !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\r\n            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));\r\n        }\r\n    }\r\n}\r\nfunction viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {\r\n    const oldEventSnap = viewCache.eventCache;\r\n    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {\r\n        // we have a shadowing write, ignore changes\r\n        return viewCache;\r\n    }\r\n    else {\r\n        let newEventCache, serverNode;\r\n        if (pathIsEmpty(changePath)) {\r\n            // TODO: figure out how this plays with \"sliding ack windows\"\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.serverCache.isFullyInitialized(), 'If change path is empty, we must have complete server data');\r\n            if (viewCache.serverCache.isFiltered()) {\r\n                // We need to special case this, because we need to only apply writes to complete children, or\r\n                // we might end up raising events for incomplete children. If the server data is filtered deep\r\n                // writes cannot be guaranteed to be complete\r\n                const serverCache = viewCacheGetCompleteServerSnap(viewCache);\r\n                const completeChildren = serverCache instanceof ChildrenNode\r\n                    ? serverCache\r\n                    : ChildrenNode.EMPTY_NODE;\r\n                const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);\r\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);\r\n            }\r\n            else {\r\n                const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\r\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);\r\n            }\r\n        }\r\n        else {\r\n            const childKey = pathGetFront(changePath);\r\n            if (childKey === '.priority') {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(pathGetLength(changePath) === 1, \"Can't have a priority with additional path components\");\r\n                const oldEventNode = oldEventSnap.getNode();\r\n                serverNode = viewCache.serverCache.getNode();\r\n                // we might have overwrites for this priority\r\n                const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);\r\n                if (updatedPriority != null) {\r\n                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);\r\n                }\r\n                else {\r\n                    // priority didn't change, keep old node\r\n                    newEventCache = oldEventSnap.getNode();\r\n                }\r\n            }\r\n            else {\r\n                const childChangePath = pathPopFront(changePath);\r\n                // update child\r\n                let newEventChild;\r\n                if (oldEventSnap.isCompleteForChild(childKey)) {\r\n                    serverNode = viewCache.serverCache.getNode();\r\n                    const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);\r\n                    if (eventChildUpdate != null) {\r\n                        newEventChild = oldEventSnap\r\n                            .getNode()\r\n                            .getImmediateChild(childKey)\r\n                            .updateChild(childChangePath, eventChildUpdate);\r\n                    }\r\n                    else {\r\n                        // Nothing changed, just keep the old child\r\n                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\r\n                    }\r\n                }\r\n                else {\r\n                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\r\n                }\r\n                if (newEventChild != null) {\r\n                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\r\n                }\r\n                else {\r\n                    // no complete child available or no change\r\n                    newEventCache = oldEventSnap.getNode();\r\n                }\r\n            }\r\n        }\r\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());\r\n    }\r\n}\r\nfunction viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\r\n    const oldServerSnap = oldViewCache.serverCache;\r\n    let newServerCache;\r\n    const serverFilter = filterServerNode\r\n        ? viewProcessor.filter\r\n        : viewProcessor.filter.getIndexedFilter();\r\n    if (pathIsEmpty(changePath)) {\r\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\r\n    }\r\n    else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\r\n        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\r\n        const newServerNode = oldServerSnap\r\n            .getNode()\r\n            .updateChild(changePath, changedSnap);\r\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\r\n    }\r\n    else {\r\n        const childKey = pathGetFront(changePath);\r\n        if (!oldServerSnap.isCompleteForPath(changePath) &&\r\n            pathGetLength(changePath) > 1) {\r\n            // We don't update incomplete nodes with updates intended for other listeners\r\n            return oldViewCache;\r\n        }\r\n        const childChangePath = pathPopFront(changePath);\r\n        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\r\n        const newChildNode = childNode.updateChild(childChangePath, changedSnap);\r\n        if (childKey === '.priority') {\r\n            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\r\n        }\r\n        else {\r\n            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);\r\n        }\r\n    }\r\n    const newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());\r\n    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\r\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);\r\n}\r\nfunction viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\r\n    const oldEventSnap = oldViewCache.eventCache;\r\n    let newViewCache, newEventCache;\r\n    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\r\n    if (pathIsEmpty(changePath)) {\r\n        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);\r\n        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());\r\n    }\r\n    else {\r\n        const childKey = pathGetFront(changePath);\r\n        if (childKey === '.priority') {\r\n            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);\r\n            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\r\n        }\r\n        else {\r\n            const childChangePath = pathPopFront(changePath);\r\n            const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\r\n            let newChild;\r\n            if (pathIsEmpty(childChangePath)) {\r\n                // Child overwrite, we can replace the child\r\n                newChild = changedSnap;\r\n            }\r\n            else {\r\n                const childNode = source.getCompleteChild(childKey);\r\n                if (childNode != null) {\r\n                    if (pathGetBack(childChangePath) === '.priority' &&\r\n                        childNode.getChild(pathParent(childChangePath)).isEmpty()) {\r\n                        // This is a priority update on an empty node. If this node exists on the server, the\r\n                        // server will send down the priority in the update, so ignore for now\r\n                        newChild = childNode;\r\n                    }\r\n                    else {\r\n                        newChild = childNode.updateChild(childChangePath, changedSnap);\r\n                    }\r\n                }\r\n                else {\r\n                    // There is no complete child node available\r\n                    newChild = ChildrenNode.EMPTY_NODE;\r\n                }\r\n            }\r\n            if (!oldChild.equals(newChild)) {\r\n                const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\r\n                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());\r\n            }\r\n            else {\r\n                newViewCache = oldViewCache;\r\n            }\r\n        }\r\n    }\r\n    return newViewCache;\r\n}\r\nfunction viewProcessorCacheHasChild(viewCache, childKey) {\r\n    return viewCache.eventCache.isCompleteForChild(childKey);\r\n}\r\nfunction viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\r\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\r\n    // window leaving room for new items.  It's important we process these changes first, so we\r\n    // iterate the changes twice, first processing any that affect items currently in view.\r\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\r\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\r\n    // not the other.\r\n    let curViewCache = viewCache;\r\n    changedChildren.foreach((relativePath, childNode) => {\r\n        const writePath = pathChild(path, relativePath);\r\n        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\r\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\r\n        }\r\n    });\r\n    changedChildren.foreach((relativePath, childNode) => {\r\n        const writePath = pathChild(path, relativePath);\r\n        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\r\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\r\n        }\r\n    });\r\n    return curViewCache;\r\n}\r\nfunction viewProcessorApplyMerge(viewProcessor, node, merge) {\r\n    merge.foreach((relativePath, childNode) => {\r\n        node = node.updateChild(relativePath, childNode);\r\n    });\r\n    return node;\r\n}\r\nfunction viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\r\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\r\n    // wait for the complete data update coming soon.\r\n    if (viewCache.serverCache.getNode().isEmpty() &&\r\n        !viewCache.serverCache.isFullyInitialized()) {\r\n        return viewCache;\r\n    }\r\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\r\n    // window leaving room for new items.  It's important we process these changes first, so we\r\n    // iterate the changes twice, first processing any that affect items currently in view.\r\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\r\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\r\n    // not the other.\r\n    let curViewCache = viewCache;\r\n    let viewMergeTree;\r\n    if (pathIsEmpty(path)) {\r\n        viewMergeTree = changedChildren;\r\n    }\r\n    else {\r\n        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);\r\n    }\r\n    const serverNode = viewCache.serverCache.getNode();\r\n    viewMergeTree.children.inorderTraversal((childKey, childTree) => {\r\n        if (serverNode.hasChild(childKey)) {\r\n            const serverChild = viewCache.serverCache\r\n                .getNode()\r\n                .getImmediateChild(childKey);\r\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);\r\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\r\n        }\r\n    });\r\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {\r\n        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) &&\r\n            childMergeTree.value === null;\r\n        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\r\n            const serverChild = viewCache.serverCache\r\n                .getNode()\r\n                .getImmediateChild(childKey);\r\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);\r\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\r\n        }\r\n    });\r\n    return curViewCache;\r\n}\r\nfunction viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\r\n    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {\r\n        return viewCache;\r\n    }\r\n    // Only filter server node if it is currently filtered\r\n    const filterServerNode = viewCache.serverCache.isFiltered();\r\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\r\n    // now that it won't be shadowed.\r\n    const serverCache = viewCache.serverCache;\r\n    if (affectedTree.value != null) {\r\n        // This is an overwrite.\r\n        if ((pathIsEmpty(ackPath) && serverCache.isFullyInitialized()) ||\r\n            serverCache.isCompleteForPath(ackPath)) {\r\n            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n        else if (pathIsEmpty(ackPath)) {\r\n            // This is a goofy edge case where we are acking data at this location but don't have full data.  We\r\n            // should just re-apply whatever we have in our cache as a merge.\r\n            let changedChildren = new ImmutableTree(null);\r\n            serverCache.getNode().forEachChild(KEY_INDEX, (name, node) => {\r\n                changedChildren = changedChildren.set(new Path(name), node);\r\n            });\r\n            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n        else {\r\n            return viewCache;\r\n        }\r\n    }\r\n    else {\r\n        // This is a merge.\r\n        let changedChildren = new ImmutableTree(null);\r\n        affectedTree.foreach((mergePath, value) => {\r\n            const serverCachePath = pathChild(ackPath, mergePath);\r\n            if (serverCache.isCompleteForPath(serverCachePath)) {\r\n                changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));\r\n            }\r\n        });\r\n        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\r\n    }\r\n}\r\nfunction viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {\r\n    const oldServerNode = viewCache.serverCache;\r\n    const newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());\r\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);\r\n}\r\nfunction viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {\r\n    let complete;\r\n    if (writeTreeRefShadowingWrite(writesCache, path) != null) {\r\n        return viewCache;\r\n    }\r\n    else {\r\n        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\r\n        const oldEventCache = viewCache.eventCache.getNode();\r\n        let newEventCache;\r\n        if (pathIsEmpty(path) || pathGetFront(path) === '.priority') {\r\n            let newNode;\r\n            if (viewCache.serverCache.isFullyInitialized()) {\r\n                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\r\n            }\r\n            else {\r\n                const serverChildren = viewCache.serverCache.getNode();\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');\r\n                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);\r\n            }\r\n            newNode = newNode;\r\n            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);\r\n        }\r\n        else {\r\n            const childKey = pathGetFront(path);\r\n            let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\r\n            if (newChild == null &&\r\n                viewCache.serverCache.isCompleteForChild(childKey)) {\r\n                newChild = oldEventCache.getImmediateChild(childKey);\r\n            }\r\n            if (newChild != null) {\r\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);\r\n            }\r\n            else if (viewCache.eventCache.getNode().hasChild(childKey)) {\r\n                // No complete child available, delete the existing one, if any\r\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);\r\n            }\r\n            else {\r\n                newEventCache = oldEventCache;\r\n            }\r\n            if (newEventCache.isEmpty() &&\r\n                viewCache.serverCache.isFullyInitialized()) {\r\n                // We might have reverted all child writes. Maybe the old event was a leaf node\r\n                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\r\n                if (complete.isLeafNode()) {\r\n                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);\r\n                }\r\n            }\r\n        }\r\n        complete =\r\n            viewCache.serverCache.isFullyInitialized() ||\r\n                writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;\r\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A view represents a specific location and query that has 1 or more event registrations.\r\n *\r\n * It does several things:\r\n *  - Maintains the list of event registrations for this location/query.\r\n *  - Maintains a cache of the data visible for this location/query.\r\n *  - Applies new operations (via applyOperation), updates the cache, and based on the event\r\n *    registrations returns the set of events to be raised.\r\n */\r\nclass View {\r\n    constructor(query_, initialViewCache) {\r\n        this.query_ = query_;\r\n        this.eventRegistrations_ = [];\r\n        const params = this.query_._queryParams;\r\n        const indexFilter = new IndexedFilter(params.getIndex());\r\n        const filter = queryParamsGetNodeFilter(params);\r\n        this.processor_ = newViewProcessor(filter);\r\n        const initialServerCache = initialViewCache.serverCache;\r\n        const initialEventCache = initialViewCache.eventCache;\r\n        // Don't filter server node with other filter than index, wait for tagged listen\r\n        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);\r\n        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);\r\n        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());\r\n        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());\r\n        this.viewCache_ = newViewCache(newEventCache, newServerCache);\r\n        this.eventGenerator_ = new EventGenerator(this.query_);\r\n    }\r\n    get query() {\r\n        return this.query_;\r\n    }\r\n}\r\nfunction viewGetServerCache(view) {\r\n    return view.viewCache_.serverCache.getNode();\r\n}\r\nfunction viewGetCompleteNode(view) {\r\n    return viewCacheGetCompleteEventSnap(view.viewCache_);\r\n}\r\nfunction viewGetCompleteServerCache(view, path) {\r\n    const cache = viewCacheGetCompleteServerSnap(view.viewCache_);\r\n    if (cache) {\r\n        // If this isn't a \"loadsAllData\" view, then cache isn't actually a complete cache and\r\n        // we need to see if it contains the child we're interested in.\r\n        if (view.query._queryParams.loadsAllData() ||\r\n            (!pathIsEmpty(path) &&\r\n                !cache.getImmediateChild(pathGetFront(path)).isEmpty())) {\r\n            return cache.getChild(path);\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction viewIsEmpty(view) {\r\n    return view.eventRegistrations_.length === 0;\r\n}\r\nfunction viewAddEventRegistration(view, eventRegistration) {\r\n    view.eventRegistrations_.push(eventRegistration);\r\n}\r\n/**\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns Cancel events, if cancelError was provided.\r\n */\r\nfunction viewRemoveEventRegistration(view, eventRegistration, cancelError) {\r\n    const cancelEvents = [];\r\n    if (cancelError) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventRegistration == null, 'A cancel should cancel all event registrations.');\r\n        const path = view.query._path;\r\n        view.eventRegistrations_.forEach(registration => {\r\n            const maybeEvent = registration.createCancelEvent(cancelError, path);\r\n            if (maybeEvent) {\r\n                cancelEvents.push(maybeEvent);\r\n            }\r\n        });\r\n    }\r\n    if (eventRegistration) {\r\n        let remaining = [];\r\n        for (let i = 0; i < view.eventRegistrations_.length; ++i) {\r\n            const existing = view.eventRegistrations_[i];\r\n            if (!existing.matches(eventRegistration)) {\r\n                remaining.push(existing);\r\n            }\r\n            else if (eventRegistration.hasAnyCallback()) {\r\n                // We're removing just this one\r\n                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));\r\n                break;\r\n            }\r\n        }\r\n        view.eventRegistrations_ = remaining;\r\n    }\r\n    else {\r\n        view.eventRegistrations_ = [];\r\n    }\r\n    return cancelEvents;\r\n}\r\n/**\r\n * Applies the given Operation, updates our cache, and returns the appropriate events.\r\n */\r\nfunction viewApplyOperation(view, operation, writesCache, completeServerCache) {\r\n    if (operation.type === OperationType.MERGE &&\r\n        operation.source.queryId !== null) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCacheGetCompleteServerSnap(view.viewCache_), 'We should always have a full cache before handling merges');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCacheGetCompleteEventSnap(view.viewCache_), 'Missing event cache, even though we have a server cache');\r\n    }\r\n    const oldViewCache = view.viewCache_;\r\n    const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);\r\n    viewProcessorAssertIndexed(view.processor_, result.viewCache);\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(result.viewCache.serverCache.isFullyInitialized() ||\r\n        !oldViewCache.serverCache.isFullyInitialized(), 'Once a server snap is complete, it should never go back');\r\n    view.viewCache_ = result.viewCache;\r\n    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);\r\n}\r\nfunction viewGetInitialEvents(view, registration) {\r\n    const eventSnap = view.viewCache_.eventCache;\r\n    const initialChanges = [];\r\n    if (!eventSnap.getNode().isLeafNode()) {\r\n        const eventNode = eventSnap.getNode();\r\n        eventNode.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n            initialChanges.push(changeChildAdded(key, childNode));\r\n        });\r\n    }\r\n    if (eventSnap.isFullyInitialized()) {\r\n        initialChanges.push(changeValue(eventSnap.getNode()));\r\n    }\r\n    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);\r\n}\r\nfunction viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {\r\n    const registrations = eventRegistration\r\n        ? [eventRegistration]\r\n        : view.eventRegistrations_;\r\n    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet referenceConstructor$1;\r\n/**\r\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\r\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\r\n * and user writes (set, transaction, update).\r\n *\r\n * It's responsible for:\r\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\r\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\r\n *    applyUserOverwrite, etc.)\r\n */\r\nclass SyncPoint {\r\n    constructor() {\r\n        /**\r\n         * The Views being tracked at this location in the tree, stored as a map where the key is a\r\n         * queryId and the value is the View for that query.\r\n         *\r\n         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\r\n         */\r\n        this.views = new Map();\r\n    }\r\n}\r\nfunction syncPointSetReferenceConstructor(val) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!referenceConstructor$1, '__referenceConstructor has already been defined');\r\n    referenceConstructor$1 = val;\r\n}\r\nfunction syncPointGetReferenceConstructor() {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(referenceConstructor$1, 'Reference.ts has not been loaded');\r\n    return referenceConstructor$1;\r\n}\r\nfunction syncPointIsEmpty(syncPoint) {\r\n    return syncPoint.views.size === 0;\r\n}\r\nfunction syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {\r\n    const queryId = operation.source.queryId;\r\n    if (queryId !== null) {\r\n        const view = syncPoint.views.get(queryId);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(view != null, 'SyncTree gave us an op for an invalid query.');\r\n        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);\r\n    }\r\n    else {\r\n        let events = [];\r\n        for (const view of syncPoint.views.values()) {\r\n            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));\r\n        }\r\n        return events;\r\n    }\r\n}\r\n/**\r\n * Get a view for the specified query.\r\n *\r\n * @param query - The query to return a view for\r\n * @param writesCache\r\n * @param serverCache\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */\r\nfunction syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {\r\n    const queryId = query._queryIdentifier;\r\n    const view = syncPoint.views.get(queryId);\r\n    if (!view) {\r\n        // TODO: make writesCache take flag for complete server node\r\n        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);\r\n        let eventCacheComplete = false;\r\n        if (eventCache) {\r\n            eventCacheComplete = true;\r\n        }\r\n        else if (serverCache instanceof ChildrenNode) {\r\n            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);\r\n            eventCacheComplete = false;\r\n        }\r\n        else {\r\n            eventCache = ChildrenNode.EMPTY_NODE;\r\n            eventCacheComplete = false;\r\n        }\r\n        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));\r\n        return new View(query, viewCache);\r\n    }\r\n    return view;\r\n}\r\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @param query\r\n * @param eventRegistration\r\n * @param writesCache\r\n * @param serverCache - Complete server cache, if we have it.\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */\r\nfunction syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\r\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);\r\n    if (!syncPoint.views.has(query._queryIdentifier)) {\r\n        syncPoint.views.set(query._queryIdentifier, view);\r\n    }\r\n    // This is guaranteed to exist now, we just created anything that was missing\r\n    viewAddEventRegistration(view, eventRegistration);\r\n    return viewGetInitialEvents(view, eventRegistration);\r\n}\r\n/**\r\n * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\r\n *\r\n * If query is the default query, we'll check all views for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\r\n *\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns removed queries and any cancel events\r\n */\r\nfunction syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {\r\n    const queryId = query._queryIdentifier;\r\n    const removed = [];\r\n    let cancelEvents = [];\r\n    const hadCompleteView = syncPointHasCompleteView(syncPoint);\r\n    if (queryId === 'default') {\r\n        // When you do ref.off(...), we search all views for the registration to remove.\r\n        for (const [viewQueryId, view] of syncPoint.views.entries()) {\r\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\r\n            if (viewIsEmpty(view)) {\r\n                syncPoint.views.delete(viewQueryId);\r\n                // We'll deal with complete views later.\r\n                if (!view.query._queryParams.loadsAllData()) {\r\n                    removed.push(view.query);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // remove the callback from the specific view.\r\n        const view = syncPoint.views.get(queryId);\r\n        if (view) {\r\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\r\n            if (viewIsEmpty(view)) {\r\n                syncPoint.views.delete(queryId);\r\n                // We'll deal with complete views later.\r\n                if (!view.query._queryParams.loadsAllData()) {\r\n                    removed.push(view.query);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {\r\n        // We removed our last complete view.\r\n        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));\r\n    }\r\n    return { removed, events: cancelEvents };\r\n}\r\nfunction syncPointGetQueryViews(syncPoint) {\r\n    const result = [];\r\n    for (const view of syncPoint.views.values()) {\r\n        if (!view.query._queryParams.loadsAllData()) {\r\n            result.push(view);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @param path - The path to the desired complete snapshot\r\n * @returns A complete cache, if it exists\r\n */\r\nfunction syncPointGetCompleteServerCache(syncPoint, path) {\r\n    let serverCache = null;\r\n    for (const view of syncPoint.views.values()) {\r\n        serverCache = serverCache || viewGetCompleteServerCache(view, path);\r\n    }\r\n    return serverCache;\r\n}\r\nfunction syncPointViewForQuery(syncPoint, query) {\r\n    const params = query._queryParams;\r\n    if (params.loadsAllData()) {\r\n        return syncPointGetCompleteView(syncPoint);\r\n    }\r\n    else {\r\n        const queryId = query._queryIdentifier;\r\n        return syncPoint.views.get(queryId);\r\n    }\r\n}\r\nfunction syncPointViewExistsForQuery(syncPoint, query) {\r\n    return syncPointViewForQuery(syncPoint, query) != null;\r\n}\r\nfunction syncPointHasCompleteView(syncPoint) {\r\n    return syncPointGetCompleteView(syncPoint) != null;\r\n}\r\nfunction syncPointGetCompleteView(syncPoint) {\r\n    for (const view of syncPoint.views.values()) {\r\n        if (view.query._queryParams.loadsAllData()) {\r\n            return view;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet referenceConstructor;\r\nfunction syncTreeSetReferenceConstructor(val) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!referenceConstructor, '__referenceConstructor has already been defined');\r\n    referenceConstructor = val;\r\n}\r\nfunction syncTreeGetReferenceConstructor() {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(referenceConstructor, 'Reference.ts has not been loaded');\r\n    return referenceConstructor;\r\n}\r\n/**\r\n * Static tracker for next query tag.\r\n */\r\nlet syncTreeNextQueryTag_ = 1;\r\n/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n */\r\nclass SyncTree {\r\n    /**\r\n     * @param listenProvider_ - Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */\r\n    constructor(listenProvider_) {\r\n        this.listenProvider_ = listenProvider_;\r\n        /**\r\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n         */\r\n        this.syncPointTree_ = new ImmutableTree(null);\r\n        /**\r\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n         */\r\n        this.pendingWriteTree_ = newWriteTree();\r\n        this.tagToQueryMap = new Map();\r\n        this.queryToTagMap = new Map();\r\n    }\r\n}\r\n/**\r\n * Apply the data changes for a user-generated set() or transaction() call.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {\r\n    // Record pending write.\r\n    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);\r\n    if (!visible) {\r\n        return [];\r\n    }\r\n    else {\r\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));\r\n    }\r\n}\r\n/**\r\n * Apply the data from a user-generated update() call\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {\r\n    // Record pending merge.\r\n    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);\r\n    const changeTree = ImmutableTree.fromObject(changedChildren);\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));\r\n}\r\n/**\r\n * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n *\r\n * @param revert - True if the given write failed and needs to be reverted\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeAckUserWrite(syncTree, writeId, revert = false) {\r\n    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);\r\n    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);\r\n    if (!needToReevaluate) {\r\n        return [];\r\n    }\r\n    else {\r\n        let affectedTree = new ImmutableTree(null);\r\n        if (write.snap != null) {\r\n            // overwrite\r\n            affectedTree = affectedTree.set(newEmptyPath(), true);\r\n        }\r\n        else {\r\n            each(write.children, (pathString) => {\r\n                affectedTree = affectedTree.set(new Path(pathString), true);\r\n            });\r\n        }\r\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));\r\n    }\r\n}\r\n/**\r\n * Apply new server data for the specified path..\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyServerOverwrite(syncTree, path, newData) {\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));\r\n}\r\n/**\r\n * Apply new server data to be merged in at the specified path.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyServerMerge(syncTree, path, changedChildren) {\r\n    const changeTree = ImmutableTree.fromObject(changedChildren);\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));\r\n}\r\n/**\r\n * Apply a listen complete for a query\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyListenComplete(syncTree, path) {\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));\r\n}\r\n/**\r\n * Apply a listen complete for a tagged query\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyTaggedListenComplete(syncTree, path, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // We've already removed the query. No big deal, ignore the update\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Remove event callback(s).\r\n *\r\n * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n *\r\n * @param eventRegistration - If null, all callbacks are removed.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no\r\n *  deduping needs to take place. This flag allows toggling of that behavior\r\n * @returns Cancel events, if cancelError was provided.\r\n */\r\nfunction syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) {\r\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\r\n    const path = query._path;\r\n    const maybeSyncPoint = syncTree.syncPointTree_.get(path);\r\n    let cancelEvents = [];\r\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\r\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\r\n    // not loadsAllData().\r\n    if (maybeSyncPoint &&\r\n        (query._queryIdentifier === 'default' ||\r\n            syncPointViewExistsForQuery(maybeSyncPoint, query))) {\r\n        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);\r\n        if (syncPointIsEmpty(maybeSyncPoint)) {\r\n            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);\r\n        }\r\n        const removed = removedAndEvents.removed;\r\n        cancelEvents = removedAndEvents.events;\r\n        if (!skipListenerDedup) {\r\n            /**\r\n             * We may have just removed one of many listeners and can short-circuit this whole process\r\n             * We may also not have removed a default listener, in which case all of the descendant listeners should already be\r\n             * properly set up.\r\n             */\r\n            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\r\n            // queryId === 'default'\r\n            const removingDefault = -1 !==\r\n                removed.findIndex(query => {\r\n                    return query._queryParams.loadsAllData();\r\n                });\r\n            const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint) => syncPointHasCompleteView(parentSyncPoint));\r\n            if (removingDefault && !covered) {\r\n                const subtree = syncTree.syncPointTree_.subtree(path);\r\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\r\n                // removal\r\n                if (!subtree.isEmpty()) {\r\n                    // We need to fold over our subtree and collect the listeners to send\r\n                    const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);\r\n                    // Ok, we've collected all the listens we need. Set them up.\r\n                    for (let i = 0; i < newViews.length; ++i) {\r\n                        const view = newViews[i], newQuery = view.query;\r\n                        const listener = syncTreeCreateListenerForView_(syncTree, view);\r\n                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);\r\n                    }\r\n                }\r\n                // Otherwise there's nothing below us, so nothing we need to start listening on\r\n            }\r\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\r\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\r\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\r\n            if (!covered && removed.length > 0 && !cancelError) {\r\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\r\n                // default. Otherwise, we need to iterate through and cancel each individual query\r\n                if (removingDefault) {\r\n                    // We don't tag default listeners\r\n                    const defaultTag = null;\r\n                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);\r\n                }\r\n                else {\r\n                    removed.forEach((queryToRemove) => {\r\n                        const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));\r\n                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        // Now, clear all of the tags we're tracking for the removed listens\r\n        syncTreeRemoveTags_(syncTree, removed);\r\n    }\r\n    return cancelEvents;\r\n}\r\n/**\r\n * Apply new server data for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey != null) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // Query must have been removed already\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Apply server data to be merged in for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const changeTree = ImmutableTree.fromObject(changedChildren);\r\n        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // We've already removed the query. No big deal, ignore the update\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener = false) {\r\n    const path = query._path;\r\n    let serverCache = null;\r\n    let foundAncestorDefaultView = false;\r\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\r\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\r\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {\r\n        const relativePath = newRelativePath(pathToSyncPoint, path);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(sp, relativePath);\r\n        foundAncestorDefaultView =\r\n            foundAncestorDefaultView || syncPointHasCompleteView(sp);\r\n    });\r\n    let syncPoint = syncTree.syncPointTree_.get(path);\r\n    if (!syncPoint) {\r\n        syncPoint = new SyncPoint();\r\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\r\n    }\r\n    else {\r\n        foundAncestorDefaultView =\r\n            foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    let serverCacheComplete;\r\n    if (serverCache != null) {\r\n        serverCacheComplete = true;\r\n    }\r\n    else {\r\n        serverCacheComplete = false;\r\n        serverCache = ChildrenNode.EMPTY_NODE;\r\n        const subtree = syncTree.syncPointTree_.subtree(path);\r\n        subtree.foreachChild((childName, childSyncPoint) => {\r\n            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());\r\n            if (completeCache) {\r\n                serverCache = serverCache.updateImmediateChild(childName, completeCache);\r\n            }\r\n        });\r\n    }\r\n    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);\r\n    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {\r\n        // We need to track a tag for this query\r\n        const queryKey = syncTreeMakeQueryKey_(query);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!syncTree.queryToTagMap.has(queryKey), 'View does not exist, but we have a tag');\r\n        const tag = syncTreeGetNextQueryTag_();\r\n        syncTree.queryToTagMap.set(queryKey, tag);\r\n        syncTree.tagToQueryMap.set(tag, queryKey);\r\n    }\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);\r\n    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);\r\n    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {\r\n        const view = syncPointViewForQuery(syncPoint, query);\r\n        events = events.concat(syncTreeSetupListener_(syncTree, query, view));\r\n    }\r\n    return events;\r\n}\r\n/**\r\n * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n *\r\n * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n *\r\n * @param path - The path to the data we want\r\n * @param writeIdsToExclude - A specific set to be excluded\r\n */\r\nfunction syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {\r\n    const includeHiddenSets = true;\r\n    const writeTree = syncTree.pendingWriteTree_;\r\n    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint) => {\r\n        const relativePath = newRelativePath(pathSoFar, path);\r\n        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);\r\n        if (serverCache) {\r\n            return serverCache;\r\n        }\r\n    });\r\n    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);\r\n}\r\nfunction syncTreeGetServerValue(syncTree, query) {\r\n    const path = query._path;\r\n    let serverCache = null;\r\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\r\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\r\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {\r\n        const relativePath = newRelativePath(pathToSyncPoint, path);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(sp, relativePath);\r\n    });\r\n    let syncPoint = syncTree.syncPointTree_.get(path);\r\n    if (!syncPoint) {\r\n        syncPoint = new SyncPoint();\r\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\r\n    }\r\n    else {\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    const serverCacheComplete = serverCache != null;\r\n    const serverCacheNode = serverCacheComplete\r\n        ? new CacheNode(serverCache, true, false)\r\n        : null;\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);\r\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);\r\n    return viewGetCompleteNode(view);\r\n}\r\n/**\r\n * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\r\n *\r\n * NOTES:\r\n * - Descendant SyncPoints will be visited first (since we raise events depth-first).\r\n *\r\n * - We call applyOperation() on each SyncPoint passing three things:\r\n *   1. A version of the Operation that has been made relative to the SyncPoint location.\r\n *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\r\n *   3. A snapshot Node with cached server data, if we have it.\r\n *\r\n * - We concatenate all of the events returned by each SyncPoint and return the result.\r\n */\r\nfunction syncTreeApplyOperationToSyncPoints_(syncTree, operation) {\r\n    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, \r\n    /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));\r\n}\r\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */\r\nfunction syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {\r\n    if (pathIsEmpty(operation.path)) {\r\n        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\r\n    }\r\n    else {\r\n        const syncPoint = syncPointTree.get(newEmptyPath());\r\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\r\n        if (serverCache == null && syncPoint != null) {\r\n            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n        }\r\n        let events = [];\r\n        const childName = pathGetFront(operation.path);\r\n        const childOperation = operation.operationForChild(childName);\r\n        const childTree = syncPointTree.children.get(childName);\r\n        if (childTree && childOperation) {\r\n            const childServerCache = serverCache\r\n                ? serverCache.getImmediateChild(childName)\r\n                : null;\r\n            const childWritesCache = writeTreeRefChild(writesCache, childName);\r\n            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\r\n        }\r\n        if (syncPoint) {\r\n            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\r\n        }\r\n        return events;\r\n    }\r\n}\r\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */\r\nfunction syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {\r\n    const syncPoint = syncPointTree.get(newEmptyPath());\r\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\r\n    if (serverCache == null && syncPoint != null) {\r\n        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    let events = [];\r\n    syncPointTree.children.inorderTraversal((childName, childTree) => {\r\n        const childServerCache = serverCache\r\n            ? serverCache.getImmediateChild(childName)\r\n            : null;\r\n        const childWritesCache = writeTreeRefChild(writesCache, childName);\r\n        const childOperation = operation.operationForChild(childName);\r\n        if (childOperation) {\r\n            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\r\n        }\r\n    });\r\n    if (syncPoint) {\r\n        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\r\n    }\r\n    return events;\r\n}\r\nfunction syncTreeCreateListenerForView_(syncTree, view) {\r\n    const query = view.query;\r\n    const tag = syncTreeTagForQuery(syncTree, query);\r\n    return {\r\n        hashFn: () => {\r\n            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;\r\n            return cache.hash();\r\n        },\r\n        onComplete: (status) => {\r\n            if (status === 'ok') {\r\n                if (tag) {\r\n                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);\r\n                }\r\n                else {\r\n                    return syncTreeApplyListenComplete(syncTree, query._path);\r\n                }\r\n            }\r\n            else {\r\n                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\r\n                // Note that this may need to be scoped to just this listener if we change permissions on filtered children\r\n                const error = errorForServerCode(status, query);\r\n                return syncTreeRemoveEventRegistration(syncTree, query, \r\n                /*eventRegistration*/ null, error);\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * Return the tag associated with the given query.\r\n */\r\nfunction syncTreeTagForQuery(syncTree, query) {\r\n    const queryKey = syncTreeMakeQueryKey_(query);\r\n    return syncTree.queryToTagMap.get(queryKey);\r\n}\r\n/**\r\n * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\r\n */\r\nfunction syncTreeMakeQueryKey_(query) {\r\n    return query._path.toString() + '$' + query._queryIdentifier;\r\n}\r\n/**\r\n * Return the query associated with the given tag, if we have one\r\n */\r\nfunction syncTreeQueryKeyForTag_(syncTree, tag) {\r\n    return syncTree.tagToQueryMap.get(tag);\r\n}\r\n/**\r\n * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\r\n */\r\nfunction syncTreeParseQueryKey_(queryKey) {\r\n    const splitIndex = queryKey.indexOf('$');\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');\r\n    return {\r\n        queryId: queryKey.substr(splitIndex + 1),\r\n        path: new Path(queryKey.substr(0, splitIndex))\r\n    };\r\n}\r\n/**\r\n * A helper method to apply tagged operations\r\n */\r\nfunction syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {\r\n    const syncPoint = syncTree.syncPointTree_.get(queryPath);\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(syncPoint, \"Missing sync point for query tag that we're tracking\");\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);\r\n    return syncPointApplyOperation(syncPoint, operation, writesCache, null);\r\n}\r\n/**\r\n * This collapses multiple unfiltered views into a single view, since we only need a single\r\n * listener for them.\r\n */\r\nfunction syncTreeCollectDistinctViewsForSubTree_(subtree) {\r\n    return subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {\r\n        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\r\n            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);\r\n            return [completeView];\r\n        }\r\n        else {\r\n            // No complete view here, flatten any deeper listens into an array\r\n            let views = [];\r\n            if (maybeChildSyncPoint) {\r\n                views = syncPointGetQueryViews(maybeChildSyncPoint);\r\n            }\r\n            each(childMap, (_key, childViews) => {\r\n                views = views.concat(childViews);\r\n            });\r\n            return views;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Normalizes a query to a query we send the server for listening\r\n *\r\n * @returns The normalized query\r\n */\r\nfunction syncTreeQueryForListening_(query) {\r\n    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {\r\n        // We treat queries that load all data as default queries\r\n        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\r\n        // from Query\r\n        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);\r\n    }\r\n    else {\r\n        return query;\r\n    }\r\n}\r\nfunction syncTreeRemoveTags_(syncTree, queries) {\r\n    for (let j = 0; j < queries.length; ++j) {\r\n        const removedQuery = queries[j];\r\n        if (!removedQuery._queryParams.loadsAllData()) {\r\n            // We should have a tag for this\r\n            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);\r\n            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);\r\n            syncTree.queryToTagMap.delete(removedQueryKey);\r\n            syncTree.tagToQueryMap.delete(removedQueryTag);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Static accessor for query tags.\r\n */\r\nfunction syncTreeGetNextQueryTag_() {\r\n    return syncTreeNextQueryTag_++;\r\n}\r\n/**\r\n * For a given new listen, manage the de-duplication of outstanding subscriptions.\r\n *\r\n * @returns This method can return events to support synchronous data sources\r\n */\r\nfunction syncTreeSetupListener_(syncTree, query, view) {\r\n    const path = query._path;\r\n    const tag = syncTreeTagForQuery(syncTree, query);\r\n    const listener = syncTreeCreateListenerForView_(syncTree, view);\r\n    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);\r\n    const subtree = syncTree.syncPointTree_.subtree(path);\r\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\r\n    // may need to shadow other listens as well.\r\n    if (tag) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!syncPointHasCompleteView(subtree.value), \"If we're adding a query, it shouldn't be shadowed\");\r\n    }\r\n    else {\r\n        // Shadow everything at or below this location, this is a default listener.\r\n        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {\r\n            if (!pathIsEmpty(relativePath) &&\r\n                maybeChildSyncPoint &&\r\n                syncPointHasCompleteView(maybeChildSyncPoint)) {\r\n                return [syncPointGetCompleteView(maybeChildSyncPoint).query];\r\n            }\r\n            else {\r\n                // No default listener here, flatten any deeper queries into an array\r\n                let queries = [];\r\n                if (maybeChildSyncPoint) {\r\n                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view => view.query));\r\n                }\r\n                each(childMap, (_key, childQueries) => {\r\n                    queries = queries.concat(childQueries);\r\n                });\r\n                return queries;\r\n            }\r\n        });\r\n        for (let i = 0; i < queriesToStop.length; ++i) {\r\n            const queryToStop = queriesToStop[i];\r\n            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));\r\n        }\r\n    }\r\n    return events;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ExistingValueProvider {\r\n    constructor(node_) {\r\n        this.node_ = node_;\r\n    }\r\n    getImmediateChild(childName) {\r\n        const child = this.node_.getImmediateChild(childName);\r\n        return new ExistingValueProvider(child);\r\n    }\r\n    node() {\r\n        return this.node_;\r\n    }\r\n}\r\nclass DeferredValueProvider {\r\n    constructor(syncTree, path) {\r\n        this.syncTree_ = syncTree;\r\n        this.path_ = path;\r\n    }\r\n    getImmediateChild(childName) {\r\n        const childPath = pathChild(this.path_, childName);\r\n        return new DeferredValueProvider(this.syncTree_, childPath);\r\n    }\r\n    node() {\r\n        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);\r\n    }\r\n}\r\n/**\r\n * Generate placeholders for deferred values.\r\n */\r\nconst generateWithValues = function (values) {\r\n    values = values || {};\r\n    values['timestamp'] = values['timestamp'] || new Date().getTime();\r\n    return values;\r\n};\r\n/**\r\n * Value to use when firing local events. When writing server values, fire\r\n * local events with an approximate value, otherwise return value as-is.\r\n */\r\nconst resolveDeferredLeafValue = function (value, existingVal, serverValues) {\r\n    if (!value || typeof value !== 'object') {\r\n        return value;\r\n    }\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)('.sv' in value, 'Unexpected leaf node or priority contents');\r\n    if (typeof value['.sv'] === 'string') {\r\n        return resolveScalarDeferredValue(value['.sv'], existingVal, serverValues);\r\n    }\r\n    else if (typeof value['.sv'] === 'object') {\r\n        return resolveComplexDeferredValue(value['.sv'], existingVal);\r\n    }\r\n    else {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + JSON.stringify(value, null, 2));\r\n    }\r\n};\r\nconst resolveScalarDeferredValue = function (op, existing, serverValues) {\r\n    switch (op) {\r\n        case 'timestamp':\r\n            return serverValues['timestamp'];\r\n        default:\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + op);\r\n    }\r\n};\r\nconst resolveComplexDeferredValue = function (op, existing, unused) {\r\n    if (!op.hasOwnProperty('increment')) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + JSON.stringify(op, null, 2));\r\n    }\r\n    const delta = op['increment'];\r\n    if (typeof delta !== 'number') {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected increment value: ' + delta);\r\n    }\r\n    const existingNode = existing.node();\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(existingNode !== null && typeof existingNode !== 'undefined', 'Expected ChildrenNode.EMPTY_NODE for nulls');\r\n    // Incrementing a non-number sets the value to the incremented amount\r\n    if (!existingNode.isLeafNode()) {\r\n        return delta;\r\n    }\r\n    const leaf = existingNode;\r\n    const existingVal = leaf.getValue();\r\n    if (typeof existingVal !== 'number') {\r\n        return delta;\r\n    }\r\n    // No need to do over/underflow arithmetic here because JS only handles floats under the covers\r\n    return existingVal + delta;\r\n};\r\n/**\r\n * Recursively replace all deferred values and priorities in the tree with the\r\n * specified generated replacement values.\r\n * @param path - path to which write is relative\r\n * @param node - new data written at path\r\n * @param syncTree - current data\r\n */\r\nconst resolveDeferredValueTree = function (path, node, syncTree, serverValues) {\r\n    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);\r\n};\r\n/**\r\n * Recursively replace all deferred values and priorities in the node with the\r\n * specified generated replacement values.  If there are no server values in the node,\r\n * it'll be returned as-is.\r\n */\r\nconst resolveDeferredValueSnapshot = function (node, existing, serverValues) {\r\n    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);\r\n};\r\nfunction resolveDeferredValue(node, existingVal, serverValues) {\r\n    const rawPri = node.getPriority().val();\r\n    const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild('.priority'), serverValues);\r\n    let newNode;\r\n    if (node.isLeafNode()) {\r\n        const leafNode = node;\r\n        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);\r\n        if (value !== leafNode.getValue() ||\r\n            priority !== leafNode.getPriority().val()) {\r\n            return new LeafNode(value, nodeFromJSON(priority));\r\n        }\r\n        else {\r\n            return node;\r\n        }\r\n    }\r\n    else {\r\n        const childrenNode = node;\r\n        newNode = childrenNode;\r\n        if (priority !== childrenNode.getPriority().val()) {\r\n            newNode = newNode.updatePriority(new LeafNode(priority));\r\n        }\r\n        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode) => {\r\n            const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);\r\n            if (newChildNode !== childNode) {\r\n                newNode = newNode.updateImmediateChild(childName, newChildNode);\r\n            }\r\n        });\r\n        return newNode;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */\r\nclass Tree {\r\n    /**\r\n     * @param name - Optional name of the node.\r\n     * @param parent - Optional parent node.\r\n     * @param node - Optional node to wrap.\r\n     */\r\n    constructor(name = '', parent = null, node = { children: {}, childCount: 0 }) {\r\n        this.name = name;\r\n        this.parent = parent;\r\n        this.node = node;\r\n    }\r\n}\r\n/**\r\n * Returns a sub-Tree for the given path.\r\n *\r\n * @param pathObj - Path to look up.\r\n * @returns Tree for path.\r\n */\r\nfunction treeSubTree(tree, pathObj) {\r\n    // TODO: Require pathObj to be Path?\r\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\r\n    let child = tree, next = pathGetFront(path);\r\n    while (next !== null) {\r\n        const childNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(child.node.children, next) || {\r\n            children: {},\r\n            childCount: 0\r\n        };\r\n        child = new Tree(next, child, childNode);\r\n        path = pathPopFront(path);\r\n        next = pathGetFront(path);\r\n    }\r\n    return child;\r\n}\r\n/**\r\n * Returns the data associated with this tree node.\r\n *\r\n * @returns The data or null if no data exists.\r\n */\r\nfunction treeGetValue(tree) {\r\n    return tree.node.value;\r\n}\r\n/**\r\n * Sets data to this tree node.\r\n *\r\n * @param value - Value to set.\r\n */\r\nfunction treeSetValue(tree, value) {\r\n    tree.node.value = value;\r\n    treeUpdateParents(tree);\r\n}\r\n/**\r\n * @returns Whether the tree has any children.\r\n */\r\nfunction treeHasChildren(tree) {\r\n    return tree.node.childCount > 0;\r\n}\r\n/**\r\n * @returns Whethe rthe tree is empty (no value or children).\r\n */\r\nfunction treeIsEmpty(tree) {\r\n    return treeGetValue(tree) === undefined && !treeHasChildren(tree);\r\n}\r\n/**\r\n * Calls action for each child of this tree node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */\r\nfunction treeForEachChild(tree, action) {\r\n    each(tree.node.children, (child, childTree) => {\r\n        action(new Tree(child, tree, childTree));\r\n    });\r\n}\r\n/**\r\n * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n *\r\n * @param action - Action to be called for each child.\r\n * @param includeSelf - Whether to call action on this node as well. Defaults to\r\n *   false.\r\n * @param childrenFirst - Whether to call action on children before calling it on\r\n *   parent.\r\n */\r\nfunction treeForEachDescendant(tree, action, includeSelf, childrenFirst) {\r\n    if (includeSelf && !childrenFirst) {\r\n        action(tree);\r\n    }\r\n    treeForEachChild(tree, child => {\r\n        treeForEachDescendant(child, action, true, childrenFirst);\r\n    });\r\n    if (includeSelf && childrenFirst) {\r\n        action(tree);\r\n    }\r\n}\r\n/**\r\n * Calls action on each ancestor node.\r\n *\r\n * @param action - Action to be called on each parent; return\r\n *   true to abort.\r\n * @param includeSelf - Whether to call action on this node as well.\r\n * @returns true if the action callback returned true.\r\n */\r\nfunction treeForEachAncestor(tree, action, includeSelf) {\r\n    let node = includeSelf ? tree : tree.parent;\r\n    while (node !== null) {\r\n        if (action(node)) {\r\n            return true;\r\n        }\r\n        node = node.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * @returns The path of this tree node, as a Path.\r\n */\r\nfunction treeGetPath(tree) {\r\n    return new Path(tree.parent === null\r\n        ? tree.name\r\n        : treeGetPath(tree.parent) + '/' + tree.name);\r\n}\r\n/**\r\n * Adds or removes this child from its parent based on whether it's empty or not.\r\n */\r\nfunction treeUpdateParents(tree) {\r\n    if (tree.parent !== null) {\r\n        treeUpdateChild(tree.parent, tree.name, tree);\r\n    }\r\n}\r\n/**\r\n * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n *\r\n * @param childName - The name of the child to update.\r\n * @param child - The child to update.\r\n */\r\nfunction treeUpdateChild(tree, childName, child) {\r\n    const childEmpty = treeIsEmpty(child);\r\n    const childExists = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(tree.node.children, childName);\r\n    if (childEmpty && childExists) {\r\n        delete tree.node.children[childName];\r\n        tree.node.childCount--;\r\n        treeUpdateParents(tree);\r\n    }\r\n    else if (!childEmpty && !childExists) {\r\n        tree.node.children[childName] = child.node;\r\n        tree.node.childCount++;\r\n        treeUpdateParents(tree);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * True for invalid Firebase keys\r\n */\r\nconst INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\r\n/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n */\r\nconst INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\r\n/**\r\n * Maximum number of characters to allow in leaf value\r\n */\r\nconst MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\r\nconst isValidKey = function (key) {\r\n    return (typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key));\r\n};\r\nconst isValidPathString = function (pathString) {\r\n    return (typeof pathString === 'string' &&\r\n        pathString.length !== 0 &&\r\n        !INVALID_PATH_REGEX_.test(pathString));\r\n};\r\nconst isValidRootPathString = function (pathString) {\r\n    if (pathString) {\r\n        // Allow '/.info/' at the beginning.\r\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\r\n    }\r\n    return isValidPathString(pathString);\r\n};\r\nconst isValidPriority = function (priority) {\r\n    return (priority === null ||\r\n        typeof priority === 'string' ||\r\n        (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||\r\n        (priority &&\r\n            typeof priority === 'object' &&\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(priority, '.sv')));\r\n};\r\n/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n */\r\nconst validateFirebaseDataArg = function (fnName, value, path, optional) {\r\n    if (optional && value === undefined) {\r\n        return;\r\n    }\r\n    validateFirebaseData((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'value'), value, path);\r\n};\r\n/**\r\n * Validate a data object client-side before sending to server.\r\n */\r\nconst validateFirebaseData = function (errorPrefix, data, path_) {\r\n    const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\r\n    if (data === undefined) {\r\n        throw new Error(errorPrefix + 'contains undefined ' + validationPathToErrorString(path));\r\n    }\r\n    if (typeof data === 'function') {\r\n        throw new Error(errorPrefix +\r\n            'contains a function ' +\r\n            validationPathToErrorString(path) +\r\n            ' with contents = ' +\r\n            data.toString());\r\n    }\r\n    if (isInvalidJSONNumber(data)) {\r\n        throw new Error(errorPrefix +\r\n            'contains ' +\r\n            data.toString() +\r\n            ' ' +\r\n            validationPathToErrorString(path));\r\n    }\r\n    // Check max leaf size, but try to avoid the utf8 conversion if we can.\r\n    if (typeof data === 'string' &&\r\n        data.length > MAX_LEAF_SIZE_ / 3 &&\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(data) > MAX_LEAF_SIZE_) {\r\n        throw new Error(errorPrefix +\r\n            'contains a string greater than ' +\r\n            MAX_LEAF_SIZE_ +\r\n            ' utf8 bytes ' +\r\n            validationPathToErrorString(path) +\r\n            \" ('\" +\r\n            data.substring(0, 50) +\r\n            \"...')\");\r\n    }\r\n    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\r\n    // to save extra walking of large objects.\r\n    if (data && typeof data === 'object') {\r\n        let hasDotValue = false;\r\n        let hasActualChild = false;\r\n        each(data, (key, value) => {\r\n            if (key === '.value') {\r\n                hasDotValue = true;\r\n            }\r\n            else if (key !== '.priority' && key !== '.sv') {\r\n                hasActualChild = true;\r\n                if (!isValidKey(key)) {\r\n                    throw new Error(errorPrefix +\r\n                        ' contains an invalid key (' +\r\n                        key +\r\n                        ') ' +\r\n                        validationPathToErrorString(path) +\r\n                        '.  Keys must be non-empty strings ' +\r\n                        'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\r\n                }\r\n            }\r\n            validationPathPush(path, key);\r\n            validateFirebaseData(errorPrefix, value, path);\r\n            validationPathPop(path);\r\n        });\r\n        if (hasDotValue && hasActualChild) {\r\n            throw new Error(errorPrefix +\r\n                ' contains \".value\" child ' +\r\n                validationPathToErrorString(path) +\r\n                ' in addition to actual children.');\r\n        }\r\n    }\r\n};\r\n/**\r\n * Pre-validate paths passed in the firebase function.\r\n */\r\nconst validateFirebaseMergePaths = function (errorPrefix, mergePaths) {\r\n    let i, curPath;\r\n    for (i = 0; i < mergePaths.length; i++) {\r\n        curPath = mergePaths[i];\r\n        const keys = pathSlice(curPath);\r\n        for (let j = 0; j < keys.length; j++) {\r\n            if (keys[j] === '.priority' && j === keys.length - 1) ;\r\n            else if (!isValidKey(keys[j])) {\r\n                throw new Error(errorPrefix +\r\n                    'contains an invalid key (' +\r\n                    keys[j] +\r\n                    ') in path ' +\r\n                    curPath.toString() +\r\n                    '. Keys must be non-empty strings ' +\r\n                    'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\r\n            }\r\n        }\r\n    }\r\n    // Check that update keys are not descendants of each other.\r\n    // We rely on the property that sorting guarantees that ancestors come\r\n    // right before descendants.\r\n    mergePaths.sort(pathCompare);\r\n    let prevPath = null;\r\n    for (i = 0; i < mergePaths.length; i++) {\r\n        curPath = mergePaths[i];\r\n        if (prevPath !== null && pathContains(prevPath, curPath)) {\r\n            throw new Error(errorPrefix +\r\n                'contains a path ' +\r\n                prevPath.toString() +\r\n                ' that is ancestor of another path ' +\r\n                curPath.toString());\r\n        }\r\n        prevPath = curPath;\r\n    }\r\n};\r\n/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n */\r\nconst validateFirebaseMergeDataArg = function (fnName, data, path, optional) {\r\n    if (optional && data === undefined) {\r\n        return;\r\n    }\r\n    const errorPrefix$1 = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'values');\r\n    if (!(data && typeof data === 'object') || Array.isArray(data)) {\r\n        throw new Error(errorPrefix$1 + ' must be an object containing the children to replace.');\r\n    }\r\n    const mergePaths = [];\r\n    each(data, (key, value) => {\r\n        const curPath = new Path(key);\r\n        validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));\r\n        if (pathGetBack(curPath) === '.priority') {\r\n            if (!isValidPriority(value)) {\r\n                throw new Error(errorPrefix$1 +\r\n                    \"contains an invalid value for '\" +\r\n                    curPath.toString() +\r\n                    \"', which must be a valid \" +\r\n                    'Firebase priority (a string, finite number, server value, or null).');\r\n            }\r\n        }\r\n        mergePaths.push(curPath);\r\n    });\r\n    validateFirebaseMergePaths(errorPrefix$1, mergePaths);\r\n};\r\nconst validatePriority = function (fnName, priority, optional) {\r\n    if (optional && priority === undefined) {\r\n        return;\r\n    }\r\n    if (isInvalidJSONNumber(priority)) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'priority') +\r\n            'is ' +\r\n            priority.toString() +\r\n            ', but must be a valid Firebase priority (a string, finite number, ' +\r\n            'server value, or null).');\r\n    }\r\n    // Special case to allow importing data with a .sv.\r\n    if (!isValidPriority(priority)) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'priority') +\r\n            'must be a valid Firebase priority ' +\r\n            '(a string, finite number, server value, or null).');\r\n    }\r\n};\r\nconst validateKey = function (fnName, argumentName, key, optional) {\r\n    if (optional && key === undefined) {\r\n        return;\r\n    }\r\n    if (!isValidKey(key)) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentName) +\r\n            'was an invalid key = \"' +\r\n            key +\r\n            '\".  Firebase keys must be non-empty strings and ' +\r\n            'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\r\n    }\r\n};\r\n/**\r\n * @internal\r\n */\r\nconst validatePathString = function (fnName, argumentName, pathString, optional) {\r\n    if (optional && pathString === undefined) {\r\n        return;\r\n    }\r\n    if (!isValidPathString(pathString)) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentName) +\r\n            'was an invalid path = \"' +\r\n            pathString +\r\n            '\". Paths must be non-empty strings and ' +\r\n            'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\r\n    }\r\n};\r\nconst validateRootPathString = function (fnName, argumentName, pathString, optional) {\r\n    if (pathString) {\r\n        // Allow '/.info/' at the beginning.\r\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\r\n    }\r\n    validatePathString(fnName, argumentName, pathString, optional);\r\n};\r\n/**\r\n * @internal\r\n */\r\nconst validateWritablePath = function (fnName, path) {\r\n    if (pathGetFront(path) === '.info') {\r\n        throw new Error(fnName + \" failed = Can't modify data under /.info/\");\r\n    }\r\n};\r\nconst validateUrl = function (fnName, parsedUrl) {\r\n    // TODO = Validate server better.\r\n    const pathString = parsedUrl.path.toString();\r\n    if (!(typeof parsedUrl.repoInfo.host === 'string') ||\r\n        parsedUrl.repoInfo.host.length === 0 ||\r\n        (!isValidKey(parsedUrl.repoInfo.namespace) &&\r\n            parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||\r\n        (pathString.length !== 0 && !isValidRootPathString(pathString))) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 'url') +\r\n            'must be a valid firebase URL and ' +\r\n            'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\r\n    }\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The event queue serves a few purposes:\r\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\r\n *    events being queued.\r\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\r\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\r\n *    left off, ensuring that the events are still raised synchronously and in order.\r\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\r\n *    events are raised synchronously.\r\n *\r\n * NOTE: This can all go away if/when we move to async events.\r\n *\r\n */\r\nclass EventQueue {\r\n    constructor() {\r\n        this.eventLists_ = [];\r\n        /**\r\n         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\r\n         */\r\n        this.recursionDepth_ = 0;\r\n    }\r\n}\r\n/**\r\n * @param eventDataList - The new events to queue.\r\n */\r\nfunction eventQueueQueueEvents(eventQueue, eventDataList) {\r\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\r\n    let currList = null;\r\n    for (let i = 0; i < eventDataList.length; i++) {\r\n        const data = eventDataList[i];\r\n        const path = data.getPath();\r\n        if (currList !== null && !pathEquals(path, currList.path)) {\r\n            eventQueue.eventLists_.push(currList);\r\n            currList = null;\r\n        }\r\n        if (currList === null) {\r\n            currList = { events: [], path };\r\n        }\r\n        currList.events.push(data);\r\n    }\r\n    if (currList) {\r\n        eventQueue.eventLists_.push(currList);\r\n    }\r\n}\r\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones)\r\n * for the specified path.\r\n *\r\n * It is assumed that the new events are all for the specified path.\r\n *\r\n * @param path - The path to raise events for.\r\n * @param eventDataList - The new events to raise.\r\n */\r\nfunction eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {\r\n    eventQueueQueueEvents(eventQueue, eventDataList);\r\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathEquals(eventPath, path));\r\n}\r\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones) for\r\n * locations related to the specified change path (i.e. all ancestors and descendants).\r\n *\r\n * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\r\n *\r\n * @param changedPath - The path to raise events for.\r\n * @param eventDataList - The events to raise\r\n */\r\nfunction eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {\r\n    eventQueueQueueEvents(eventQueue, eventDataList);\r\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathContains(eventPath, changedPath) ||\r\n        pathContains(changedPath, eventPath));\r\n}\r\nfunction eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {\r\n    eventQueue.recursionDepth_++;\r\n    let sentAll = true;\r\n    for (let i = 0; i < eventQueue.eventLists_.length; i++) {\r\n        const eventList = eventQueue.eventLists_[i];\r\n        if (eventList) {\r\n            const eventPath = eventList.path;\r\n            if (predicate(eventPath)) {\r\n                eventListRaise(eventQueue.eventLists_[i]);\r\n                eventQueue.eventLists_[i] = null;\r\n            }\r\n            else {\r\n                sentAll = false;\r\n            }\r\n        }\r\n    }\r\n    if (sentAll) {\r\n        eventQueue.eventLists_ = [];\r\n    }\r\n    eventQueue.recursionDepth_--;\r\n}\r\n/**\r\n * Iterates through the list and raises each event\r\n */\r\nfunction eventListRaise(eventList) {\r\n    for (let i = 0; i < eventList.events.length; i++) {\r\n        const eventData = eventList.events[i];\r\n        if (eventData !== null) {\r\n            eventList.events[i] = null;\r\n            const eventFn = eventData.getEventRunner();\r\n            if (logger) {\r\n                log('event: ' + eventData.toString());\r\n            }\r\n            exceptionGuard(eventFn);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst INTERRUPT_REASON = 'repo_interrupt';\r\n/**\r\n * If a transaction does not succeed after 25 retries, we abort it. Among other\r\n * things this ensure that if there's ever a bug causing a mismatch between\r\n * client / server hashes for some data, we won't retry indefinitely.\r\n */\r\nconst MAX_TRANSACTION_RETRIES = 25;\r\n/**\r\n * A connection to a single data repository.\r\n */\r\nclass Repo {\r\n    constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {\r\n        this.repoInfo_ = repoInfo_;\r\n        this.forceRestClient_ = forceRestClient_;\r\n        this.authTokenProvider_ = authTokenProvider_;\r\n        this.appCheckProvider_ = appCheckProvider_;\r\n        this.dataUpdateCount = 0;\r\n        this.statsListener_ = null;\r\n        this.eventQueue_ = new EventQueue();\r\n        this.nextWriteId_ = 1;\r\n        this.interceptServerDataCallback_ = null;\r\n        /** A list of data pieces and paths to be set when this client disconnects. */\r\n        this.onDisconnect_ = newSparseSnapshotTree();\r\n        /** Stores queues of outstanding transactions for Firebase locations. */\r\n        this.transactionQueueTree_ = new Tree();\r\n        // TODO: This should be @private but it's used by test_access.js and internal.js\r\n        this.persistentConnection_ = null;\r\n        // This key is intentionally not updated if RepoInfo is later changed or replaced\r\n        this.key = this.repoInfo_.toURLString();\r\n    }\r\n    /**\r\n     * @returns The URL corresponding to the root of this Firebase.\r\n     */\r\n    toString() {\r\n        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);\r\n    }\r\n}\r\nfunction repoStart(repo, appId, authOverride) {\r\n    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);\r\n    if (repo.forceRestClient_ || beingCrawled()) {\r\n        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag) => {\r\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\r\n        }, repo.authTokenProvider_, repo.appCheckProvider_);\r\n        // Minor hack: Fire onConnect immediately, since there's no actual connection.\r\n        setTimeout(() => repoOnConnectStatus(repo, /* connectStatus= */ true), 0);\r\n    }\r\n    else {\r\n        // Validate authOverride\r\n        if (typeof authOverride !== 'undefined' && authOverride !== null) {\r\n            if (typeof authOverride !== 'object') {\r\n                throw new Error('Only objects are supported for option databaseAuthVariableOverride');\r\n            }\r\n            try {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(authOverride);\r\n            }\r\n            catch (e) {\r\n                throw new Error('Invalid authOverride provided: ' + e);\r\n            }\r\n        }\r\n        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag) => {\r\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\r\n        }, (connectStatus) => {\r\n            repoOnConnectStatus(repo, connectStatus);\r\n        }, (updates) => {\r\n            repoOnServerInfoUpdate(repo, updates);\r\n        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);\r\n        repo.server_ = repo.persistentConnection_;\r\n    }\r\n    repo.authTokenProvider_.addTokenChangeListener(token => {\r\n        repo.server_.refreshAuthToken(token);\r\n    });\r\n    repo.appCheckProvider_.addTokenChangeListener(result => {\r\n        repo.server_.refreshAppCheckToken(result.token);\r\n    });\r\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\r\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\r\n    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, () => new StatsReporter(repo.stats_, repo.server_));\r\n    // Used for .info.\r\n    repo.infoData_ = new SnapshotHolder();\r\n    repo.infoSyncTree_ = new SyncTree({\r\n        startListening: (query, tag, currentHashFn, onComplete) => {\r\n            let infoEvents = [];\r\n            const node = repo.infoData_.getNode(query._path);\r\n            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\r\n            // on initial data...\r\n            if (!node.isEmpty()) {\r\n                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);\r\n                setTimeout(() => {\r\n                    onComplete('ok');\r\n                }, 0);\r\n            }\r\n            return infoEvents;\r\n        },\r\n        stopListening: () => { }\r\n    });\r\n    repoUpdateInfo(repo, 'connected', false);\r\n    repo.serverSyncTree_ = new SyncTree({\r\n        startListening: (query, tag, currentHashFn, onComplete) => {\r\n            repo.server_.listen(query, currentHashFn, tag, (status, data) => {\r\n                const events = onComplete(status, data);\r\n                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\r\n            });\r\n            // No synchronous events for network-backed sync trees\r\n            return [];\r\n        },\r\n        stopListening: (query, tag) => {\r\n            repo.server_.unlisten(query, tag);\r\n        }\r\n    });\r\n}\r\n/**\r\n * @returns The time in milliseconds, taking the server offset into account if we have one.\r\n */\r\nfunction repoServerTime(repo) {\r\n    const offsetNode = repo.infoData_.getNode(new Path('.info/serverTimeOffset'));\r\n    const offset = offsetNode.val() || 0;\r\n    return new Date().getTime() + offset;\r\n}\r\n/**\r\n * Generate ServerValues using some variables from the repo object.\r\n */\r\nfunction repoGenerateServerValues(repo) {\r\n    return generateWithValues({\r\n        timestamp: repoServerTime(repo)\r\n    });\r\n}\r\n/**\r\n * Called by realtime when we get new messages from the server.\r\n */\r\nfunction repoOnDataUpdate(repo, pathString, data, isMerge, tag) {\r\n    // For testing.\r\n    repo.dataUpdateCount++;\r\n    const path = new Path(pathString);\r\n    data = repo.interceptServerDataCallback_\r\n        ? repo.interceptServerDataCallback_(pathString, data)\r\n        : data;\r\n    let events = [];\r\n    if (tag) {\r\n        if (isMerge) {\r\n            const taggedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(data, (raw) => nodeFromJSON(raw));\r\n            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);\r\n        }\r\n        else {\r\n            const taggedSnap = nodeFromJSON(data);\r\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);\r\n        }\r\n    }\r\n    else if (isMerge) {\r\n        const changedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(data, (raw) => nodeFromJSON(raw));\r\n        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);\r\n    }\r\n    else {\r\n        const snap = nodeFromJSON(data);\r\n        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);\r\n    }\r\n    let affectedPath = path;\r\n    if (events.length > 0) {\r\n        // Since we have a listener outstanding for each transaction, receiving any events\r\n        // is a proxy for some change having occurred.\r\n        affectedPath = repoRerunTransactions(repo, path);\r\n    }\r\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);\r\n}\r\nfunction repoOnConnectStatus(repo, connectStatus) {\r\n    repoUpdateInfo(repo, 'connected', connectStatus);\r\n    if (connectStatus === false) {\r\n        repoRunOnDisconnectEvents(repo);\r\n    }\r\n}\r\nfunction repoOnServerInfoUpdate(repo, updates) {\r\n    each(updates, (key, value) => {\r\n        repoUpdateInfo(repo, key, value);\r\n    });\r\n}\r\nfunction repoUpdateInfo(repo, pathString, value) {\r\n    const path = new Path('/.info/' + pathString);\r\n    const newNode = nodeFromJSON(value);\r\n    repo.infoData_.updateSnapshot(path, newNode);\r\n    const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);\r\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\r\n}\r\nfunction repoGetNextWriteId(repo) {\r\n    return repo.nextWriteId_++;\r\n}\r\n/**\r\n * The purpose of `getValue` is to return the latest known value\r\n * satisfying `query`.\r\n *\r\n * This method will first check for in-memory cached values\r\n * belonging to active listeners. If they are found, such values\r\n * are considered to be the most up-to-date.\r\n *\r\n * If the client is not connected, this method will wait until the\r\n *  repo has established a connection and then request the value for `query`.\r\n * If the client is not able to retrieve the query result for another reason,\r\n * it reports an error.\r\n *\r\n * @param query - The query to surface a value for.\r\n */\r\nfunction repoGetValue(repo, query, eventRegistration) {\r\n    // Only active queries are cached. There is no persisted cache.\r\n    const cached = syncTreeGetServerValue(repo.serverSyncTree_, query);\r\n    if (cached != null) {\r\n        return Promise.resolve(cached);\r\n    }\r\n    return repo.server_.get(query).then(payload => {\r\n        const node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());\r\n        /**\r\n         * Below we simulate the actions of an `onlyOnce` `onValue()` event where:\r\n         * Add an event registration,\r\n         * Update data at the path,\r\n         * Raise any events,\r\n         * Cleanup the SyncTree\r\n         */\r\n        syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration, true);\r\n        let events;\r\n        if (query._queryParams.loadsAllData()) {\r\n            events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);\r\n        }\r\n        else {\r\n            const tag = syncTreeTagForQuery(repo.serverSyncTree_, query);\r\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query._path, node, tag);\r\n        }\r\n        /*\r\n         * We need to raise events in the scenario where `get()` is called at a parent path, and\r\n         * while the `get()` is pending, `onValue` is called at a child location. While get() is waiting\r\n         * for the data, `onValue` will register a new event. Then, get() will come back, and update the syncTree\r\n         * and its corresponding serverCache, including the child location where `onValue` is called. Then,\r\n         * `onValue` will receive the event from the server, but look at the syncTree and see that the data received\r\n         * from the server is already at the SyncPoint, and so the `onValue` callback will never get fired.\r\n         * Calling `eventQueueRaiseEventsForChangedPath()` is the correct way to propagate the events and\r\n         * ensure the corresponding child events will get fired.\r\n         */\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\r\n        syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration, null, true);\r\n        return node;\r\n    }, err => {\r\n        repoLog(repo, 'get for query ' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(query) + ' failed: ' + err);\r\n        return Promise.reject(new Error(err));\r\n    });\r\n}\r\nfunction repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {\r\n    repoLog(repo, 'set', {\r\n        path: path.toString(),\r\n        value: newVal,\r\n        priority: newPriority\r\n    });\r\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\r\n    // (b) store unresolved paths on JSON parse\r\n    const serverValues = repoGenerateServerValues(repo);\r\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\r\n    const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);\r\n    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);\r\n    const writeId = repoGetNextWriteId(repo);\r\n    const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);\r\n    eventQueueQueueEvents(repo.eventQueue_, events);\r\n    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), (status, errorReason) => {\r\n        const success = status === 'ok';\r\n        if (!success) {\r\n            warn('set at ' + path + ' failed: ' + status);\r\n        }\r\n        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n    const affectedPath = repoAbortTransactions(repo, path);\r\n    repoRerunTransactions(repo, affectedPath);\r\n    // We queued the events above, so just flush the queue here\r\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);\r\n}\r\nfunction repoUpdate(repo, path, childrenToMerge, onComplete) {\r\n    repoLog(repo, 'update', { path: path.toString(), value: childrenToMerge });\r\n    // Start with our existing data and merge each child into it.\r\n    let empty = true;\r\n    const serverValues = repoGenerateServerValues(repo);\r\n    const changedChildren = {};\r\n    each(childrenToMerge, (changedKey, changedValue) => {\r\n        empty = false;\r\n        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);\r\n    });\r\n    if (!empty) {\r\n        const writeId = repoGetNextWriteId(repo);\r\n        const events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId);\r\n        eventQueueQueueEvents(repo.eventQueue_, events);\r\n        repo.server_.merge(path.toString(), childrenToMerge, (status, errorReason) => {\r\n            const success = status === 'ok';\r\n            if (!success) {\r\n                warn('update at ' + path + ' failed: ' + status);\r\n            }\r\n            const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\r\n            const affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;\r\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);\r\n            repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n        });\r\n        each(childrenToMerge, (changedPath) => {\r\n            const affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));\r\n            repoRerunTransactions(repo, affectedPath);\r\n        });\r\n        // We queued the events above, so just flush the queue here\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);\r\n    }\r\n    else {\r\n        log(\"update() called with empty data.  Don't do anything.\");\r\n        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);\r\n    }\r\n}\r\n/**\r\n * Applies all of the changes stored up in the onDisconnect_ tree.\r\n */\r\nfunction repoRunOnDisconnectEvents(repo) {\r\n    repoLog(repo, 'onDisconnectEvents');\r\n    const serverValues = repoGenerateServerValues(repo);\r\n    const resolvedOnDisconnectTree = newSparseSnapshotTree();\r\n    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node) => {\r\n        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);\r\n        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);\r\n    });\r\n    let events = [];\r\n    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap) => {\r\n        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));\r\n        const affectedPath = repoAbortTransactions(repo, path);\r\n        repoRerunTransactions(repo, affectedPath);\r\n    });\r\n    repo.onDisconnect_ = newSparseSnapshotTree();\r\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);\r\n}\r\nfunction repoOnDisconnectCancel(repo, path, onComplete) {\r\n    repo.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {\r\n        if (status === 'ok') {\r\n            sparseSnapshotTreeForget(repo.onDisconnect_, path);\r\n        }\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n}\r\nfunction repoOnDisconnectSet(repo, path, value, onComplete) {\r\n    const newNode = nodeFromJSON(value);\r\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason) => {\r\n        if (status === 'ok') {\r\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\r\n        }\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n}\r\nfunction repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {\r\n    const newNode = nodeFromJSON(value, priority);\r\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason) => {\r\n        if (status === 'ok') {\r\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\r\n        }\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n}\r\nfunction repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(childrenToMerge)) {\r\n        log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\r\n        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);\r\n        return;\r\n    }\r\n    repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason) => {\r\n        if (status === 'ok') {\r\n            each(childrenToMerge, (childName, childNode) => {\r\n                const newChildNode = nodeFromJSON(childNode);\r\n                sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);\r\n            });\r\n        }\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n}\r\nfunction repoAddEventCallbackForQuery(repo, query, eventRegistration) {\r\n    let events;\r\n    if (pathGetFront(query._path) === '.info') {\r\n        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);\r\n    }\r\n    else {\r\n        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);\r\n    }\r\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\r\n}\r\nfunction repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {\r\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\r\n    // a little bit by handling the return values anyways.\r\n    let events;\r\n    if (pathGetFront(query._path) === '.info') {\r\n        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);\r\n    }\r\n    else {\r\n        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);\r\n    }\r\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\r\n}\r\nfunction repoInterrupt(repo) {\r\n    if (repo.persistentConnection_) {\r\n        repo.persistentConnection_.interrupt(INTERRUPT_REASON);\r\n    }\r\n}\r\nfunction repoResume(repo) {\r\n    if (repo.persistentConnection_) {\r\n        repo.persistentConnection_.resume(INTERRUPT_REASON);\r\n    }\r\n}\r\nfunction repoLog(repo, ...varArgs) {\r\n    let prefix = '';\r\n    if (repo.persistentConnection_) {\r\n        prefix = repo.persistentConnection_.id + ':';\r\n    }\r\n    log(prefix, ...varArgs);\r\n}\r\nfunction repoCallOnCompleteCallback(repo, callback, status, errorReason) {\r\n    if (callback) {\r\n        exceptionGuard(() => {\r\n            if (status === 'ok') {\r\n                callback(null);\r\n            }\r\n            else {\r\n                const code = (status || 'error').toUpperCase();\r\n                let message = code;\r\n                if (errorReason) {\r\n                    message += ': ' + errorReason;\r\n                }\r\n                const error = new Error(message);\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                error.code = code;\r\n                callback(error);\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Creates a new transaction, adds it to the transactions we're tracking, and\r\n * sends it to the server if possible.\r\n *\r\n * @param path - Path at which to do transaction.\r\n * @param transactionUpdate - Update callback.\r\n * @param onComplete - Completion callback.\r\n * @param unwatcher - Function that will be called when the transaction no longer\r\n * need data updates for `path`.\r\n * @param applyLocally - Whether or not to make intermediate results visible\r\n */\r\nfunction repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {\r\n    repoLog(repo, 'transaction on ' + path);\r\n    // Initialize transaction.\r\n    const transaction = {\r\n        path,\r\n        update: transactionUpdate,\r\n        onComplete,\r\n        // One of TransactionStatus enums.\r\n        status: null,\r\n        // Used when combining transactions at different locations to figure out\r\n        // which one goes first.\r\n        order: LUIDGenerator(),\r\n        // Whether to raise local events for this transaction.\r\n        applyLocally,\r\n        // Count of how many times we've retried the transaction.\r\n        retryCount: 0,\r\n        // Function to call to clean up our .on() listener.\r\n        unwatcher,\r\n        // Stores why a transaction was aborted.\r\n        abortReason: null,\r\n        currentWriteId: null,\r\n        currentInputSnapshot: null,\r\n        currentOutputSnapshotRaw: null,\r\n        currentOutputSnapshotResolved: null\r\n    };\r\n    // Run transaction initially.\r\n    const currentState = repoGetLatestState(repo, path, undefined);\r\n    transaction.currentInputSnapshot = currentState;\r\n    const newVal = transaction.update(currentState.val());\r\n    if (newVal === undefined) {\r\n        // Abort transaction.\r\n        transaction.unwatcher();\r\n        transaction.currentOutputSnapshotRaw = null;\r\n        transaction.currentOutputSnapshotResolved = null;\r\n        if (transaction.onComplete) {\r\n            transaction.onComplete(null, false, transaction.currentInputSnapshot);\r\n        }\r\n    }\r\n    else {\r\n        validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);\r\n        // Mark as run and add to our queue.\r\n        transaction.status = 0 /* TransactionStatus.RUN */;\r\n        const queueNode = treeSubTree(repo.transactionQueueTree_, path);\r\n        const nodeQueue = treeGetValue(queueNode) || [];\r\n        nodeQueue.push(transaction);\r\n        treeSetValue(queueNode, nodeQueue);\r\n        // Update visibleData and raise events\r\n        // Note: We intentionally raise events after updating all of our\r\n        // transaction state, since the user could start new transactions from the\r\n        // event callbacks.\r\n        let priorityForNode;\r\n        if (typeof newVal === 'object' &&\r\n            newVal !== null &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(newVal, '.priority')) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            priorityForNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(newVal, '.priority');\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +\r\n                'Priority must be a valid string, finite number, server value, or null.');\r\n        }\r\n        else {\r\n            const currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) ||\r\n                ChildrenNode.EMPTY_NODE;\r\n            priorityForNode = currentNode.getPriority().val();\r\n        }\r\n        const serverValues = repoGenerateServerValues(repo);\r\n        const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\r\n        const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);\r\n        transaction.currentOutputSnapshotRaw = newNodeUnresolved;\r\n        transaction.currentOutputSnapshotResolved = newNode;\r\n        transaction.currentWriteId = repoGetNextWriteId(repo);\r\n        const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\r\n        repoSendReadyTransactions(repo, repo.transactionQueueTree_);\r\n    }\r\n}\r\n/**\r\n * @param excludeSets - A specific set to exclude\r\n */\r\nfunction repoGetLatestState(repo, path, excludeSets) {\r\n    return (syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) ||\r\n        ChildrenNode.EMPTY_NODE);\r\n}\r\n/**\r\n * Sends any already-run transactions that aren't waiting for outstanding\r\n * transactions to complete.\r\n *\r\n * Externally it's called with no arguments, but it calls itself recursively\r\n * with a particular transactionQueueTree node to recurse through the tree.\r\n *\r\n * @param node - transactionQueueTree node to start at.\r\n */\r\nfunction repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {\r\n    // Before recursing, make sure any completed transactions are removed.\r\n    if (!node) {\r\n        repoPruneCompletedTransactionsBelowNode(repo, node);\r\n    }\r\n    if (treeGetValue(node)) {\r\n        const queue = repoBuildTransactionQueue(repo, node);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queue.length > 0, 'Sending zero length transaction queue');\r\n        const allRun = queue.every((transaction) => transaction.status === 0 /* TransactionStatus.RUN */);\r\n        // If they're all run (and not sent), we can send them.  Else, we must wait.\r\n        if (allRun) {\r\n            repoSendTransactionQueue(repo, treeGetPath(node), queue);\r\n        }\r\n    }\r\n    else if (treeHasChildren(node)) {\r\n        treeForEachChild(node, childNode => {\r\n            repoSendReadyTransactions(repo, childNode);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Given a list of run transactions, send them to the server and then handle\r\n * the result (success or failure).\r\n *\r\n * @param path - The location of the queue.\r\n * @param queue - Queue of transactions under the specified location.\r\n */\r\nfunction repoSendTransactionQueue(repo, path, queue) {\r\n    // Mark transactions as sent and increment retry count!\r\n    const setsToIgnore = queue.map(txn => {\r\n        return txn.currentWriteId;\r\n    });\r\n    const latestState = repoGetLatestState(repo, path, setsToIgnore);\r\n    let snapToSend = latestState;\r\n    const latestHash = latestState.hash();\r\n    for (let i = 0; i < queue.length; i++) {\r\n        const txn = queue[i];\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(txn.status === 0 /* TransactionStatus.RUN */, 'tryToSendTransactionQueue_: items in queue should all be run.');\r\n        txn.status = 1 /* TransactionStatus.SENT */;\r\n        txn.retryCount++;\r\n        const relativePath = newRelativePath(path, txn.path);\r\n        // If we've gotten to this point, the output snapshot must be defined.\r\n        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */, txn.currentOutputSnapshotRaw);\r\n    }\r\n    const dataToSend = snapToSend.val(true);\r\n    const pathToSend = path;\r\n    // Send the put.\r\n    repo.server_.put(pathToSend.toString(), dataToSend, (status) => {\r\n        repoLog(repo, 'transaction put response', {\r\n            path: pathToSend.toString(),\r\n            status\r\n        });\r\n        let events = [];\r\n        if (status === 'ok') {\r\n            // Queue up the callbacks and fire them after cleaning up all of our\r\n            // transaction state, since the callback could trigger more\r\n            // transactions or sets.\r\n            const callbacks = [];\r\n            for (let i = 0; i < queue.length; i++) {\r\n                queue[i].status = 2 /* TransactionStatus.COMPLETED */;\r\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));\r\n                if (queue[i].onComplete) {\r\n                    // We never unset the output snapshot, and given that this\r\n                    // transaction is complete, it should be set\r\n                    callbacks.push(() => queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));\r\n                }\r\n                queue[i].unwatcher();\r\n            }\r\n            // Now remove the completed transactions.\r\n            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));\r\n            // There may be pending transactions that we can now send.\r\n            repoSendReadyTransactions(repo, repo.transactionQueueTree_);\r\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\r\n            // Finally, trigger onComplete callbacks.\r\n            for (let i = 0; i < callbacks.length; i++) {\r\n                exceptionGuard(callbacks[i]);\r\n            }\r\n        }\r\n        else {\r\n            // transactions are no longer sent.  Update their status appropriately.\r\n            if (status === 'datastale') {\r\n                for (let i = 0; i < queue.length; i++) {\r\n                    if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) {\r\n                        queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;\r\n                    }\r\n                    else {\r\n                        queue[i].status = 0 /* TransactionStatus.RUN */;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);\r\n                for (let i = 0; i < queue.length; i++) {\r\n                    queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;\r\n                    queue[i].abortReason = status;\r\n                }\r\n            }\r\n            repoRerunTransactions(repo, path);\r\n        }\r\n    }, latestHash);\r\n}\r\n/**\r\n * Finds all transactions dependent on the data at changedPath and reruns them.\r\n *\r\n * Should be called any time cached data changes.\r\n *\r\n * Return the highest path that was affected by rerunning transactions. This\r\n * is the path at which events need to be raised for.\r\n *\r\n * @param changedPath - The path in mergedData that changed.\r\n * @returns The rootmost path that was affected by rerunning transactions.\r\n */\r\nfunction repoRerunTransactions(repo, changedPath) {\r\n    const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);\r\n    const path = treeGetPath(rootMostTransactionNode);\r\n    const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);\r\n    repoRerunTransactionQueue(repo, queue, path);\r\n    return path;\r\n}\r\n/**\r\n * Does all the work of rerunning transactions (as well as cleans up aborted\r\n * transactions and whatnot).\r\n *\r\n * @param queue - The queue of transactions to run.\r\n * @param path - The path the queue is for.\r\n */\r\nfunction repoRerunTransactionQueue(repo, queue, path) {\r\n    if (queue.length === 0) {\r\n        return; // Nothing to do!\r\n    }\r\n    // Queue up the callbacks and fire them after cleaning up all of our\r\n    // transaction state, since the callback could trigger more transactions or\r\n    // sets.\r\n    const callbacks = [];\r\n    let events = [];\r\n    // Ignore all of the sets we're going to re-run.\r\n    const txnsToRerun = queue.filter(q => {\r\n        return q.status === 0 /* TransactionStatus.RUN */;\r\n    });\r\n    const setsToIgnore = txnsToRerun.map(q => {\r\n        return q.currentWriteId;\r\n    });\r\n    for (let i = 0; i < queue.length; i++) {\r\n        const transaction = queue[i];\r\n        const relativePath = newRelativePath(path, transaction.path);\r\n        let abortTransaction = false, abortReason;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');\r\n        if (transaction.status === 4 /* TransactionStatus.NEEDS_ABORT */) {\r\n            abortTransaction = true;\r\n            abortReason = transaction.abortReason;\r\n            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\r\n        }\r\n        else if (transaction.status === 0 /* TransactionStatus.RUN */) {\r\n            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {\r\n                abortTransaction = true;\r\n                abortReason = 'maxretry';\r\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\r\n            }\r\n            else {\r\n                // This code reruns a transaction\r\n                const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);\r\n                transaction.currentInputSnapshot = currentNode;\r\n                const newData = queue[i].update(currentNode.val());\r\n                if (newData !== undefined) {\r\n                    validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);\r\n                    let newDataNode = nodeFromJSON(newData);\r\n                    const hasExplicitPriority = typeof newData === 'object' &&\r\n                        newData != null &&\r\n                        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(newData, '.priority');\r\n                    if (!hasExplicitPriority) {\r\n                        // Keep the old priority if there wasn't a priority explicitly specified.\r\n                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());\r\n                    }\r\n                    const oldWriteId = transaction.currentWriteId;\r\n                    const serverValues = repoGenerateServerValues(repo);\r\n                    const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);\r\n                    transaction.currentOutputSnapshotRaw = newDataNode;\r\n                    transaction.currentOutputSnapshotResolved = newNodeResolved;\r\n                    transaction.currentWriteId = repoGetNextWriteId(repo);\r\n                    // Mutates setsToIgnore in place\r\n                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\r\n                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\r\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));\r\n                }\r\n                else {\r\n                    abortTransaction = true;\r\n                    abortReason = 'nodata';\r\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\r\n                }\r\n            }\r\n        }\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\r\n        events = [];\r\n        if (abortTransaction) {\r\n            // Abort.\r\n            queue[i].status = 2 /* TransactionStatus.COMPLETED */;\r\n            // Removing a listener can trigger pruning which can muck with\r\n            // mergedData/visibleData (as it prunes data). So defer the unwatcher\r\n            // until we're done.\r\n            (function (unwatcher) {\r\n                setTimeout(unwatcher, Math.floor(0));\r\n            })(queue[i].unwatcher);\r\n            if (queue[i].onComplete) {\r\n                if (abortReason === 'nodata') {\r\n                    callbacks.push(() => queue[i].onComplete(null, false, queue[i].currentInputSnapshot));\r\n                }\r\n                else {\r\n                    callbacks.push(() => queue[i].onComplete(new Error(abortReason), false, null));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Clean up completed transactions.\r\n    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);\r\n    // Now fire callbacks, now that we're in a good, known state.\r\n    for (let i = 0; i < callbacks.length; i++) {\r\n        exceptionGuard(callbacks[i]);\r\n    }\r\n    // Try to send the transaction result to the server.\r\n    repoSendReadyTransactions(repo, repo.transactionQueueTree_);\r\n}\r\n/**\r\n * Returns the rootmost ancestor node of the specified path that has a pending\r\n * transaction on it, or just returns the node for the given path if there are\r\n * no pending transactions on any ancestor.\r\n *\r\n * @param path - The location to start at.\r\n * @returns The rootmost node with a transaction.\r\n */\r\nfunction repoGetAncestorTransactionNode(repo, path) {\r\n    let front;\r\n    // Start at the root and walk deeper into the tree towards path until we\r\n    // find a node with pending transactions.\r\n    let transactionNode = repo.transactionQueueTree_;\r\n    front = pathGetFront(path);\r\n    while (front !== null && treeGetValue(transactionNode) === undefined) {\r\n        transactionNode = treeSubTree(transactionNode, front);\r\n        path = pathPopFront(path);\r\n        front = pathGetFront(path);\r\n    }\r\n    return transactionNode;\r\n}\r\n/**\r\n * Builds the queue of all transactions at or below the specified\r\n * transactionNode.\r\n *\r\n * @param transactionNode\r\n * @returns The generated queue.\r\n */\r\nfunction repoBuildTransactionQueue(repo, transactionNode) {\r\n    // Walk any child transaction queues and aggregate them into a single queue.\r\n    const transactionQueue = [];\r\n    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);\r\n    // Sort them by the order the transactions were created.\r\n    transactionQueue.sort((a, b) => a.order - b.order);\r\n    return transactionQueue;\r\n}\r\nfunction repoAggregateTransactionQueuesForNode(repo, node, queue) {\r\n    const nodeQueue = treeGetValue(node);\r\n    if (nodeQueue) {\r\n        for (let i = 0; i < nodeQueue.length; i++) {\r\n            queue.push(nodeQueue[i]);\r\n        }\r\n    }\r\n    treeForEachChild(node, child => {\r\n        repoAggregateTransactionQueuesForNode(repo, child, queue);\r\n    });\r\n}\r\n/**\r\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\r\n */\r\nfunction repoPruneCompletedTransactionsBelowNode(repo, node) {\r\n    const queue = treeGetValue(node);\r\n    if (queue) {\r\n        let to = 0;\r\n        for (let from = 0; from < queue.length; from++) {\r\n            if (queue[from].status !== 2 /* TransactionStatus.COMPLETED */) {\r\n                queue[to] = queue[from];\r\n                to++;\r\n            }\r\n        }\r\n        queue.length = to;\r\n        treeSetValue(node, queue.length > 0 ? queue : undefined);\r\n    }\r\n    treeForEachChild(node, childNode => {\r\n        repoPruneCompletedTransactionsBelowNode(repo, childNode);\r\n    });\r\n}\r\n/**\r\n * Aborts all transactions on ancestors or descendants of the specified path.\r\n * Called when doing a set() or update() since we consider them incompatible\r\n * with transactions.\r\n *\r\n * @param path - Path for which we want to abort related transactions.\r\n */\r\nfunction repoAbortTransactions(repo, path) {\r\n    const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));\r\n    const transactionNode = treeSubTree(repo.transactionQueueTree_, path);\r\n    treeForEachAncestor(transactionNode, (node) => {\r\n        repoAbortTransactionsOnNode(repo, node);\r\n    });\r\n    repoAbortTransactionsOnNode(repo, transactionNode);\r\n    treeForEachDescendant(transactionNode, (node) => {\r\n        repoAbortTransactionsOnNode(repo, node);\r\n    });\r\n    return affectedPath;\r\n}\r\n/**\r\n * Abort transactions stored in this transaction queue node.\r\n *\r\n * @param node - Node to abort transactions for.\r\n */\r\nfunction repoAbortTransactionsOnNode(repo, node) {\r\n    const queue = treeGetValue(node);\r\n    if (queue) {\r\n        // Queue up the callbacks and fire them after cleaning up all of our\r\n        // transaction state, since the callback could trigger more transactions\r\n        // or sets.\r\n        const callbacks = [];\r\n        // Go through queue.  Any already-sent transactions must be marked for\r\n        // abort, while the unsent ones can be immediately aborted and removed.\r\n        let events = [];\r\n        let lastSent = -1;\r\n        for (let i = 0; i < queue.length; i++) {\r\n            if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) ;\r\n            else if (queue[i].status === 1 /* TransactionStatus.SENT */) {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(lastSent === i - 1, 'All SENT items should be at beginning of queue.');\r\n                lastSent = i;\r\n                // Mark transaction for abort when it comes back.\r\n                queue[i].status = 3 /* TransactionStatus.SENT_NEEDS_ABORT */;\r\n                queue[i].abortReason = 'set';\r\n            }\r\n            else {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queue[i].status === 0 /* TransactionStatus.RUN */, 'Unexpected transaction status in abort');\r\n                // We can abort it immediately.\r\n                queue[i].unwatcher();\r\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));\r\n                if (queue[i].onComplete) {\r\n                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, null));\r\n                }\r\n            }\r\n        }\r\n        if (lastSent === -1) {\r\n            // We're not waiting for any sent transactions.  We can clear the queue.\r\n            treeSetValue(node, undefined);\r\n        }\r\n        else {\r\n            // Remove the transactions we aborted.\r\n            queue.length = lastSent + 1;\r\n        }\r\n        // Now fire the callbacks.\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);\r\n        for (let i = 0; i < callbacks.length; i++) {\r\n            exceptionGuard(callbacks[i]);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction decodePath(pathString) {\r\n    let pathStringDecoded = '';\r\n    const pieces = pathString.split('/');\r\n    for (let i = 0; i < pieces.length; i++) {\r\n        if (pieces[i].length > 0) {\r\n            let piece = pieces[i];\r\n            try {\r\n                piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\r\n            }\r\n            catch (e) { }\r\n            pathStringDecoded += '/' + piece;\r\n        }\r\n    }\r\n    return pathStringDecoded;\r\n}\r\n/**\r\n * @returns key value hash\r\n */\r\nfunction decodeQuery(queryString) {\r\n    const results = {};\r\n    if (queryString.charAt(0) === '?') {\r\n        queryString = queryString.substring(1);\r\n    }\r\n    for (const segment of queryString.split('&')) {\r\n        if (segment.length === 0) {\r\n            continue;\r\n        }\r\n        const kv = segment.split('=');\r\n        if (kv.length === 2) {\r\n            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\r\n        }\r\n        else {\r\n            warn(`Invalid query segment '${segment}' in query '${queryString}'`);\r\n        }\r\n    }\r\n    return results;\r\n}\r\nconst parseRepoInfo = function (dataURL, nodeAdmin) {\r\n    const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;\r\n    if (parsedUrl.domain === 'firebase.com') {\r\n        fatal(parsedUrl.host +\r\n            ' is no longer supported. ' +\r\n            'Please use <YOUR FIREBASE>.firebaseio.com instead');\r\n    }\r\n    // Catch common error of uninitialized namespace value.\r\n    if ((!namespace || namespace === 'undefined') &&\r\n        parsedUrl.domain !== 'localhost') {\r\n        fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');\r\n    }\r\n    if (!parsedUrl.secure) {\r\n        warnIfPageIsSecure();\r\n    }\r\n    const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\r\n    return {\r\n        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, \r\n        /*persistenceKey=*/ '', \r\n        /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),\r\n        path: new Path(parsedUrl.pathString)\r\n    };\r\n};\r\nconst parseDatabaseURL = function (dataURL) {\r\n    // Default to empty strings in the event of a malformed string.\r\n    let host = '', domain = '', subdomain = '', pathString = '', namespace = '';\r\n    // Always default to SSL, unless otherwise specified.\r\n    let secure = true, scheme = 'https', port = 443;\r\n    // Don't do any validation here. The caller is responsible for validating the result of parsing.\r\n    if (typeof dataURL === 'string') {\r\n        // Parse scheme.\r\n        let colonInd = dataURL.indexOf('//');\r\n        if (colonInd >= 0) {\r\n            scheme = dataURL.substring(0, colonInd - 1);\r\n            dataURL = dataURL.substring(colonInd + 2);\r\n        }\r\n        // Parse host, path, and query string.\r\n        let slashInd = dataURL.indexOf('/');\r\n        if (slashInd === -1) {\r\n            slashInd = dataURL.length;\r\n        }\r\n        let questionMarkInd = dataURL.indexOf('?');\r\n        if (questionMarkInd === -1) {\r\n            questionMarkInd = dataURL.length;\r\n        }\r\n        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\r\n        if (slashInd < questionMarkInd) {\r\n            // For pathString, questionMarkInd will always come after slashInd\r\n            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\r\n        }\r\n        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));\r\n        // If we have a port, use scheme for determining if it's secure.\r\n        colonInd = host.indexOf(':');\r\n        if (colonInd >= 0) {\r\n            secure = scheme === 'https' || scheme === 'wss';\r\n            port = parseInt(host.substring(colonInd + 1), 10);\r\n        }\r\n        else {\r\n            colonInd = host.length;\r\n        }\r\n        const hostWithoutPort = host.slice(0, colonInd);\r\n        if (hostWithoutPort.toLowerCase() === 'localhost') {\r\n            domain = 'localhost';\r\n        }\r\n        else if (hostWithoutPort.split('.').length <= 2) {\r\n            domain = hostWithoutPort;\r\n        }\r\n        else {\r\n            // Interpret the subdomain of a 3 or more component URL as the namespace name.\r\n            const dotInd = host.indexOf('.');\r\n            subdomain = host.substring(0, dotInd).toLowerCase();\r\n            domain = host.substring(dotInd + 1);\r\n            // Normalize namespaces to lowercase to share storage / connection.\r\n            namespace = subdomain;\r\n        }\r\n        // Always treat the value of the `ns` as the namespace name if it is present.\r\n        if ('ns' in queryParams) {\r\n            namespace = queryParams['ns'];\r\n        }\r\n    }\r\n    return {\r\n        host,\r\n        port,\r\n        domain,\r\n        subdomain,\r\n        secure,\r\n        scheme,\r\n        pathString,\r\n        namespace\r\n    };\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Modeled after base64 web-safe chars, but ordered by ASCII.\r\nconst PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\r\n/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */\r\nconst nextPushId = (function () {\r\n    // Timestamp of last push, used to prevent local collisions if you push twice\r\n    // in one ms.\r\n    let lastPushTime = 0;\r\n    // We generate 72-bits of randomness which get turned into 12 characters and\r\n    // appended to the timestamp to prevent collisions with other clients. We\r\n    // store the last characters we generated because in the event of a collision,\r\n    // we'll use those same characters except \"incremented\" by one.\r\n    const lastRandChars = [];\r\n    return function (now) {\r\n        const duplicateTime = now === lastPushTime;\r\n        lastPushTime = now;\r\n        let i;\r\n        const timeStampChars = new Array(8);\r\n        for (i = 7; i >= 0; i--) {\r\n            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\r\n            // NOTE: Can't use << here because javascript will convert to int and lose\r\n            // the upper bits.\r\n            now = Math.floor(now / 64);\r\n        }\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(now === 0, 'Cannot push at time == 0');\r\n        let id = timeStampChars.join('');\r\n        if (!duplicateTime) {\r\n            for (i = 0; i < 12; i++) {\r\n                lastRandChars[i] = Math.floor(Math.random() * 64);\r\n            }\r\n        }\r\n        else {\r\n            // If the timestamp hasn't changed since last push, use the same random\r\n            // number, except incremented by 1.\r\n            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\r\n                lastRandChars[i] = 0;\r\n            }\r\n            lastRandChars[i]++;\r\n        }\r\n        for (i = 0; i < 12; i++) {\r\n            id += PUSH_CHARS.charAt(lastRandChars[i]);\r\n        }\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(id.length === 20, 'nextPushId: Length should be 20.');\r\n        return id;\r\n    };\r\n})();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Encapsulates the data needed to raise an event\r\n */\r\nclass DataEvent {\r\n    /**\r\n     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed\r\n     * @param eventRegistration - The function to call to with the event data. User provided\r\n     * @param snapshot - The data backing the event\r\n     * @param prevName - Optional, the name of the previous child for child_* events.\r\n     */\r\n    constructor(eventType, eventRegistration, snapshot, prevName) {\r\n        this.eventType = eventType;\r\n        this.eventRegistration = eventRegistration;\r\n        this.snapshot = snapshot;\r\n        this.prevName = prevName;\r\n    }\r\n    getPath() {\r\n        const ref = this.snapshot.ref;\r\n        if (this.eventType === 'value') {\r\n            return ref._path;\r\n        }\r\n        else {\r\n            return ref.parent._path;\r\n        }\r\n    }\r\n    getEventType() {\r\n        return this.eventType;\r\n    }\r\n    getEventRunner() {\r\n        return this.eventRegistration.getEventRunner(this);\r\n    }\r\n    toString() {\r\n        return (this.getPath().toString() +\r\n            ':' +\r\n            this.eventType +\r\n            ':' +\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(this.snapshot.exportVal()));\r\n    }\r\n}\r\nclass CancelEvent {\r\n    constructor(eventRegistration, error, path) {\r\n        this.eventRegistration = eventRegistration;\r\n        this.error = error;\r\n        this.path = path;\r\n    }\r\n    getPath() {\r\n        return this.path;\r\n    }\r\n    getEventType() {\r\n        return 'cancel';\r\n    }\r\n    getEventRunner() {\r\n        return this.eventRegistration.getEventRunner(this);\r\n    }\r\n    toString() {\r\n        return this.path.toString() + ':cancel';\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A wrapper class that converts events from the database@exp SDK to the legacy\r\n * Database SDK. Events are not converted directly as event registration relies\r\n * on reference comparison of the original user callback (see `matches()`) and\r\n * relies on equality of the legacy SDK's `context` object.\r\n */\r\nclass CallbackContext {\r\n    constructor(snapshotCallback, cancelCallback) {\r\n        this.snapshotCallback = snapshotCallback;\r\n        this.cancelCallback = cancelCallback;\r\n    }\r\n    onValue(expDataSnapshot, previousChildName) {\r\n        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);\r\n    }\r\n    onCancel(error) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.hasCancelCallback, 'Raising a cancel event on a listener with no cancel callback');\r\n        return this.cancelCallback.call(null, error);\r\n    }\r\n    get hasCancelCallback() {\r\n        return !!this.cancelCallback;\r\n    }\r\n    matches(other) {\r\n        return (this.snapshotCallback === other.snapshotCallback ||\r\n            (this.snapshotCallback.userCallback !== undefined &&\r\n                this.snapshotCallback.userCallback ===\r\n                    other.snapshotCallback.userCallback &&\r\n                this.snapshotCallback.context === other.snapshotCallback.context));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The `onDisconnect` class allows you to write or clear data when your client\r\n * disconnects from the Database server. These updates occur whether your\r\n * client disconnects cleanly or not, so you can rely on them to clean up data\r\n * even if a connection is dropped or a client crashes.\r\n *\r\n * The `onDisconnect` class is most commonly used to manage presence in\r\n * applications where it is useful to detect how many clients are connected and\r\n * when other clients disconnect. See\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information.\r\n *\r\n * To avoid problems when a connection is dropped before the requests can be\r\n * transferred to the Database server, these functions should be called before\r\n * writing any data.\r\n *\r\n * Note that `onDisconnect` operations are only triggered once. If you want an\r\n * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n * the `onDisconnect` operations each time you reconnect.\r\n */\r\nclass OnDisconnect {\r\n    /** @hideconstructor */\r\n    constructor(_repo, _path) {\r\n        this._repo = _repo;\r\n        this._path = _path;\r\n    }\r\n    /**\r\n     * Cancels all previously queued `onDisconnect()` set or update events for this\r\n     * location and all children.\r\n     *\r\n     * If a write has been queued for this location via a `set()` or `update()` at a\r\n     * parent location, the write at this location will be canceled, though writes\r\n     * to sibling locations will still occur.\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */\r\n    cancel() {\r\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n    /**\r\n     * Ensures the data at this location is deleted when the client is disconnected\r\n     * (due to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */\r\n    remove() {\r\n        validateWritablePath('OnDisconnect.remove', this._path);\r\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n    /**\r\n     * Ensures the data at this location is set to the specified value when the\r\n     * client is disconnected (due to closing the browser, navigating to a new page,\r\n     * or network issues).\r\n     *\r\n     * `set()` is especially useful for implementing \"presence\" systems, where a\r\n     * value should be changed or cleared when a user disconnects so that they\r\n     * appear \"offline\" to other users. See\r\n     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n     * for more information.\r\n     *\r\n     * Note that `onDisconnect` operations are only triggered once. If you want an\r\n     * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n     * the `onDisconnect` operations each time.\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */\r\n    set(value) {\r\n        validateWritablePath('OnDisconnect.set', this._path);\r\n        validateFirebaseDataArg('OnDisconnect.set', value, this._path, false);\r\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n    /**\r\n     * Ensures the data at this location is set to the specified value and priority\r\n     * when the client is disconnected (due to closing the browser, navigating to a\r\n     * new page, or network issues).\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @param priority - The priority to be written (string, number, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */\r\n    setWithPriority(value, priority) {\r\n        validateWritablePath('OnDisconnect.setWithPriority', this._path);\r\n        validateFirebaseDataArg('OnDisconnect.setWithPriority', value, this._path, false);\r\n        validatePriority('OnDisconnect.setWithPriority', priority, false);\r\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n    /**\r\n     * Writes multiple values at this location when the client is disconnected (due\r\n     * to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * The `values` argument contains multiple property-value pairs that will be\r\n     * written to the Database together. Each child property can either be a simple\r\n     * property (for example, \"name\") or a relative path (for example, \"name/first\")\r\n     * from the current location to the data to update.\r\n     *\r\n     * As opposed to the `set()` method, `update()` can be use to selectively update\r\n     * only the referenced properties at the current location (instead of replacing\r\n     * all the child properties at the current location).\r\n     *\r\n     * @param values - Object containing multiple values.\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */\r\n    update(values) {\r\n        validateWritablePath('OnDisconnect.update', this._path);\r\n        validateFirebaseMergeDataArg('OnDisconnect.update', values, this._path, false);\r\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nclass QueryImpl {\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(_repo, _path, _queryParams, _orderByCalled) {\r\n        this._repo = _repo;\r\n        this._path = _path;\r\n        this._queryParams = _queryParams;\r\n        this._orderByCalled = _orderByCalled;\r\n    }\r\n    get key() {\r\n        if (pathIsEmpty(this._path)) {\r\n            return null;\r\n        }\r\n        else {\r\n            return pathGetBack(this._path);\r\n        }\r\n    }\r\n    get ref() {\r\n        return new ReferenceImpl(this._repo, this._path);\r\n    }\r\n    get _queryIdentifier() {\r\n        const obj = queryParamsGetQueryObject(this._queryParams);\r\n        const id = ObjectToUniqueKey(obj);\r\n        return id === '{}' ? 'default' : id;\r\n    }\r\n    /**\r\n     * An object representation of the query parameters used by this Query.\r\n     */\r\n    get _queryObject() {\r\n        return queryParamsGetQueryObject(this._queryParams);\r\n    }\r\n    isEqual(other) {\r\n        other = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(other);\r\n        if (!(other instanceof QueryImpl)) {\r\n            return false;\r\n        }\r\n        const sameRepo = this._repo === other._repo;\r\n        const samePath = pathEquals(this._path, other._path);\r\n        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;\r\n        return sameRepo && samePath && sameQueryIdentifier;\r\n    }\r\n    toJSON() {\r\n        return this.toString();\r\n    }\r\n    toString() {\r\n        return this._repo.toString() + pathToUrlEncodedString(this._path);\r\n    }\r\n}\r\n/**\r\n * Validates that no other order by call has been made\r\n */\r\nfunction validateNoPreviousOrderByCall(query, fnName) {\r\n    if (query._orderByCalled === true) {\r\n        throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\r\n    }\r\n}\r\n/**\r\n * Validates start/end values for queries.\r\n */\r\nfunction validateQueryEndpoints(params) {\r\n    let startNode = null;\r\n    let endNode = null;\r\n    if (params.hasStart()) {\r\n        startNode = params.getIndexStartValue();\r\n    }\r\n    if (params.hasEnd()) {\r\n        endNode = params.getIndexEndValue();\r\n    }\r\n    if (params.getIndex() === KEY_INDEX) {\r\n        const tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +\r\n            'startAt(), endAt(), or equalTo().';\r\n        const wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), startAfter(), ' +\r\n            'endAt(), endBefore(), or equalTo() must be a string.';\r\n        if (params.hasStart()) {\r\n            const startName = params.getIndexStartName();\r\n            if (startName !== MIN_NAME) {\r\n                throw new Error(tooManyArgsError);\r\n            }\r\n            else if (typeof startNode !== 'string') {\r\n                throw new Error(wrongArgTypeError);\r\n            }\r\n        }\r\n        if (params.hasEnd()) {\r\n            const endName = params.getIndexEndName();\r\n            if (endName !== MAX_NAME) {\r\n                throw new Error(tooManyArgsError);\r\n            }\r\n            else if (typeof endNode !== 'string') {\r\n                throw new Error(wrongArgTypeError);\r\n            }\r\n        }\r\n    }\r\n    else if (params.getIndex() === PRIORITY_INDEX) {\r\n        if ((startNode != null && !isValidPriority(startNode)) ||\r\n            (endNode != null && !isValidPriority(endNode))) {\r\n            throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +\r\n                'startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value ' +\r\n                '(null, a number, or a string).');\r\n        }\r\n    }\r\n    else {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(params.getIndex() instanceof PathIndex ||\r\n            params.getIndex() === VALUE_INDEX, 'unknown index type.');\r\n        if ((startNode != null && typeof startNode === 'object') ||\r\n            (endNode != null && typeof endNode === 'object')) {\r\n            throw new Error('Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or ' +\r\n                'equalTo() cannot be an object.');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Validates that limit* has been called with the correct combination of parameters\r\n */\r\nfunction validateLimit(params) {\r\n    if (params.hasStart() &&\r\n        params.hasEnd() &&\r\n        params.hasLimit() &&\r\n        !params.hasAnchoredLimit()) {\r\n        throw new Error(\"Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use \" +\r\n            'limitToFirst() or limitToLast() instead.');\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass ReferenceImpl extends QueryImpl {\r\n    /** @hideconstructor */\r\n    constructor(repo, path) {\r\n        super(repo, path, new QueryParams(), false);\r\n    }\r\n    get parent() {\r\n        const parentPath = pathParent(this._path);\r\n        return parentPath === null\r\n            ? null\r\n            : new ReferenceImpl(this._repo, parentPath);\r\n    }\r\n    get root() {\r\n        let ref = this;\r\n        while (ref.parent !== null) {\r\n            ref = ref.parent;\r\n        }\r\n        return ref;\r\n    }\r\n}\r\n/**\r\n * A `DataSnapshot` contains data from a Database location.\r\n *\r\n * Any time you read data from the Database, you receive the data as a\r\n * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach\r\n * with `on()` or `once()`. You can extract the contents of the snapshot as a\r\n * JavaScript object by calling the `val()` method. Alternatively, you can\r\n * traverse into the snapshot by calling `child()` to return child snapshots\r\n * (which you could then call `val()` on).\r\n *\r\n * A `DataSnapshot` is an efficiently generated, immutable copy of the data at\r\n * a Database location. It cannot be modified and will never change (to modify\r\n * data, you always call the `set()` method on a `Reference` directly).\r\n */\r\nclass DataSnapshot {\r\n    /**\r\n     * @param _node - A SnapshotNode to wrap.\r\n     * @param ref - The location this snapshot came from.\r\n     * @param _index - The iteration order for this snapshot\r\n     * @hideconstructor\r\n     */\r\n    constructor(_node, \r\n    /**\r\n     * The location of this DataSnapshot.\r\n     */\r\n    ref, _index) {\r\n        this._node = _node;\r\n        this.ref = ref;\r\n        this._index = _index;\r\n    }\r\n    /**\r\n     * Gets the priority value of the data in this `DataSnapshot`.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}\r\n     * ).\r\n     */\r\n    get priority() {\r\n        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\r\n        return this._node.getPriority().val();\r\n    }\r\n    /**\r\n     * The key (last part of the path) of the location of this `DataSnapshot`.\r\n     *\r\n     * The last token in a Database location is considered its key. For example,\r\n     * \"ada\" is the key for the /users/ada/ node. Accessing the key on any\r\n     * `DataSnapshot` will return the key for the location that generated it.\r\n     * However, accessing the key on the root URL of a Database will return\r\n     * `null`.\r\n     */\r\n    get key() {\r\n        return this.ref.key;\r\n    }\r\n    /** Returns the number of child properties of this `DataSnapshot`. */\r\n    get size() {\r\n        return this._node.numChildren();\r\n    }\r\n    /**\r\n     * Gets another `DataSnapshot` for the location at the specified relative path.\r\n     *\r\n     * Passing a relative path to the `child()` method of a DataSnapshot returns\r\n     * another `DataSnapshot` for the location at the specified relative path. The\r\n     * relative path can either be a simple child name (for example, \"ada\") or a\r\n     * deeper, slash-separated path (for example, \"ada/name/first\"). If the child\r\n     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`\r\n     * whose value is `null`) is returned.\r\n     *\r\n     * @param path - A relative path to the location of child data.\r\n     */\r\n    child(path) {\r\n        const childPath = new Path(path);\r\n        const childRef = child(this.ref, path);\r\n        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);\r\n    }\r\n    /**\r\n     * Returns true if this `DataSnapshot` contains any data. It is slightly more\r\n     * efficient than using `snapshot.val() !== null`.\r\n     */\r\n    exists() {\r\n        return !this._node.isEmpty();\r\n    }\r\n    /**\r\n     * Exports the entire contents of the DataSnapshot as a JavaScript object.\r\n     *\r\n     * The `exportVal()` method is similar to `val()`, except priority information\r\n     * is included (if available), making it suitable for backing up your data.\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    exportVal() {\r\n        return this._node.val(true);\r\n    }\r\n    /**\r\n     * Enumerates the top-level children in the `DataSnapshot`.\r\n     *\r\n     * Because of the way JavaScript objects work, the ordering of data in the\r\n     * JavaScript object returned by `val()` is not guaranteed to match the\r\n     * ordering on the server nor the ordering of `onChildAdded()` events. That is\r\n     * where `forEach()` comes in handy. It guarantees the children of a\r\n     * `DataSnapshot` will be iterated in their query order.\r\n     *\r\n     * If no explicit `orderBy*()` method is used, results are returned\r\n     * ordered by key (unless priorities are used, in which case, results are\r\n     * returned by priority).\r\n     *\r\n     * @param action - A function that will be called for each child DataSnapshot.\r\n     * The callback can return true to cancel further enumeration.\r\n     * @returns true if enumeration was canceled due to your callback returning\r\n     * true.\r\n     */\r\n    forEach(action) {\r\n        if (this._node.isLeafNode()) {\r\n            return false;\r\n        }\r\n        const childrenNode = this._node;\r\n        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\r\n        return !!childrenNode.forEachChild(this._index, (key, node) => {\r\n            return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));\r\n        });\r\n    }\r\n    /**\r\n     * Returns true if the specified child path has (non-null) data.\r\n     *\r\n     * @param path - A relative path to the location of a potential child.\r\n     * @returns `true` if data exists at the specified child path; else\r\n     *  `false`.\r\n     */\r\n    hasChild(path) {\r\n        const childPath = new Path(path);\r\n        return !this._node.getChild(childPath).isEmpty();\r\n    }\r\n    /**\r\n     * Returns whether or not the `DataSnapshot` has any non-`null` child\r\n     * properties.\r\n     *\r\n     * You can use `hasChildren()` to determine if a `DataSnapshot` has any\r\n     * children. If it does, you can enumerate them using `forEach()`. If it\r\n     * doesn't, then either this snapshot contains a primitive value (which can be\r\n     * retrieved with `val()`) or it is empty (in which case, `val()` will return\r\n     * `null`).\r\n     *\r\n     * @returns true if this snapshot has any children; else false.\r\n     */\r\n    hasChildren() {\r\n        if (this._node.isLeafNode()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return !this._node.isEmpty();\r\n        }\r\n    }\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     */\r\n    toJSON() {\r\n        return this.exportVal();\r\n    }\r\n    /**\r\n     * Extracts a JavaScript value from a `DataSnapshot`.\r\n     *\r\n     * Depending on the data in a `DataSnapshot`, the `val()` method may return a\r\n     * scalar type (string, number, or boolean), an array, or an object. It may\r\n     * also return null, indicating that the `DataSnapshot` is empty (contains no\r\n     * data).\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    val() {\r\n        return this._node.val();\r\n    }\r\n}\r\n/**\r\n *\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided path. If no path is provided, the `Reference`\r\n * will point to the root of the Database.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param path - Optional path representing the location the returned\r\n *   `Reference` will point. If not provided, the returned `Reference` will\r\n *   point to the root of the Database.\r\n * @returns If a path is provided, a `Reference`\r\n *   pointing to the provided path. Otherwise, a `Reference` pointing to the\r\n *   root of the Database.\r\n */\r\nfunction ref(db, path) {\r\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);\r\n    db._checkNotDeleted('ref');\r\n    return path !== undefined ? child(db._root, path) : db._root;\r\n}\r\n/**\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided Firebase URL.\r\n *\r\n * An exception is thrown if the URL is not a valid Firebase Database URL or it\r\n * has a different domain than the current `Database` instance.\r\n *\r\n * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored\r\n * and are not applied to the returned `Reference`.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param url - The Firebase URL at which the returned `Reference` will\r\n *   point.\r\n * @returns A `Reference` pointing to the provided\r\n *   Firebase URL.\r\n */\r\nfunction refFromURL(db, url) {\r\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);\r\n    db._checkNotDeleted('refFromURL');\r\n    const parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);\r\n    validateUrl('refFromURL', parsedURL);\r\n    const repoInfo = parsedURL.repoInfo;\r\n    if (!db._repo.repoInfo_.isCustomHost() &&\r\n        repoInfo.host !== db._repo.repoInfo_.host) {\r\n        fatal('refFromURL' +\r\n            ': Host name does not match the current database: ' +\r\n            '(found ' +\r\n            repoInfo.host +\r\n            ' but expected ' +\r\n            db._repo.repoInfo_.host +\r\n            ')');\r\n    }\r\n    return ref(db, parsedURL.path.toString());\r\n}\r\n/**\r\n * Gets a `Reference` for the location at the specified relative path.\r\n *\r\n * The relative path can either be a simple child name (for example, \"ada\") or\r\n * a deeper slash-separated path (for example, \"ada/name/first\").\r\n *\r\n * @param parent - The parent location.\r\n * @param path - A relative path from this location to the desired child\r\n *   location.\r\n * @returns The specified child location.\r\n */\r\nfunction child(parent, path) {\r\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(parent);\r\n    if (pathGetFront(parent._path) === null) {\r\n        validateRootPathString('child', 'path', path, false);\r\n    }\r\n    else {\r\n        validatePathString('child', 'path', path, false);\r\n    }\r\n    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));\r\n}\r\n/**\r\n * Returns an `OnDisconnect` object - see\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information on how to use it.\r\n *\r\n * @param ref - The reference to add OnDisconnect triggers for.\r\n */\r\nfunction onDisconnect(ref) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);\r\n    return new OnDisconnect(ref._repo, ref._path);\r\n}\r\n/**\r\n * Generates a new child location using a unique key and returns its\r\n * `Reference`.\r\n *\r\n * This is the most common pattern for adding data to a collection of items.\r\n *\r\n * If you provide a value to `push()`, the value is written to the\r\n * generated location. If you don't pass a value, nothing is written to the\r\n * database and the child remains empty (but you can use the `Reference`\r\n * elsewhere).\r\n *\r\n * The unique keys generated by `push()` are ordered by the current time, so the\r\n * resulting list of items is chronologically sorted. The keys are also\r\n * designed to be unguessable (they contain 72 random bits of entropy).\r\n *\r\n * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.\r\n * See {@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.\r\n *\r\n * @param parent - The parent location.\r\n * @param value - Optional value to be written at the generated location.\r\n * @returns Combined `Promise` and `Reference`; resolves when write is complete,\r\n * but can be used immediately as the `Reference` to the child location.\r\n */\r\nfunction push(parent, value) {\r\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(parent);\r\n    validateWritablePath('push', parent._path);\r\n    validateFirebaseDataArg('push', value, parent._path, true);\r\n    const now = repoServerTime(parent._repo);\r\n    const name = nextPushId(now);\r\n    // push() returns a ThennableReference whose promise is fulfilled with a\r\n    // regular Reference. We use child() to create handles to two different\r\n    // references. The first is turned into a ThennableReference below by adding\r\n    // then() and catch() methods and is used as the return value of push(). The\r\n    // second remains a regular Reference and is used as the fulfilled value of\r\n    // the first ThennableReference.\r\n    const thennablePushRef = child(parent, name);\r\n    const pushRef = child(parent, name);\r\n    let promise;\r\n    if (value != null) {\r\n        promise = set(pushRef, value).then(() => pushRef);\r\n    }\r\n    else {\r\n        promise = Promise.resolve(pushRef);\r\n    }\r\n    thennablePushRef.then = promise.then.bind(promise);\r\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\r\n    return thennablePushRef;\r\n}\r\n/**\r\n * Removes the data at this Database location.\r\n *\r\n * Any data at child locations will also be deleted.\r\n *\r\n * The effect of the remove will be visible immediately and the corresponding\r\n * event 'value' will be triggered. Synchronization of the remove to the\r\n * Firebase servers will also be started, and the returned Promise will resolve\r\n * when complete. If provided, the onComplete callback will be called\r\n * asynchronously after synchronization has finished.\r\n *\r\n * @param ref - The location to remove.\r\n * @returns Resolves when remove on server is complete.\r\n */\r\nfunction remove(ref) {\r\n    validateWritablePath('remove', ref._path);\r\n    return set(ref, null);\r\n}\r\n/**\r\n * Writes data to this Database location.\r\n *\r\n * This will overwrite any data at this location and all child locations.\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events (\"value\", \"child_added\", etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * Passing `null` for the new value is equivalent to calling `remove()`; namely,\r\n * all data at this location and all child locations will be deleted.\r\n *\r\n * `set()` will remove any priority stored at this location, so if priority is\r\n * meant to be preserved, you need to use `setWithPriority()` instead.\r\n *\r\n * Note that modifying data with `set()` will cancel any pending transactions\r\n * at that location, so extreme care should be taken if mixing `set()` and\r\n * `transaction()` to modify the same data.\r\n *\r\n * A single `set()` will generate a single \"value\" event at the location where\r\n * the `set()` was performed.\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @returns Resolves when write to server is complete.\r\n */\r\nfunction set(ref, value) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);\r\n    validateWritablePath('set', ref._path);\r\n    validateFirebaseDataArg('set', value, ref._path, false);\r\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n    repoSetWithPriority(ref._repo, ref._path, value, \r\n    /*priority=*/ null, deferred.wrapCallback(() => { }));\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Sets a priority for the data at this Database location.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */\r\nfunction setPriority(ref, priority) {\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);\r\n    validateWritablePath('setPriority', ref._path);\r\n    validatePriority('setPriority', priority, false);\r\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n    repoSetWithPriority(ref._repo, pathChild(ref._path, '.priority'), priority, null, deferred.wrapCallback(() => { }));\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Writes data the Database location. Like `set()` but also specifies the\r\n * priority for that data.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */\r\nfunction setWithPriority(ref, value, priority) {\r\n    validateWritablePath('setWithPriority', ref._path);\r\n    validateFirebaseDataArg('setWithPriority', value, ref._path, false);\r\n    validatePriority('setWithPriority', priority, false);\r\n    if (ref.key === '.length' || ref.key === '.keys') {\r\n        throw 'setWithPriority failed: ' + ref.key + ' is a read-only object.';\r\n    }\r\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n    repoSetWithPriority(ref._repo, ref._path, value, priority, deferred.wrapCallback(() => { }));\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Writes multiple values to the Database at once.\r\n *\r\n * The `values` argument contains multiple property-value pairs that will be\r\n * written to the Database together. Each child property can either be a simple\r\n * property (for example, \"name\") or a relative path (for example,\r\n * \"name/first\") from the current location to the data to update.\r\n *\r\n * As opposed to the `set()` method, `update()` can be use to selectively update\r\n * only the referenced properties at the current location (instead of replacing\r\n * all the child properties at the current location).\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events ('value', 'child_added', etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * A single `update()` will generate a single \"value\" event at the location\r\n * where the `update()` was performed, regardless of how many children were\r\n * modified.\r\n *\r\n * Note that modifying data with `update()` will cancel any pending\r\n * transactions at that location, so extreme care should be taken if mixing\r\n * `update()` and `transaction()` to modify the same data.\r\n *\r\n * Passing `null` to `update()` will remove the data at this location.\r\n *\r\n * See\r\n * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.\r\n *\r\n * @param ref - The location to write to.\r\n * @param values - Object containing multiple values.\r\n * @returns Resolves when update on server is complete.\r\n */\r\nfunction update(ref, values) {\r\n    validateFirebaseMergeDataArg('update', values, ref._path, false);\r\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n    repoUpdate(ref._repo, ref._path, values, deferred.wrapCallback(() => { }));\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Gets the most up-to-date result for this query.\r\n *\r\n * @param query - The query to run.\r\n * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is\r\n * available, or rejects if the client is unable to return a value (e.g., if the\r\n * server is unreachable and there is nothing cached).\r\n */\r\nfunction get(query) {\r\n    query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(query);\r\n    const callbackContext = new CallbackContext(() => { });\r\n    const container = new ValueEventRegistration(callbackContext);\r\n    return repoGetValue(query._repo, query, container).then(node => {\r\n        return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());\r\n    });\r\n}\r\n/**\r\n * Represents registration for 'value' events.\r\n */\r\nclass ValueEventRegistration {\r\n    constructor(callbackContext) {\r\n        this.callbackContext = callbackContext;\r\n    }\r\n    respondsTo(eventType) {\r\n        return eventType === 'value';\r\n    }\r\n    createEvent(change, query) {\r\n        const index = query._queryParams.getIndex();\r\n        return new DataEvent('value', this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));\r\n    }\r\n    getEventRunner(eventData) {\r\n        if (eventData.getEventType() === 'cancel') {\r\n            return () => this.callbackContext.onCancel(eventData.error);\r\n        }\r\n        else {\r\n            return () => this.callbackContext.onValue(eventData.snapshot, null);\r\n        }\r\n    }\r\n    createCancelEvent(error, path) {\r\n        if (this.callbackContext.hasCancelCallback) {\r\n            return new CancelEvent(this, error, path);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    matches(other) {\r\n        if (!(other instanceof ValueEventRegistration)) {\r\n            return false;\r\n        }\r\n        else if (!other.callbackContext || !this.callbackContext) {\r\n            // If no callback specified, we consider it to match any callback.\r\n            return true;\r\n        }\r\n        else {\r\n            return other.callbackContext.matches(this.callbackContext);\r\n        }\r\n    }\r\n    hasAnyCallback() {\r\n        return this.callbackContext !== null;\r\n    }\r\n}\r\n/**\r\n * Represents the registration of a child_x event.\r\n */\r\nclass ChildEventRegistration {\r\n    constructor(eventType, callbackContext) {\r\n        this.eventType = eventType;\r\n        this.callbackContext = callbackContext;\r\n    }\r\n    respondsTo(eventType) {\r\n        let eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;\r\n        eventToCheck =\r\n            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\r\n        return this.eventType === eventToCheck;\r\n    }\r\n    createCancelEvent(error, path) {\r\n        if (this.callbackContext.hasCancelCallback) {\r\n            return new CancelEvent(this, error, path);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    createEvent(change, query) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(change.childName != null, 'Child events should have a childName.');\r\n        const childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);\r\n        const index = query._queryParams.getIndex();\r\n        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);\r\n    }\r\n    getEventRunner(eventData) {\r\n        if (eventData.getEventType() === 'cancel') {\r\n            return () => this.callbackContext.onCancel(eventData.error);\r\n        }\r\n        else {\r\n            return () => this.callbackContext.onValue(eventData.snapshot, eventData.prevName);\r\n        }\r\n    }\r\n    matches(other) {\r\n        if (other instanceof ChildEventRegistration) {\r\n            return (this.eventType === other.eventType &&\r\n                (!this.callbackContext ||\r\n                    !other.callbackContext ||\r\n                    this.callbackContext.matches(other.callbackContext)));\r\n        }\r\n        return false;\r\n    }\r\n    hasAnyCallback() {\r\n        return !!this.callbackContext;\r\n    }\r\n}\r\nfunction addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) {\r\n    let cancelCallback;\r\n    if (typeof cancelCallbackOrListenOptions === 'object') {\r\n        cancelCallback = undefined;\r\n        options = cancelCallbackOrListenOptions;\r\n    }\r\n    if (typeof cancelCallbackOrListenOptions === 'function') {\r\n        cancelCallback = cancelCallbackOrListenOptions;\r\n    }\r\n    if (options && options.onlyOnce) {\r\n        const userCallback = callback;\r\n        const onceCallback = (dataSnapshot, previousChildName) => {\r\n            repoRemoveEventCallbackForQuery(query._repo, query, container);\r\n            userCallback(dataSnapshot, previousChildName);\r\n        };\r\n        onceCallback.userCallback = callback.userCallback;\r\n        onceCallback.context = callback.context;\r\n        callback = onceCallback;\r\n    }\r\n    const callbackContext = new CallbackContext(callback, cancelCallback || undefined);\r\n    const container = eventType === 'value'\r\n        ? new ValueEventRegistration(callbackContext)\r\n        : new ChildEventRegistration(eventType, callbackContext);\r\n    repoAddEventCallbackForQuery(query._repo, query, container);\r\n    return () => repoRemoveEventCallbackForQuery(query._repo, query, container);\r\n}\r\nfunction onValue(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'value', callback, cancelCallbackOrListenOptions, options);\r\n}\r\nfunction onChildAdded(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'child_added', callback, cancelCallbackOrListenOptions, options);\r\n}\r\nfunction onChildChanged(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'child_changed', callback, cancelCallbackOrListenOptions, options);\r\n}\r\nfunction onChildMoved(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'child_moved', callback, cancelCallbackOrListenOptions, options);\r\n}\r\nfunction onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'child_removed', callback, cancelCallbackOrListenOptions, options);\r\n}\r\n/**\r\n * Detaches a callback previously attached with the corresponding `on*()` (`onValue`, `onChildAdded`) listener.\r\n * Note: This is not the recommended way to remove a listener. Instead, please use the returned callback function from\r\n * the respective `on*` callbacks.\r\n *\r\n * Detach a callback previously attached with `on*()`. Calling `off()` on a parent listener\r\n * will not automatically remove listeners registered on child nodes, `off()`\r\n * must also be called on any child listeners to remove the callback.\r\n *\r\n * If a callback is not specified, all callbacks for the specified eventType\r\n * will be removed. Similarly, if no eventType is specified, all callbacks\r\n * for the `Reference` will be removed.\r\n *\r\n * Individual listeners can also be removed by invoking their unsubscribe\r\n * callbacks.\r\n *\r\n * @param query - The query that the listener was registered with.\r\n * @param eventType - One of the following strings: \"value\", \"child_added\",\r\n * \"child_changed\", \"child_removed\", or \"child_moved.\" If omitted, all callbacks\r\n * for the `Reference` will be removed.\r\n * @param callback - The callback function that was passed to `on()` or\r\n * `undefined` to remove all callbacks.\r\n */\r\nfunction off(query, eventType, callback) {\r\n    let container = null;\r\n    const expCallback = callback ? new CallbackContext(callback) : null;\r\n    if (eventType === 'value') {\r\n        container = new ValueEventRegistration(expCallback);\r\n    }\r\n    else if (eventType) {\r\n        container = new ChildEventRegistration(eventType, expCallback);\r\n    }\r\n    repoRemoveEventCallbackForQuery(query._repo, query, container);\r\n}\r\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Database query. `QueryConstraint`s are created by invoking {@link endAt},\r\n * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link\r\n * limitToFirst}, {@link limitToLast}, {@link orderByChild},\r\n * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,\r\n * {@link orderByValue}  or {@link equalTo} and\r\n * can then be passed to {@link query} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */\r\nclass QueryConstraint {\r\n}\r\nclass QueryEndAtConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('endAt', this._value, query._path, true);\r\n        const newParams = queryParamsEndAt(query._queryParams, this._value, this._key);\r\n        validateLimit(newParams);\r\n        validateQueryEndpoints(newParams);\r\n        if (query._queryParams.hasEnd()) {\r\n            throw new Error('endAt: Starting point was already set (by another call to endAt, ' +\r\n                'endBefore or equalTo).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` with the specified ending point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name less than or equal\r\n * to the specified key.\r\n *\r\n * You can read more about `endAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to end at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end at, among the children with the previously\r\n * specified priority. This argument is only allowed if ordering by child,\r\n * value, or priority.\r\n */\r\nfunction endAt(value, key) {\r\n    validateKey('endAt', 'key', key, true);\r\n    return new QueryEndAtConstraint(value, key);\r\n}\r\nclass QueryEndBeforeConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('endBefore', this._value, query._path, false);\r\n        const newParams = queryParamsEndBefore(query._queryParams, this._value, this._key);\r\n        validateLimit(newParams);\r\n        validateQueryEndpoints(newParams);\r\n        if (query._queryParams.hasEnd()) {\r\n            throw new Error('endBefore: Starting point was already set (by another call to endAt, ' +\r\n                'endBefore or equalTo).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` with the specified ending point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is exclusive. If only a value is provided, children\r\n * with a value less than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value less than or equal\r\n * to the specified value and a key name less than the specified key.\r\n *\r\n * @param value - The value to end before. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end before, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */\r\nfunction endBefore(value, key) {\r\n    validateKey('endBefore', 'key', key, true);\r\n    return new QueryEndBeforeConstraint(value, key);\r\n}\r\nclass QueryStartAtConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('startAt', this._value, query._path, true);\r\n        const newParams = queryParamsStartAt(query._queryParams, this._value, this._key);\r\n        validateLimit(newParams);\r\n        validateQueryEndpoints(newParams);\r\n        if (query._queryParams.hasStart()) {\r\n            throw new Error('startAt: Starting point was already set (by another call to startAt, ' +\r\n                'startBefore or equalTo).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` with the specified starting point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name greater than or\r\n * equal to the specified key.\r\n *\r\n * You can read more about `startAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to start at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */\r\nfunction startAt(value = null, key) {\r\n    validateKey('startAt', 'key', key, true);\r\n    return new QueryStartAtConstraint(value, key);\r\n}\r\nclass QueryStartAfterConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('startAfter', this._value, query._path, false);\r\n        const newParams = queryParamsStartAfter(query._queryParams, this._value, this._key);\r\n        validateLimit(newParams);\r\n        validateQueryEndpoints(newParams);\r\n        if (query._queryParams.hasStart()) {\r\n            throw new Error('startAfter: Starting point was already set (by another call to startAt, ' +\r\n                'startAfter, or equalTo).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` with the specified starting point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is exclusive. If only a value is provided, children\r\n * with a value greater than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value greater than or equal\r\n * to the specified value and a a key name greater than the specified key.\r\n *\r\n * @param value - The value to start after. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start after. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */\r\nfunction startAfter(value, key) {\r\n    validateKey('startAfter', 'key', key, true);\r\n    return new QueryStartAfterConstraint(value, key);\r\n}\r\nclass QueryLimitToFirstConstraint extends QueryConstraint {\r\n    constructor(_limit) {\r\n        super();\r\n        this._limit = _limit;\r\n    }\r\n    _apply(query) {\r\n        if (query._queryParams.hasLimit()) {\r\n            throw new Error('limitToFirst: Limit was already set (by another call to limitToFirst ' +\r\n                'or limitToLast).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToFirst(query._queryParams, this._limit), query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that if limited to the first specific number\r\n * of children.\r\n *\r\n * The `limitToFirst()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the first 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToFirst()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */\r\nfunction limitToFirst(limit) {\r\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\r\n        throw new Error('limitToFirst: First argument must be a positive integer.');\r\n    }\r\n    return new QueryLimitToFirstConstraint(limit);\r\n}\r\nclass QueryLimitToLastConstraint extends QueryConstraint {\r\n    constructor(_limit) {\r\n        super();\r\n        this._limit = _limit;\r\n    }\r\n    _apply(query) {\r\n        if (query._queryParams.hasLimit()) {\r\n            throw new Error('limitToLast: Limit was already set (by another call to limitToFirst ' +\r\n                'or limitToLast).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToLast(query._queryParams, this._limit), query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that is limited to return only the last\r\n * specified number of children.\r\n *\r\n * The `limitToLast()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the last 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToLast()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */\r\nfunction limitToLast(limit) {\r\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\r\n        throw new Error('limitToLast: First argument must be a positive integer.');\r\n    }\r\n    return new QueryLimitToLastConstraint(limit);\r\n}\r\nclass QueryOrderByChildConstraint extends QueryConstraint {\r\n    constructor(_path) {\r\n        super();\r\n        this._path = _path;\r\n    }\r\n    _apply(query) {\r\n        validateNoPreviousOrderByCall(query, 'orderByChild');\r\n        const parsedPath = new Path(this._path);\r\n        if (pathIsEmpty(parsedPath)) {\r\n            throw new Error('orderByChild: cannot pass in empty path. Use orderByValue() instead.');\r\n        }\r\n        const index = new PathIndex(parsedPath);\r\n        const newParams = queryParamsOrderBy(query._queryParams, index);\r\n        validateQueryEndpoints(newParams);\r\n        return new QueryImpl(query._repo, query._path, newParams, \r\n        /*orderByCalled=*/ true);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that orders by the specified child key.\r\n *\r\n * Queries can only order by one key at a time. Calling `orderByChild()`\r\n * multiple times on the same query is an error.\r\n *\r\n * Firebase queries allow you to order your data by any child key on the fly.\r\n * However, if you know in advance what your indexes will be, you can define\r\n * them via the .indexOn rule in your Security Rules for better performance. See\r\n * the{@link https://firebase.google.com/docs/database/security/indexing-data}\r\n * rule for more information.\r\n *\r\n * You can read more about `orderByChild()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n *\r\n * @param path - The path to order by.\r\n */\r\nfunction orderByChild(path) {\r\n    if (path === '$key') {\r\n        throw new Error('orderByChild: \"$key\" is invalid.  Use orderByKey() instead.');\r\n    }\r\n    else if (path === '$priority') {\r\n        throw new Error('orderByChild: \"$priority\" is invalid.  Use orderByPriority() instead.');\r\n    }\r\n    else if (path === '$value') {\r\n        throw new Error('orderByChild: \"$value\" is invalid.  Use orderByValue() instead.');\r\n    }\r\n    validatePathString('orderByChild', 'path', path, false);\r\n    return new QueryOrderByChildConstraint(path);\r\n}\r\nclass QueryOrderByKeyConstraint extends QueryConstraint {\r\n    _apply(query) {\r\n        validateNoPreviousOrderByCall(query, 'orderByKey');\r\n        const newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);\r\n        validateQueryEndpoints(newParams);\r\n        return new QueryImpl(query._repo, query._path, newParams, \r\n        /*orderByCalled=*/ true);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that orders by the key.\r\n *\r\n * Sorts the results of a query by their (ascending) key values.\r\n *\r\n * You can read more about `orderByKey()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */\r\nfunction orderByKey() {\r\n    return new QueryOrderByKeyConstraint();\r\n}\r\nclass QueryOrderByPriorityConstraint extends QueryConstraint {\r\n    _apply(query) {\r\n        validateNoPreviousOrderByCall(query, 'orderByPriority');\r\n        const newParams = queryParamsOrderBy(query._queryParams, PRIORITY_INDEX);\r\n        validateQueryEndpoints(newParams);\r\n        return new QueryImpl(query._repo, query._path, newParams, \r\n        /*orderByCalled=*/ true);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that orders by priority.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}\r\n * for alternatives to priority.\r\n */\r\nfunction orderByPriority() {\r\n    return new QueryOrderByPriorityConstraint();\r\n}\r\nclass QueryOrderByValueConstraint extends QueryConstraint {\r\n    _apply(query) {\r\n        validateNoPreviousOrderByCall(query, 'orderByValue');\r\n        const newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);\r\n        validateQueryEndpoints(newParams);\r\n        return new QueryImpl(query._repo, query._path, newParams, \r\n        /*orderByCalled=*/ true);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that orders by value.\r\n *\r\n * If the children of a query are all scalar values (string, number, or\r\n * boolean), you can order the results by their (ascending) values.\r\n *\r\n * You can read more about `orderByValue()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */\r\nfunction orderByValue() {\r\n    return new QueryOrderByValueConstraint();\r\n}\r\nclass QueryEqualToValueConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('equalTo', this._value, query._path, false);\r\n        if (query._queryParams.hasStart()) {\r\n            throw new Error('equalTo: Starting point was already set (by another call to startAt/startAfter or ' +\r\n                'equalTo).');\r\n        }\r\n        if (query._queryParams.hasEnd()) {\r\n            throw new Error('equalTo: Ending point was already set (by another call to endAt/endBefore or ' +\r\n                'equalTo).');\r\n        }\r\n        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query));\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` that includes children that match the specified\r\n * value.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The optional key argument can be used to further limit the range of the\r\n * query. If it is specified, then children that have exactly the specified\r\n * value must also have exactly the specified key as their key name. This can be\r\n * used to filter result sets with many matches for the same value.\r\n *\r\n * You can read more about `equalTo()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to match for. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */\r\nfunction equalTo(value, key) {\r\n    validateKey('equalTo', 'key', key, true);\r\n    return new QueryEqualToValueConstraint(value, key);\r\n}\r\n/**\r\n * Creates a new immutable instance of `Query` that is extended to also include\r\n * additional query constraints.\r\n *\r\n * @param query - The Query instance to use as a base for the new constraints.\r\n * @param queryConstraints - The list of `QueryConstraint`s to apply.\r\n * @throws if any of the provided query constraints cannot be combined with the\r\n * existing or new constraints.\r\n */\r\nfunction query(query, ...queryConstraints) {\r\n    let queryImpl = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(query);\r\n    for (const constraint of queryConstraints) {\r\n        queryImpl = constraint._apply(queryImpl);\r\n    }\r\n    return queryImpl;\r\n}\r\n/**\r\n * Define reference constructor in various modules\r\n *\r\n * We are doing this here to avoid several circular\r\n * dependency issues\r\n */\r\nsyncPointSetReferenceConstructor(ReferenceImpl);\r\nsyncTreeSetReferenceConstructor(ReferenceImpl);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This variable is also defined in the firebase Node.js Admin SDK. Before\r\n * modifying this definition, consult the definition in:\r\n *\r\n * https://github.com/firebase/firebase-admin-node\r\n *\r\n * and make sure the two are consistent.\r\n */\r\nconst FIREBASE_DATABASE_EMULATOR_HOST_VAR = 'FIREBASE_DATABASE_EMULATOR_HOST';\r\n/**\r\n * Creates and caches `Repo` instances.\r\n */\r\nconst repos = {};\r\n/**\r\n * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).\r\n */\r\nlet useRestClient = false;\r\n/**\r\n * Update an existing `Repo` in place to point to a new host/port.\r\n */\r\nfunction repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {\r\n    repo.repoInfo_ = new RepoInfo(`${host}:${port}`, \r\n    /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams, \r\n    /*isUsingEmulator=*/ true);\r\n    if (tokenProvider) {\r\n        repo.authTokenProvider_ = tokenProvider;\r\n    }\r\n}\r\n/**\r\n * This function should only ever be called to CREATE a new database instance.\r\n * @internal\r\n */\r\nfunction repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {\r\n    let dbUrl = url || app.options.databaseURL;\r\n    if (dbUrl === undefined) {\r\n        if (!app.options.projectId) {\r\n            fatal(\"Can't determine Firebase Database URL. Be sure to include \" +\r\n                ' a Project ID when calling firebase.initializeApp().');\r\n        }\r\n        log('Using default host for project ', app.options.projectId);\r\n        dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;\r\n    }\r\n    let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\r\n    let repoInfo = parsedUrl.repoInfo;\r\n    let isEmulator;\r\n    let dbEmulatorHost = undefined;\r\n    if (typeof process !== 'undefined' && process.env) {\r\n        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];\r\n    }\r\n    if (dbEmulatorHost) {\r\n        isEmulator = true;\r\n        dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;\r\n        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\r\n        repoInfo = parsedUrl.repoInfo;\r\n    }\r\n    else {\r\n        isEmulator = !parsedUrl.repoInfo.secure;\r\n    }\r\n    const authTokenProvider = nodeAdmin && isEmulator\r\n        ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)\r\n        : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);\r\n    validateUrl('Invalid Firebase Database URL', parsedUrl);\r\n    if (!pathIsEmpty(parsedUrl.path)) {\r\n        fatal('Database URL must point to the root of a Firebase Database ' +\r\n            '(not including a child path).');\r\n    }\r\n    const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));\r\n    return new Database(repo, app);\r\n}\r\n/**\r\n * Remove the repo and make sure it is disconnected.\r\n *\r\n */\r\nfunction repoManagerDeleteRepo(repo, appName) {\r\n    const appRepos = repos[appName];\r\n    // This should never happen...\r\n    if (!appRepos || appRepos[repo.key] !== repo) {\r\n        fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);\r\n    }\r\n    repoInterrupt(repo);\r\n    delete appRepos[repo.key];\r\n}\r\n/**\r\n * Ensures a repo doesn't already exist and then creates one using the\r\n * provided app.\r\n *\r\n * @param repoInfo - The metadata about the Repo\r\n * @returns The Repo object for the specified server / repoName.\r\n */\r\nfunction repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {\r\n    let appRepos = repos[app.name];\r\n    if (!appRepos) {\r\n        appRepos = {};\r\n        repos[app.name] = appRepos;\r\n    }\r\n    let repo = appRepos[repoInfo.toURLString()];\r\n    if (repo) {\r\n        fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');\r\n    }\r\n    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);\r\n    appRepos[repoInfo.toURLString()] = repo;\r\n    return repo;\r\n}\r\n/**\r\n * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\r\n */\r\nfunction repoManagerForceRestClient(forceRestClient) {\r\n    useRestClient = forceRestClient;\r\n}\r\n/**\r\n * Class representing a Firebase Realtime Database.\r\n */\r\nclass Database {\r\n    /** @hideconstructor */\r\n    constructor(_repoInternal, \r\n    /** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */\r\n    app) {\r\n        this._repoInternal = _repoInternal;\r\n        this.app = app;\r\n        /** Represents a `Database` instance. */\r\n        this['type'] = 'database';\r\n        /** Track if the instance has been used (root or repo accessed) */\r\n        this._instanceStarted = false;\r\n    }\r\n    get _repo() {\r\n        if (!this._instanceStarted) {\r\n            repoStart(this._repoInternal, this.app.options.appId, this.app.options['databaseAuthVariableOverride']);\r\n            this._instanceStarted = true;\r\n        }\r\n        return this._repoInternal;\r\n    }\r\n    get _root() {\r\n        if (!this._rootInternal) {\r\n            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());\r\n        }\r\n        return this._rootInternal;\r\n    }\r\n    _delete() {\r\n        if (this._rootInternal !== null) {\r\n            repoManagerDeleteRepo(this._repo, this.app.name);\r\n            this._repoInternal = null;\r\n            this._rootInternal = null;\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _checkNotDeleted(apiName) {\r\n        if (this._rootInternal === null) {\r\n            fatal('Cannot call ' + apiName + ' on a deleted database.');\r\n        }\r\n    }\r\n}\r\nfunction checkTransportInit() {\r\n    if (TransportManager.IS_TRANSPORT_INITIALIZED) {\r\n        warn('Transport has already been initialized. Please call this function before calling ref or setting up a listener');\r\n    }\r\n}\r\n/**\r\n * Force the use of websockets instead of longPolling.\r\n */\r\nfunction forceWebSockets() {\r\n    checkTransportInit();\r\n    BrowserPollConnection.forceDisallow();\r\n}\r\n/**\r\n * Force the use of longPolling instead of websockets. This will be ignored if websocket protocol is used in databaseURL.\r\n */\r\nfunction forceLongPolling() {\r\n    checkTransportInit();\r\n    WebSocketConnection.forceDisallow();\r\n    BrowserPollConnection.forceAllow();\r\n}\r\n/**\r\n * Returns the instance of the Realtime Database SDK that is associated\r\n * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with\r\n * with default settings if no instance exists or if the existing instance uses\r\n * a custom database URL.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime\r\n * Database instance is associated with.\r\n * @param url - The URL of the Realtime Database instance to connect to. If not\r\n * provided, the SDK connects to the default instance of the Firebase App.\r\n * @returns The `Database` instance of the provided app.\r\n */\r\nfunction getDatabase(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(), url) {\r\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'database').getImmediate({\r\n        identifier: url\r\n    });\r\n    if (!db._instanceStarted) {\r\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultEmulatorHostnameAndPort)('database');\r\n        if (emulator) {\r\n            connectDatabaseEmulator(db, ...emulator);\r\n        }\r\n    }\r\n    return db;\r\n}\r\n/**\r\n * Modify the provided instance to communicate with the Realtime Database\r\n * emulator.\r\n *\r\n * <p>Note: This method must be called before performing any other operation.\r\n *\r\n * @param db - The instance to modify.\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 8080)\r\n * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules\r\n */\r\nfunction connectDatabaseEmulator(db, host, port, options = {}) {\r\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);\r\n    db._checkNotDeleted('useEmulator');\r\n    if (db._instanceStarted) {\r\n        fatal('Cannot call useEmulator() after instance has already been initialized.');\r\n    }\r\n    const repo = db._repoInternal;\r\n    let tokenProvider = undefined;\r\n    if (repo.repoInfo_.nodeAdmin) {\r\n        if (options.mockUserToken) {\r\n            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the \"firebase\" package instead of \"firebase-admin\".');\r\n        }\r\n        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);\r\n    }\r\n    else if (options.mockUserToken) {\r\n        const token = typeof options.mockUserToken === 'string'\r\n            ? options.mockUserToken\r\n            : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.createMockUserToken)(options.mockUserToken, db.app.options.projectId);\r\n        tokenProvider = new EmulatorTokenProvider(token);\r\n    }\r\n    // Modify the repo to apply emulator settings\r\n    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);\r\n}\r\n/**\r\n * Disconnects from the server (all Database operations will be completed\r\n * offline).\r\n *\r\n * The client automatically maintains a persistent connection to the Database\r\n * server, which will remain active indefinitely and reconnect when\r\n * disconnected. However, the `goOffline()` and `goOnline()` methods may be used\r\n * to control the client connection in cases where a persistent connection is\r\n * undesirable.\r\n *\r\n * While offline, the client will no longer receive data updates from the\r\n * Database. However, all Database operations performed locally will continue to\r\n * immediately fire events, allowing your application to continue behaving\r\n * normally. Additionally, each operation performed locally will automatically\r\n * be queued and retried upon reconnection to the Database server.\r\n *\r\n * To reconnect to the Database and begin receiving remote events, see\r\n * `goOnline()`.\r\n *\r\n * @param db - The instance to disconnect.\r\n */\r\nfunction goOffline(db) {\r\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);\r\n    db._checkNotDeleted('goOffline');\r\n    repoInterrupt(db._repo);\r\n}\r\n/**\r\n * Reconnects to the server and synchronizes the offline Database state\r\n * with the server state.\r\n *\r\n * This method should be used after disabling the active connection with\r\n * `goOffline()`. Once reconnected, the client will transmit the proper data\r\n * and fire the appropriate events so that your client \"catches up\"\r\n * automatically.\r\n *\r\n * @param db - The instance to reconnect.\r\n */\r\nfunction goOnline(db) {\r\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(db);\r\n    db._checkNotDeleted('goOnline');\r\n    repoResume(db._repo);\r\n}\r\nfunction enableLogging(logger, persistent) {\r\n    enableLogging$1(logger, persistent);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerDatabase(variant) {\r\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('database', (container, { instanceIdentifier: url }) => {\r\n        const app = container.getProvider('app').getImmediate();\r\n        const authProvider = container.getProvider('auth-internal');\r\n        const appCheckProvider = container.getProvider('app-check-internal');\r\n        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */).setMultipleInstances(true));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst SERVER_TIMESTAMP = {\r\n    '.sv': 'timestamp'\r\n};\r\n/**\r\n * Returns a placeholder value for auto-populating the current timestamp (time\r\n * since the Unix epoch, in milliseconds) as determined by the Firebase\r\n * servers.\r\n */\r\nfunction serverTimestamp() {\r\n    return SERVER_TIMESTAMP;\r\n}\r\n/**\r\n * Returns a placeholder value that can be used to atomically increment the\r\n * current database value by the provided delta.\r\n *\r\n * @param delta - the amount to modify the current value atomically.\r\n * @returns A placeholder value for modifying data atomically server-side.\r\n */\r\nfunction increment(delta) {\r\n    return {\r\n        '.sv': {\r\n            'increment': delta\r\n        }\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A type for the resolve value of {@link runTransaction}.\r\n */\r\nclass TransactionResult {\r\n    /** @hideconstructor */\r\n    constructor(\r\n    /** Whether the transaction was successfully committed. */\r\n    committed, \r\n    /** The resulting data snapshot. */\r\n    snapshot) {\r\n        this.committed = committed;\r\n        this.snapshot = snapshot;\r\n    }\r\n    /** Returns a JSON-serializable representation of this object. */\r\n    toJSON() {\r\n        return { committed: this.committed, snapshot: this.snapshot.toJSON() };\r\n    }\r\n}\r\n/**\r\n * Atomically modifies the data at this location.\r\n *\r\n * Atomically modify the data at this location. Unlike a normal `set()`, which\r\n * just overwrites the data regardless of its previous value, `runTransaction()` is\r\n * used to modify the existing value to a new value, ensuring there are no\r\n * conflicts with other clients writing to the same location at the same time.\r\n *\r\n * To accomplish this, you pass `runTransaction()` an update function which is\r\n * used to transform the current value into a new value. If another client\r\n * writes to the location before your new value is successfully written, your\r\n * update function will be called again with the new current value, and the\r\n * write will be retried. This will happen repeatedly until your write succeeds\r\n * without conflict or you abort the transaction by not returning a value from\r\n * your update function.\r\n *\r\n * Note: Modifying data with `set()` will cancel any pending transactions at\r\n * that location, so extreme care should be taken if mixing `set()` and\r\n * `runTransaction()` to update the same data.\r\n *\r\n * Note: When using transactions with Security and Firebase Rules in place, be\r\n * aware that a client needs `.read` access in addition to `.write` access in\r\n * order to perform a transaction. This is because the client-side nature of\r\n * transactions requires the client to read the data in order to transactionally\r\n * update it.\r\n *\r\n * @param ref - The location to atomically modify.\r\n * @param transactionUpdate - A developer-supplied function which will be passed\r\n * the current data stored at this location (as a JavaScript object). The\r\n * function should return the new value it would like written (as a JavaScript\r\n * object). If `undefined` is returned (i.e. you return with no arguments) the\r\n * transaction will be aborted and the data at this location will not be\r\n * modified.\r\n * @param options - An options object to configure transactions.\r\n * @returns A `Promise` that can optionally be used instead of the `onComplete`\r\n * callback to handle success and failure.\r\n */\r\nfunction runTransaction(ref, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\ntransactionUpdate, options) {\r\n    var _a;\r\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(ref);\r\n    validateWritablePath('Reference.transaction', ref._path);\r\n    if (ref.key === '.length' || ref.key === '.keys') {\r\n        throw ('Reference.transaction failed: ' + ref.key + ' is a read-only object.');\r\n    }\r\n    const applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;\r\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n    const promiseComplete = (error, committed, node) => {\r\n        let dataSnapshot = null;\r\n        if (error) {\r\n            deferred.reject(error);\r\n        }\r\n        else {\r\n            dataSnapshot = new DataSnapshot(node, new ReferenceImpl(ref._repo, ref._path), PRIORITY_INDEX);\r\n            deferred.resolve(new TransactionResult(committed, dataSnapshot));\r\n        }\r\n    };\r\n    // Add a watch to make sure we get server updates.\r\n    const unwatcher = onValue(ref, () => { });\r\n    repoStartTransaction(ref._repo, ref._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);\r\n    return deferred.promise;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nPersistentConnection;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nPersistentConnection.prototype.simpleListen = function (pathString, onComplete) {\r\n    this.sendRequest('q', { p: pathString }, onComplete);\r\n};\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nPersistentConnection.prototype.echo = function (data, onEcho) {\r\n    this.sendRequest('echo', { d: data }, onEcho);\r\n};\r\n// RealTimeConnection properties that we use in tests.\r\nConnection;\r\n/**\r\n * @internal\r\n */\r\nconst hijackHash = function (newHash) {\r\n    const oldPut = PersistentConnection.prototype.put;\r\n    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {\r\n        if (hash !== undefined) {\r\n            hash = newHash();\r\n        }\r\n        oldPut.call(this, pathString, data, onComplete, hash);\r\n    };\r\n    return function () {\r\n        PersistentConnection.prototype.put = oldPut;\r\n    };\r\n};\r\nRepoInfo;\r\n/**\r\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\r\n * @internal\r\n */\r\nconst forceRestClient = function (forceRestClient) {\r\n    repoManagerForceRestClient(forceRestClient);\r\n};\n\n/**\r\n * Firebase Realtime Database\r\n *\r\n * @packageDocumentation\r\n */\r\nregisterDatabase();\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdIO0FBQ3hFO0FBQ3dUO0FBQ3BUOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHlEQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQixpRUFBaUI7QUFDdkMscUJBQXFCLGdEQUFJO0FBQ3pCO0FBQ0E7QUFDQSxXQUFXLGtFQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBLDZCQUE2Qiw4REFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx5REFBUztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILGdCQUFnQjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsY0FBYztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxrQkFBa0IsU0FBUyxFQUFFLFVBQVUsR0FBRyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVixJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFDQUFxQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5REFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlCQUFpQixHQUFHLFlBQVksR0FBRyxpQkFBaUIsR0FBRyxPQUFPO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxlQUFlO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxHQUFHLFFBQVEsR0FBRztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3REFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWEsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0RBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlCQUF5QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZCQUE2QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRCxnQ0FBZ0MsNERBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsa0RBQWtEO0FBQ2xEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCLHlEQUFTO0FBQzNCLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2QsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNEQUFzRCx3REFBUTtBQUM5RDtBQUNBLDZCQUE2Qix1REFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1REFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2REFBYTtBQUM1QyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4QkFBOEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseURBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBZTtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCLDZEQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOERBQWM7QUFDNUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBLHdDQUF3Qyx3REFBUTtBQUNoRDtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2QsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkIsSUFBSSw2QkFBNkI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBUTtBQUN2QjtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBRztBQUM5QiwwQkFBMEIsdURBQU87QUFDakMsWUFBWSxzREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsNkJBQTZCLElBQUksNkJBQTZCO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBLHdEQUF3RCx5REFBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBUztBQUNsQztBQUNBLG9DQUFvQyx5REFBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQVM7QUFDaEM7QUFDQSxrQ0FBa0MseURBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3REFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3REFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBTTtBQUNsQix5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxzREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVEQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhEQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOERBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOERBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZCxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBLElBQUksc0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWSxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQU87QUFDakMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbURBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtREFBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5Q0FBeUMseURBQVM7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUErQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSx1REFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFRO0FBQ3BCO0FBQ0EsOEJBQThCLHVEQUFPO0FBQ3JDLFlBQVksc0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLGNBQWMsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQVE7QUFDckMsc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9EQUFRO0FBQ3JDLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBUTtBQUNyQywwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQVE7QUFDckMsZ0hBQWdIO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBUTtBQUNyQyw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrRUFBa0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNIQUFzSDtBQUM5SCxRQUFRLG1JQUFtSTtBQUMzSTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBLHlCQUF5QixvREFBUTtBQUNqQztBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQVE7QUFDakMscUhBQXFIO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRO0FBQ2pDLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMklBQTJJO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRO0FBQ2pDLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBa0I7QUFDOUIseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRSxJQUFJLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRztBQUM1RCxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUI7QUFDM0QsSUFBSSxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDdEUsSUFBSSxxQkFBcUIsSUFBSSxlQUFlO0FBQzVDLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtHQUFrRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0dBQWtHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrR0FBa0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrR0FBa0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUksd0ZBQXdGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RkFBd0Y7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0ZBQXdGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0dBQWtHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUssR0FBRyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxNQUFNLG1CQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRLEdBQUcsZUFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFNO0FBQ2pDLGVBQWUsMkRBQVk7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsaUZBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsU0FBUyxrRUFBa0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrRUFBa0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrRUFBa0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQWE7QUFDL0IsSUFBSSxpRUFBa0IsS0FBSywwREFBUywyQkFBMkIseUJBQXlCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksOERBQWU7QUFDbkI7QUFDQSxJQUFJLDhEQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTI0QjtBQUMzNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYS4vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvaW5kZXguZXNtMjAxNy5qcz81MWIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBTREtfVkVSU0lPTiBhcyBTREtfVkVSU0lPTiQxLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBzdHJpbmdpZnksIGpzb25FdmFsLCBjb250YWlucywgYXNzZXJ0LCBpc05vZGVTZGssIHN0cmluZ1RvQnl0ZUFycmF5LCBTaGExLCBiYXNlNjQsIGRlZXBDb3B5LCBiYXNlNjRFbmNvZGUsIGlzTW9iaWxlQ29yZG92YSwgc3RyaW5nTGVuZ3RoLCBEZWZlcnJlZCwgc2FmZUdldCwgaXNBZG1pbiwgaXNWYWxpZEZvcm1hdCwgaXNFbXB0eSwgaXNSZWFjdE5hdGl2ZSwgYXNzZXJ0aW9uRXJyb3IsIG1hcCwgcXVlcnlzdHJpbmcsIGVycm9yUHJlZml4LCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgY3JlYXRlTW9ja1VzZXJUb2tlbiB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL2RhdGFiYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIwLjE0LjRcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFRoZSBzZW12ZXIgKHd3dy5zZW12ZXIub3JnKSB2ZXJzaW9uIG9mIHRoZSBTREsuICovXHJcbmxldCBTREtfVkVSU0lPTiA9ICcnO1xyXG4vKipcclxuICogU0RLX1ZFUlNJT04gc2hvdWxkIGJlIHNldCBiZWZvcmUgYW55IGRhdGFiYXNlIGluc3RhbmNlIGlzIGNyZWF0ZWRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRTREtWZXJzaW9uKHZlcnNpb24pIHtcclxuICAgIFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogV3JhcHMgYSBET00gU3RvcmFnZSBvYmplY3QgYW5kOlxyXG4gKiAtIGF1dG9tYXRpY2FsbHkgZW5jb2RlIG9iamVjdHMgYXMgSlNPTiBzdHJpbmdzIGJlZm9yZSBzdG9yaW5nIHRoZW0gdG8gYWxsb3cgdXMgdG8gc3RvcmUgYXJiaXRyYXJ5IHR5cGVzLlxyXG4gKiAtIHByZWZpeGVzIG5hbWVzIHdpdGggXCJmaXJlYmFzZTpcIiB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggYXBwIGRhdGEuXHJcbiAqXHJcbiAqIFdlIGF1dG9tYXRpY2FsbHkgKHNlZSBzdG9yYWdlLmpzKSBjcmVhdGUgdHdvIHN1Y2ggd3JhcHBlcnMsIG9uZSBmb3Igc2Vzc2lvblN0b3JhZ2UsXHJcbiAqIGFuZCBvbmUgZm9yIGxvY2FsU3RvcmFnZS5cclxuICpcclxuICovXHJcbmNsYXNzIERPTVN0b3JhZ2VXcmFwcGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGRvbVN0b3JhZ2VfIC0gVGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3QgKGUuZy4gbG9jYWxTdG9yYWdlIG9yIHNlc3Npb25TdG9yYWdlKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihkb21TdG9yYWdlXykge1xyXG4gICAgICAgIHRoaXMuZG9tU3RvcmFnZV8gPSBkb21TdG9yYWdlXztcclxuICAgICAgICAvLyBVc2UgYSBwcmVmaXggdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIG90aGVyIHN0dWZmIHNhdmVkIGJ5IHRoZSBhcHAuXHJcbiAgICAgICAgdGhpcy5wcmVmaXhfID0gJ2ZpcmViYXNlOic7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNhdmUgdGhlIHZhbHVlIHVuZGVyXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgYmVpbmcgc3RvcmVkLCBvciBudWxsIHRvIHJlbW92ZSB0aGUga2V5LlxyXG4gICAgICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnNldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSksIHN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIHRoYXQgd2FzIHN0b3JlZCB1bmRlciB0aGlzIGtleSwgb3IgbnVsbFxyXG4gICAgICovXHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVmFsID0gdGhpcy5kb21TdG9yYWdlXy5nZXRJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgICAgICBpZiAoc3RvcmVkVmFsID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ganNvbkV2YWwoc3RvcmVkVmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5yZW1vdmVJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgIH1cclxuICAgIHByZWZpeGVkTmFtZV8obmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpeF8gKyBuYW1lO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tU3RvcmFnZV8udG9TdHJpbmcoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gdGhhdCBtYXRjaGVzIHRoZSBBUEkgb2YgRE9NU3RvcmFnZVdyYXBwZXJcclxuICogKFRPRE86IGNyZWF0ZSBpbnRlcmZhY2UgZm9yIGJvdGggdG8gaW1wbGVtZW50KS5cclxuICovXHJcbmNsYXNzIE1lbW9yeVN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZV8gPSB7fTtcclxuICAgICAgICB0aGlzLmlzSW5NZW1vcnlTdG9yYWdlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlX1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGlmIChjb250YWlucyh0aGlzLmNhY2hlXywga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBET01TdG9yYWdlV3JhcHBlciBvciBlbHNlIGZhbGwgYmFjayB0byBNZW1vcnlTdG9yYWdlLlxyXG4gKiBUT0RPOiBPbmNlIE1lbW9yeVN0b3JhZ2UgYW5kIERPTVN0b3JhZ2VXcmFwcGVyIGhhdmUgYSBzaGFyZWQgaW50ZXJmYWNlIHRoaXMgbWV0aG9kIGFubm90YXRpb24gc2hvdWxkIGNoYW5nZVxyXG4gKiB0byByZWZsZWN0IHRoaXMgdHlwZVxyXG4gKlxyXG4gKiBAcGFyYW0gZG9tU3RvcmFnZU5hbWUgLSBOYW1lIG9mIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugb2JqZWN0XHJcbiAqICAgKGUuZy4gJ2xvY2FsU3RvcmFnZScgb3IgJ3Nlc3Npb25TdG9yYWdlJykuXHJcbiAqIEByZXR1cm5zIFR1cm5pbmcgb2ZmIHR5cGUgaW5mb3JtYXRpb24gdW50aWwgYSBjb21tb24gaW50ZXJmYWNlIGlzIGRlZmluZWQuXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVTdG9yYWdlZm9yID0gZnVuY3Rpb24gKGRvbVN0b3JhZ2VOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIE5PVEU6IGp1c3QgYWNjZXNzaW5nIFwibG9jYWxTdG9yYWdlXCIgb3IgXCJ3aW5kb3dbJ2xvY2FsU3RvcmFnZSddXCIgbWF5IHRocm93IGEgc2VjdXJpdHkgZXhjZXB0aW9uLFxyXG4gICAgICAgIC8vIHNvIGl0IG11c3QgYmUgaW5zaWRlIHRoZSB0cnkvY2F0Y2guXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBOZWVkIHRvIHRlc3QgY2FjaGUuIEp1c3QgYmVjYXVzZSBpdCdzIGhlcmUgZG9lc24ndCBtZWFuIGl0IHdvcmtzXHJcbiAgICAgICAgICAgIGNvbnN0IGRvbVN0b3JhZ2UgPSB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdO1xyXG4gICAgICAgICAgICBkb21TdG9yYWdlLnNldEl0ZW0oJ2ZpcmViYXNlOnNlbnRpbmVsJywgJ2NhY2hlJyk7XHJcbiAgICAgICAgICAgIGRvbVN0b3JhZ2UucmVtb3ZlSXRlbSgnZmlyZWJhc2U6c2VudGluZWwnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBET01TdG9yYWdlV3JhcHBlcihkb21TdG9yYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAvLyBGYWlsZWQgdG8gY3JlYXRlIHdyYXBwZXIuICBKdXN0IHJldHVybiBpbi1tZW1vcnkgc3RvcmFnZS5cclxuICAgIC8vIFRPRE86IGxvZz9cclxuICAgIHJldHVybiBuZXcgTWVtb3J5U3RvcmFnZSgpO1xyXG59O1xyXG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IGxhc3RzIGFjcm9zcyBzZXNzaW9ucyAqL1xyXG5jb25zdCBQZXJzaXN0ZW50U3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ2xvY2FsU3RvcmFnZScpO1xyXG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IG9ubHkgbGFzdHMgb25lIHNlc3Npb24gKi9cclxuY29uc3QgU2Vzc2lvblN0b3JhZ2UgPSBjcmVhdGVTdG9yYWdlZm9yKCdzZXNzaW9uU3RvcmFnZScpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZGF0YWJhc2UnKTtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBsb2NhbGx5LXVuaXF1ZSBJRCAoZ2VuZXJhdGVkIGJ5IGp1c3QgaW5jcmVtZW50aW5nIHVwIGZyb20gMCBlYWNoIHRpbWUgaXRzIGNhbGxlZCkuXHJcbiAqL1xyXG5jb25zdCBMVUlER2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGxldCBpZCA9IDE7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBpZCsrO1xyXG4gICAgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIFNoYTEgaGFzaCBvZiB0aGUgaW5wdXQgc3RyaW5nXHJcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIGhhc2hcclxuICogQHJldHVybnMgeyFzdHJpbmd9IFRoZSByZXN1bHRpbmcgaGFzaFxyXG4gKi9cclxuY29uc3Qgc2hhMSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5KHN0cik7XHJcbiAgICBjb25zdCBzaGExID0gbmV3IFNoYTEoKTtcclxuICAgIHNoYTEudXBkYXRlKHV0ZjhCeXRlcyk7XHJcbiAgICBjb25zdCBzaGExQnl0ZXMgPSBzaGExLmRpZ2VzdCgpO1xyXG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkoc2hhMUJ5dGVzKTtcclxufTtcclxuY29uc3QgYnVpbGRMb2dNZXNzYWdlXyA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJBcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJnID0gdmFyQXJnc1tpXTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpIHx8XHJcbiAgICAgICAgICAgIChhcmcgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZy5sZW5ndGggPT09ICdudW1iZXInKSkge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkobnVsbCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBzdHJpbmdpZnkoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYXJnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXNzYWdlICs9ICcgJztcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59O1xyXG4vKipcclxuICogVXNlIHRoaXMgZm9yIGFsbCBkZWJ1ZyBtZXNzYWdlcyBpbiBGaXJlYmFzZS5cclxuICovXHJcbmxldCBsb2dnZXIgPSBudWxsO1xyXG4vKipcclxuICogRmxhZyB0byBjaGVjayBmb3IgbG9nIGF2YWlsYWJpbGl0eSBvbiBmaXJzdCBsb2cgbWVzc2FnZVxyXG4gKi9cclxubGV0IGZpcnN0TG9nXyA9IHRydWU7XHJcbi8qKlxyXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgRmlyZWJhc2UuZW5hYmxlTG9nZ2luZyAoZGVmaW5lZCBoZXJlIHRvIGJyZWFrIGRlcGVuZGVuY2llcylcclxuICogQHBhcmFtIGxvZ2dlcl8gLSBBIGZsYWcgdG8gdHVybiBvbiBsb2dnaW5nLCBvciBhIGN1c3RvbSBsb2dnZXJcclxuICogQHBhcmFtIHBlcnNpc3RlbnQgLSBXaGV0aGVyIG9yIG5vdCB0byBwZXJzaXN0IGxvZ2dpbmcgc2V0dGluZ3MgYWNyb3NzIHJlZnJlc2hlc1xyXG4gKi9cclxuY29uc3QgZW5hYmxlTG9nZ2luZyQxID0gZnVuY3Rpb24gKGxvZ2dlcl8sIHBlcnNpc3RlbnQpIHtcclxuICAgIGFzc2VydCghcGVyc2lzdGVudCB8fCBsb2dnZXJfID09PSB0cnVlIHx8IGxvZ2dlcl8gPT09IGZhbHNlLCBcIkNhbid0IHR1cm4gb24gY3VzdG9tIGxvZ2dlcnMgcGVyc2lzdGVudGx5LlwiKTtcclxuICAgIGlmIChsb2dnZXJfID09PSB0cnVlKSB7XHJcbiAgICAgICAgbG9nQ2xpZW50LmxvZ0xldmVsID0gTG9nTGV2ZWwuVkVSQk9TRTtcclxuICAgICAgICBsb2dnZXIgPSBsb2dDbGllbnQubG9nLmJpbmQobG9nQ2xpZW50KTtcclxuICAgICAgICBpZiAocGVyc2lzdGVudCkge1xyXG4gICAgICAgICAgICBTZXNzaW9uU3RvcmFnZS5zZXQoJ2xvZ2dpbmdfZW5hYmxlZCcsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBsb2dnZXJfID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgbG9nZ2VyID0gbG9nZ2VyXztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxvZ2dlciA9IG51bGw7XHJcbiAgICAgICAgU2Vzc2lvblN0b3JhZ2UucmVtb3ZlKCdsb2dnaW5nX2VuYWJsZWQnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgbG9nID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGlmIChmaXJzdExvZ18gPT09IHRydWUpIHtcclxuICAgICAgICBmaXJzdExvZ18gPSBmYWxzZTtcclxuICAgICAgICBpZiAobG9nZ2VyID09PSBudWxsICYmIFNlc3Npb25TdG9yYWdlLmdldCgnbG9nZ2luZ19lbmFibGVkJykgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgZW5hYmxlTG9nZ2luZyQxKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsb2dnZXIpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRMb2dNZXNzYWdlXy5hcHBseShudWxsLCB2YXJBcmdzKTtcclxuICAgICAgICBsb2dnZXIobWVzc2FnZSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGxvZ1dyYXBwZXIgPSBmdW5jdGlvbiAocHJlZml4KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgICAgICBsb2cocHJlZml4LCAuLi52YXJBcmdzKTtcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IGVycm9yID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnRklSRUJBU0UgSU5URVJOQUwgRVJST1I6ICcgKyBidWlsZExvZ01lc3NhZ2VfKC4uLnZhckFyZ3MpO1xyXG4gICAgbG9nQ2xpZW50LmVycm9yKG1lc3NhZ2UpO1xyXG59O1xyXG5jb25zdCBmYXRhbCA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gYEZJUkVCQVNFIEZBVEFMIEVSUk9SOiAke2J1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyl9YDtcclxuICAgIGxvZ0NsaWVudC5lcnJvcihtZXNzYWdlKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxufTtcclxuY29uc3Qgd2FybiA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gJ0ZJUkVCQVNFIFdBUk5JTkc6ICcgKyBidWlsZExvZ01lc3NhZ2VfKC4uLnZhckFyZ3MpO1xyXG4gICAgbG9nQ2xpZW50Lndhcm4obWVzc2FnZSk7XHJcbn07XHJcbi8qKlxyXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgY29udGFpbmluZyBwYWdlIHVzZXMgaHR0cHMuIENhbGxlZCB3aGVuIGEgY2FsbCB0byBuZXcgRmlyZWJhc2VcclxuICogZG9lcyBub3QgdXNlIGh0dHBzLlxyXG4gKi9cclxuY29uc3Qgd2FybklmUGFnZUlzU2VjdXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gQmUgdmVyeSBjYXJlZnVsIGFjY2Vzc2luZyBicm93c2VyIGdsb2JhbHMuIFdobyBrbm93cyB3aGF0IG1heSBvciBtYXkgbm90IGV4aXN0LlxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHBzOicpICE9PSAtMSkge1xyXG4gICAgICAgIHdhcm4oJ0luc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSBodHRwcyBpbiBjYWxscyB0byBuZXcgRmlyZWJhc2UoKS4nKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBkYXRhIGlzIE5hTiwgb3IgKy8tIEluZmluaXR5LlxyXG4gKi9cclxuY29uc3QgaXNJbnZhbGlkSlNPTk51bWJlciA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIChkYXRhICE9PSBkYXRhIHx8IC8vIE5hTlxyXG4gICAgICAgICAgICBkYXRhID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcclxuICAgICAgICAgICAgZGF0YSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSk7XHJcbn07XHJcbmNvbnN0IGV4ZWN1dGVXaGVuRE9NUmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIGlmIChpc05vZGVTZGsoKSB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgZm4oKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE1vZGVsZWQgYWZ0ZXIgalF1ZXJ5LiBUcnkgRE9NQ29udGVudExvYWRlZCBhbmQgb25yZWFkeXN0YXRlY2hhbmdlICh3aGljaFxyXG4gICAgICAgIC8vIGZpcmUgYmVmb3JlIG9ubG9hZCksIGJ1dCBmYWxsIGJhY2sgdG8gb25sb2FkLlxyXG4gICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh3cmFwcGVkRm4sIE1hdGguZmxvb3IoMTApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkRm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gb25sb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHdyYXBwZWRGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5hdHRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBJRS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgnb25sb2FkJywgd3JhcHBlZEZuKTtcclxuICAgICAgICAgICAgLy8galF1ZXJ5IGhhcyBhbiBleHRyYSBoYWNrIGZvciBJRSB0aGF0IHdlIGNvdWxkIGVtcGxveSAoYmFzZWQgb25cclxuICAgICAgICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC8pIEJ1dCBpdCBsb29rcyByZWFsbHkgb2xkLlxyXG4gICAgICAgICAgICAvLyBJJ20gaG9waW5nIHdlIGRvbid0IG5lZWQgaXQuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogTWluaW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBiZWZvcmUgYW55IHZhbGlkIG5hbWVzXHJcbiAqL1xyXG5jb25zdCBNSU5fTkFNRSA9ICdbTUlOX05BTUVdJztcclxuLyoqXHJcbiAqIE1heGltdW0ga2V5IG5hbWUuIEludmFsaWQgZm9yIGFjdHVhbCBkYXRhLCB1c2VkIGFzIGEgbWFya2VyIHRvIHNvcnQgYWJvdmUgYW55IHZhbGlkIG5hbWVzXHJcbiAqL1xyXG5jb25zdCBNQVhfTkFNRSA9ICdbTUFYX05BTUVdJztcclxuLyoqXHJcbiAqIENvbXBhcmVzIHZhbGlkIEZpcmViYXNlIGtleSBuYW1lcywgcGx1cyBtaW4gYW5kIG1heCBuYW1lXHJcbiAqL1xyXG5jb25zdCBuYW1lQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYSA9PT0gTUlOX05BTUUgfHwgYiA9PT0gTUFYX05BTUUpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiID09PSBNSU5fTkFNRSB8fCBhID09PSBNQVhfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgYUFzSW50ID0gdHJ5UGFyc2VJbnQoYSksIGJBc0ludCA9IHRyeVBhcnNlSW50KGIpO1xyXG4gICAgICAgIGlmIChhQXNJbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGJBc0ludCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFBc0ludCAtIGJBc0ludCA9PT0gMCA/IGEubGVuZ3RoIC0gYi5sZW5ndGggOiBhQXNJbnQgLSBiQXNJbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYkFzSW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEByZXR1cm5zIHshbnVtYmVyfSBjb21wYXJpc29uIHJlc3VsdC5cclxuICovXHJcbmNvbnN0IHN0cmluZ0NvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEgPCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHJlcXVpcmVLZXkgPSBmdW5jdGlvbiAoa2V5LCBvYmopIHtcclxuICAgIGlmIChvYmogJiYga2V5IGluIG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBrZXkgKCcgKyBrZXkgKyAnKSBpbiBvYmplY3Q6ICcgKyBzdHJpbmdpZnkob2JqKSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IE9iamVjdFRvVW5pcXVlS2V5ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkob2JqKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGtleXMgPSBbXTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcclxuICAgICAgICBrZXlzLnB1c2goayk7XHJcbiAgICB9XHJcbiAgICAvLyBFeHBvcnQgYXMganNvbiwgYnV0IHdpdGggdGhlIGtleXMgc29ydGVkLlxyXG4gICAga2V5cy5zb3J0KCk7XHJcbiAgICBsZXQga2V5ID0gJ3snO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgIT09IDApIHtcclxuICAgICAgICAgICAga2V5ICs9ICcsJztcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5ICs9IHN0cmluZ2lmeShrZXlzW2ldKTtcclxuICAgICAgICBrZXkgKz0gJzonO1xyXG4gICAgICAgIGtleSArPSBPYmplY3RUb1VuaXF1ZUtleShvYmpba2V5c1tpXV0pO1xyXG4gICAgfVxyXG4gICAga2V5ICs9ICd9JztcclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcbi8qKlxyXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhIG51bWJlciBvZiBzbWFsbGVyIHNlZ21lbnRzIG9mIG1heGltdW0gc2l6ZVxyXG4gKiBAcGFyYW0gc3RyIC0gVGhlIHN0cmluZ1xyXG4gKiBAcGFyYW0gc2Vnc2l6ZSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFycyBpbiB0aGUgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nLCBzcGxpdCBpbnRvIGFwcHJvcHJpYXRlbHktc2l6ZWQgY2h1bmtzXHJcbiAqL1xyXG5jb25zdCBzcGxpdFN0cmluZ0J5U2l6ZSA9IGZ1bmN0aW9uIChzdHIsIHNlZ3NpemUpIHtcclxuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICBpZiAobGVuIDw9IHNlZ3NpemUpIHtcclxuICAgICAgICByZXR1cm4gW3N0cl07XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhU2VncyA9IFtdO1xyXG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBsZW47IGMgKz0gc2Vnc2l6ZSkge1xyXG4gICAgICAgIGlmIChjICsgc2Vnc2l6ZSA+IGxlbikge1xyXG4gICAgICAgICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgbGVuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgYyArIHNlZ3NpemUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YVNlZ3M7XHJcbn07XHJcbi8qKlxyXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggKGtleSwgdmFsdWUpIHBhaXIgaW4gYW4gb2JqZWN0IG9yXHJcbiAqIGFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCAoaW5kZXgsIHZhbHVlKSBwYWlyIGluIGFuIGFycmF5XHJcbiAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcclxuICovXHJcbmZ1bmN0aW9uIGVhY2gob2JqLCBmbikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQm9ycm93ZWQgZnJvbSBodHRwOi8vaGcuc2Vjb25kbGlmZS5jb20vbGxzZC9zcmMvdGlwL2pzL3R5cGVkYXJyYXkuanMgKE1JVCBMaWNlbnNlKVxyXG4gKiBJIG1hZGUgb25lIG1vZGlmaWNhdGlvbiBhdCB0aGUgZW5kIGFuZCByZW1vdmVkIHRoZSBOYU4gLyBJbmZpbml0eVxyXG4gKiBoYW5kbGluZyAoc2luY2UgaXQgc2VlbWVkIGJyb2tlbiBbY2F1c2VkIGFuIG92ZXJmbG93XSBhbmQgd2UgZG9uJ3QgbmVlZCBpdCkuICBTZWUgTUpMIGNvbW1lbnRzLlxyXG4gKiBAcGFyYW0gdiAtIEEgZG91YmxlXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBkb3VibGVUb0lFRUU3NTRTdHJpbmcgPSBmdW5jdGlvbiAodikge1xyXG4gICAgYXNzZXJ0KCFpc0ludmFsaWRKU09OTnVtYmVyKHYpLCAnSW52YWxpZCBKU09OIG51bWJlcicpOyAvLyBNSkxcclxuICAgIGNvbnN0IGViaXRzID0gMTEsIGZiaXRzID0gNTI7XHJcbiAgICBjb25zdCBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMTtcclxuICAgIGxldCBzLCBlLCBmLCBsbiwgaTtcclxuICAgIC8vIENvbXB1dGUgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXHJcbiAgICAvLyBTa2lwIE5hTiAvIEluZmluaXR5IGhhbmRsaW5nIC0tTUpMLlxyXG4gICAgaWYgKHYgPT09IDApIHtcclxuICAgICAgICBlID0gMDtcclxuICAgICAgICBmID0gMDtcclxuICAgICAgICBzID0gMSAvIHYgPT09IC1JbmZpbml0eSA/IDEgOiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcyA9IHYgPCAwO1xyXG4gICAgICAgIHYgPSBNYXRoLmFicyh2KTtcclxuICAgICAgICBpZiAodiA+PSBNYXRoLnBvdygyLCAxIC0gYmlhcykpIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplZFxyXG4gICAgICAgICAgICBsbiA9IE1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2codikgLyBNYXRoLkxOMiksIGJpYXMpO1xyXG4gICAgICAgICAgICBlID0gbG4gKyBiaWFzO1xyXG4gICAgICAgICAgICBmID0gTWF0aC5yb3VuZCh2ICogTWF0aC5wb3coMiwgZmJpdHMgLSBsbikgLSBNYXRoLnBvdygyLCBmYml0cykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGVub3JtYWxpemVkXHJcbiAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICBmID0gTWF0aC5yb3VuZCh2IC8gTWF0aC5wb3coMiwgMSAtIGJpYXMgLSBmYml0cykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFBhY2sgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXHJcbiAgICBjb25zdCBiaXRzID0gW107XHJcbiAgICBmb3IgKGkgPSBmYml0czsgaTsgaSAtPSAxKSB7XHJcbiAgICAgICAgYml0cy5wdXNoKGYgJSAyID8gMSA6IDApO1xyXG4gICAgICAgIGYgPSBNYXRoLmZsb29yKGYgLyAyKTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IGViaXRzOyBpOyBpIC09IDEpIHtcclxuICAgICAgICBiaXRzLnB1c2goZSAlIDIgPyAxIDogMCk7XHJcbiAgICAgICAgZSA9IE1hdGguZmxvb3IoZSAvIDIpO1xyXG4gICAgfVxyXG4gICAgYml0cy5wdXNoKHMgPyAxIDogMCk7XHJcbiAgICBiaXRzLnJldmVyc2UoKTtcclxuICAgIGNvbnN0IHN0ciA9IGJpdHMuam9pbignJyk7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGRhdGEgYXMgYSBoZXggc3RyaW5nLiAtLU1KTFxyXG4gICAgbGV0IGhleEJ5dGVTdHJpbmcgPSAnJztcclxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSArPSA4KSB7XHJcbiAgICAgICAgbGV0IGhleEJ5dGUgPSBwYXJzZUludChzdHIuc3Vic3RyKGksIDgpLCAyKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgaWYgKGhleEJ5dGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGhleEJ5dGUgPSAnMCcgKyBoZXhCeXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoZXhCeXRlU3RyaW5nID0gaGV4Qnl0ZVN0cmluZyArIGhleEJ5dGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGV4Qnl0ZVN0cmluZy50b0xvd2VyQ2FzZSgpO1xyXG59O1xyXG4vKipcclxuICogVXNlZCB0byBkZXRlY3QgaWYgd2UncmUgaW4gYSBDaHJvbWUgY29udGVudCBzY3JpcHQgKHdoaWNoIGV4ZWN1dGVzIGluIGFuXHJcbiAqIGlzb2xhdGVkIGVudmlyb25tZW50IHdoZXJlIGxvbmctcG9sbGluZyBkb2Vzbid0IHdvcmspLlxyXG4gKi9cclxuY29uc3QgaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgd2luZG93WydjaHJvbWUnXSAmJlxyXG4gICAgICAgIHdpbmRvd1snY2hyb21lJ11bJ2V4dGVuc2lvbiddICYmXHJcbiAgICAgICAgIS9eY2hyb21lLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIFdpbmRvd3MgOCBTdG9yZSBhcHAuXHJcbiAqL1xyXG5jb25zdCBpc1dpbmRvd3NTdG9yZUFwcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIENoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBjb3VwbGUgV2luUlQgZ2xvYmFsc1xyXG4gICAgcmV0dXJuIHR5cGVvZiBXaW5kb3dzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2luZG93cy5VSSA9PT0gJ29iamVjdCc7XHJcbn07XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHNlcnZlciBlcnJvciBjb2RlIHRvIGEgSmF2YXNjcmlwdCBFcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gZXJyb3JGb3JTZXJ2ZXJDb2RlKGNvZGUsIHF1ZXJ5KSB7XHJcbiAgICBsZXQgcmVhc29uID0gJ1Vua25vd24gRXJyb3InO1xyXG4gICAgaWYgKGNvZGUgPT09ICd0b29fYmlnJykge1xyXG4gICAgICAgIHJlYXNvbiA9XHJcbiAgICAgICAgICAgICdUaGUgZGF0YSByZXF1ZXN0ZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplICcgK1xyXG4gICAgICAgICAgICAgICAgJ3RoYXQgY2FuIGJlIGFjY2Vzc2VkIHdpdGggYSBzaW5nbGUgcmVxdWVzdC4nO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgIHJlYXNvbiA9IFwiQ2xpZW50IGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgZGVzaXJlZCBkYXRhLlwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29kZSA9PT0gJ3VuYXZhaWxhYmxlJykge1xyXG4gICAgICAgIHJlYXNvbiA9ICdUaGUgc2VydmljZSBpcyB1bmF2YWlsYWJsZSc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihjb2RlICsgJyBhdCAnICsgcXVlcnkuX3BhdGgudG9TdHJpbmcoKSArICc6ICcgKyByZWFzb24pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGVycm9yLmNvZGUgPSBjb2RlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuLyoqXHJcbiAqIFVzZWQgdG8gdGVzdCBmb3IgaW50ZWdlci1sb29raW5nIHN0cmluZ3NcclxuICovXHJcbmNvbnN0IElOVEVHRVJfUkVHRVhQXyA9IG5ldyBSZWdFeHAoJ14tPygwKilcXFxcZHsxLDEwfSQnKTtcclxuLyoqXHJcbiAqIEZvciB1c2UgaW4ga2V5cywgdGhlIG1pbmltdW0gcG9zc2libGUgMzItYml0IGludGVnZXIuXHJcbiAqL1xyXG5jb25zdCBJTlRFR0VSXzMyX01JTiA9IC0yMTQ3NDgzNjQ4O1xyXG4vKipcclxuICogRm9yIHVzZSBpbiBreWVzLCB0aGUgbWF4aW11bSBwb3NzaWJsZSAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmNvbnN0IElOVEVHRVJfMzJfTUFYID0gMjE0NzQ4MzY0NztcclxuLyoqXHJcbiAqIElmIHRoZSBzdHJpbmcgY29udGFpbnMgYSAzMi1iaXQgaW50ZWdlciwgcmV0dXJuIGl0LiAgRWxzZSByZXR1cm4gbnVsbC5cclxuICovXHJcbmNvbnN0IHRyeVBhcnNlSW50ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgaWYgKElOVEVHRVJfUkVHRVhQXy50ZXN0KHN0cikpIHtcclxuICAgICAgICBjb25zdCBpbnRWYWwgPSBOdW1iZXIoc3RyKTtcclxuICAgICAgICBpZiAoaW50VmFsID49IElOVEVHRVJfMzJfTUlOICYmIGludFZhbCA8PSBJTlRFR0VSXzMyX01BWCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50VmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4vKipcclxuICogSGVscGVyIHRvIHJ1biBzb21lIGNvZGUgYnV0IGNhdGNoIGFueSBleGNlcHRpb25zIGFuZCByZS10aHJvdyB0aGVtIGxhdGVyLlxyXG4gKiBVc2VmdWwgZm9yIHByZXZlbnRpbmcgdXNlciBjYWxsYmFja3MgZnJvbSBicmVha2luZyBpbnRlcm5hbCBjb2RlLlxyXG4gKlxyXG4gKiBSZS10aHJvd2luZyB0aGUgZXhjZXB0aW9uIGZyb20gYSBzZXRUaW1lb3V0IGlzIGEgbGl0dGxlIGV2aWwsIGJ1dCBpdCdzIHZlcnlcclxuICogY29udmVuaWVudCAod2UgZG9uJ3QgaGF2ZSB0byB0cnkgdG8gZmlndXJlIG91dCB3aGVuIGlzIGEgc2FmZSBwb2ludCB0b1xyXG4gKiByZS10aHJvdyBpdCksIGFuZCB0aGUgYmVoYXZpb3Igc2VlbXMgcmVhc29uYWJsZTpcclxuICpcclxuICogKiBJZiB5b3UgYXJlbid0IHBhdXNpbmcgb24gZXhjZXB0aW9ucywgeW91IGdldCBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aXRoXHJcbiAqICAgdGhlIGNvcnJlY3Qgc3RhY2sgdHJhY2UuXHJcbiAqICogSWYgeW91J3JlIHBhdXNpbmcgb24gYWxsIGV4Y2VwdGlvbnMsIHRoZSBkZWJ1Z2dlciB3aWxsIHBhdXNlIG9uIHlvdXJcclxuICogICBleGNlcHRpb24gYW5kIHRoZW4gYWdhaW4gd2hlbiB3ZSByZXRocm93IGl0LlxyXG4gKiAqIElmIHlvdSdyZSBvbmx5IHBhdXNpbmcgb24gdW5jYXVnaHQgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgb25seSBwYXVzZVxyXG4gKiAgIG9uIHVzIHJlLXRocm93aW5nIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gZm4gLSBUaGUgY29kZSB0byBndWFyZC5cclxuICovXHJcbmNvbnN0IGV4Y2VwdGlvbkd1YXJkID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIFJlLXRocm93IGV4Y2VwdGlvbiB3aGVuIGl0J3Mgc2FmZS5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IFwidGhyb3cgZVwiIHdvdWxkIHJlc3VsdCBpbiBhIGdvb2QgY29uc29sZSBlcnJvciB3aXRoXHJcbiAgICAgICAgICAgIC8vIHJlbGV2YW50IGNvbnRleHQsIGJ1dCBhcyBvZiBDaHJvbWUgMzksIHlvdSBqdXN0IGdldCB0aGUgZmlyZWJhc2UuanNcclxuICAgICAgICAgICAgLy8gZmlsZS9saW5lIG51bWJlciB3aGVyZSB3ZSByZS10aHJvdyBpdCwgd2hpY2ggaXMgdXNlbGVzcy4gU28gd2UgbG9nXHJcbiAgICAgICAgICAgIC8vIGUuc3RhY2sgZXhwbGljaXRseS5cclxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBlLnN0YWNrIHx8ICcnO1xyXG4gICAgICAgICAgICB3YXJuKCdFeGNlcHRpb24gd2FzIHRocm93biBieSB1c2VyIGNhbGxiYWNrLicsIHN0YWNrKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHdlIHRoaW5rIHdlJ3JlIGN1cnJlbnRseSBiZWluZyBjcmF3bGVkLlxyXG4gKi9cclxuY29uc3QgYmVpbmdDcmF3bGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgdXNlckFnZW50ID0gKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgd2luZG93WyduYXZpZ2F0b3InXSAmJlxyXG4gICAgICAgIHdpbmRvd1snbmF2aWdhdG9yJ11bJ3VzZXJBZ2VudCddKSB8fFxyXG4gICAgICAgICcnO1xyXG4gICAgLy8gRm9yIG5vdyB3ZSB3aGl0ZWxpc3QgdGhlIG1vc3QgcG9wdWxhciBjcmF3bGVycy4gIFdlIHNob3VsZCByZWZpbmUgdGhpcyB0byBiZSB0aGUgc2V0IG9mIGNyYXdsZXJzIHdlXHJcbiAgICAvLyBiZWxpZXZlIHRvIHN1cHBvcnQgSmF2YVNjcmlwdC9BSkFYIHJlbmRlcmluZy5cclxuICAgIC8vIE5PVEU6IEdvb2dsZSBXZWJtYXN0ZXIgVG9vbHMgZG9lc24ndCByZWFsbHkgYmVsb25nLCBidXQgdGhlaXIgXCJUaGlzIGlzIGhvdyBhIHZpc2l0b3IgdG8geW91ciB3ZWJzaXRlXHJcbiAgICAvLyB3b3VsZCBoYXZlIHNlZW4gdGhlIHBhZ2VcIiBpcyBmbGFreSBpZiB3ZSBkb24ndCB0cmVhdCBpdCBhcyBhIGNyYXdsZXIuXHJcbiAgICByZXR1cm4gKHVzZXJBZ2VudC5zZWFyY2goL2dvb2dsZWJvdHxnb29nbGUgd2VibWFzdGVyIHRvb2xzfGJpbmdib3R8eWFob28hIHNsdXJwfGJhaWR1c3BpZGVyfHlhbmRleGJvdHxkdWNrZHVja2JvdC9pKSA+PSAwKTtcclxufTtcclxuLyoqXHJcbiAqIFNhbWUgYXMgc2V0VGltZW91dCgpIGV4Y2VwdCBvbiBOb2RlLkpTIGl0IHdpbGwgL25vdC8gcHJldmVudCB0aGUgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXHJcbiAqXHJcbiAqIEl0IGlzIHJlbW92ZWQgd2l0aCBjbGVhclRpbWVvdXQoKSBhcyBub3JtYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbiAtIEZ1bmN0aW9uIHRvIHJ1bi5cclxuICogQHBhcmFtIHRpbWUgLSBNaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcnVubmluZy5cclxuICogQHJldHVybnMgVGhlIHNldFRpbWVvdXQoKSByZXR1cm4gdmFsdWUuXHJcbiAqL1xyXG5jb25zdCBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcgPSBmdW5jdGlvbiAoZm4sIHRpbWUpIHtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCB0aW1lKTtcclxuICAgIC8vIE5vdGU6IGF0IHRoZSB0aW1lIG9mIHRoaXMgY29tbWVudCwgdW5yZWZUaW1lciBpcyB1bmRlciB0aGUgdW5zdGFibGUgc2V0IG9mIEFQSXMuIFJ1biB3aXRoIC0tdW5zdGFibGUgdG8gZW5hYmxlIHRoZSBBUEkuXHJcbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBJcyBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgdHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBEZW5vIGFuZCB1bnJlZlRpbWVyIGFyZSBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgRGVub1sndW5yZWZUaW1lciddKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBEZW5vIGFuZCB1bnJlZlRpbWVyIGFyZSBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpbWVvdXQpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ29iamVjdCcgJiYgdGltZW91dFsndW5yZWYnXSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdGltZW91dFsndW5yZWYnXSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRpbWVvdXQ7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgQXBwQ2hlY2sncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXBwTmFtZV8sIGFwcENoZWNrUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmFwcE5hbWVfID0gYXBwTmFtZV87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyID0gYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2tQcm92aWRlciA9PT0gbnVsbCB8fCBhcHBDaGVja1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICBhcHBDaGVja1Byb3ZpZGVyID09PSBudWxsIHx8IGFwcENoZWNrUHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrUHJvdmlkZXIuZ2V0KCkudGhlbihhcHBDaGVjayA9PiAodGhpcy5hcHBDaGVjayA9IGFwcENoZWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGRlbGF5ZWQgaW5pdGlhbGl6YXRpb24gb2YgRmlyZWJhc2VBcHBDaGVjay4gVGhpcyBhbGxvd3Mgb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBjdXN0b21lcnMgdG8gaW5pdGlhbGl6ZSB0aGUgUlREQiBTREsgYmVmb3JlIGluaXRpYWxpemluZyBGaXJlYmFzZVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwQ2hlY2sgYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjay5nZXRUb2tlbihmb3JjZVJlZnJlc2gpO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmFwcENoZWNrUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKS50aGVuKGFwcENoZWNrID0+IGFwcENoZWNrLmFkZFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICB3YXJuKGBQcm92aWRlZCBBcHBDaGVjayBjcmVkZW50aWFscyBmb3IgdGhlIGFwcCBuYW1lZCBcIiR7dGhpcy5hcHBOYW1lX31cIiBgICtcclxuICAgICAgICAgICAgJ2FyZSBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgaW5kaWNhdGVzIHlvdXIgYXBwIHdhcyBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5LicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgRmlyZWJhc2VBcHAncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcE5hbWVfLCBmaXJlYmFzZU9wdGlvbnNfLCBhdXRoUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5hcHBOYW1lXyA9IGFwcE5hbWVfO1xyXG4gICAgICAgIHRoaXMuZmlyZWJhc2VPcHRpb25zXyA9IGZpcmViYXNlT3B0aW9uc187XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfID0gYXV0aFByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmF1dGhfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhfID0gYXV0aFByb3ZpZGVyXy5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgYXV0aFByb3ZpZGVyXy5vbkluaXQoYXV0aCA9PiAodGhpcy5hdXRoXyA9IGF1dGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZGVsYXllZCBpbml0aWFsaXphdGlvbiBvZiBGaXJlYmFzZUF1dGguIFRoaXMgYWxsb3dzIG91clxyXG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tZXJzIHRvIGluaXRpYWxpemUgdGhlIFJUREIgU0RLIGJlZm9yZSBpbml0aWFsaXppbmcgRmlyZWJhc2VcclxuICAgICAgICAgICAgICAgIC8vIEF1dGggYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGFsbCB0aGUgY2FzZXMgdGhpcyBpcyByYWlzZWQgYW5kIHdoZXRoZXJcclxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBzZW5zZS5cclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCcpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnR290IGF1dGgvdG9rZW4tbm90LWluaXRpYWxpemVkIGVycm9yLiAgVHJlYXRpbmcgYXMgbnVsbCB0b2tlbi4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IHdhbnQgdG8gd3JhcCB0aGUgbGlzdGVuZXIgYW5kIGNhbGwgaXQgd2l0aCBubyBhcmdzIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgYSBsZWFreSBhYnN0cmFjdGlvbiwgYnV0IHRoYXQgbWFrZXMgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIGhhcmRlci5cclxuICAgICAgICBpZiAodGhpcy5hdXRoXykge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhfLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyX1xyXG4gICAgICAgICAgICAgICAgLmdldCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGguYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfXHJcbiAgICAgICAgICAgIC5nZXQoKVxyXG4gICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGgucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1Byb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGUgYXBwIG5hbWVkIFwiJyArXHJcbiAgICAgICAgICAgIHRoaXMuYXBwTmFtZV8gK1xyXG4gICAgICAgICAgICAnXCIgYXJlIGludmFsaWQuIFRoaXMgdXN1YWxseSBpbmRpY2F0ZXMgeW91ciBhcHAgd2FzIG5vdCAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkIGNvcnJlY3RseS4gJztcclxuICAgICAgICBpZiAoJ2NyZWRlbnRpYWwnIGluIHRoaXMuZmlyZWJhc2VPcHRpb25zXykge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz1cclxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwiY3JlZGVudGlhbFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2plY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmZpcmViYXNlT3B0aW9uc18pIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcInNlcnZpY2VBY2NvdW50XCIgcHJvcGVydHkgcHJvdmlkZWQgdG8gaW5pdGlhbGl6ZUFwcCgpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpcyBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIFwiZGF0YWJhc2VVUkxcIiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcImFwaUtleVwiIGFuZCBcImRhdGFiYXNlVVJMXCIgcHJvcGVydGllcyBwcm92aWRlZCB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbGl6ZUFwcCgpIG1hdGNoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgZm9yIHlvdXIgYXBwIGF0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS8uJztcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbi8qIEF1dGhUb2tlblByb3ZpZGVyIHRoYXQgc3VwcGxpZXMgYSBjb25zdGFudCB0b2tlbi4gVXNlZCBieSBBZG1pbiBTREsgb3IgbW9ja1VzZXJUb2tlbiB3aXRoIGVtdWxhdG9ycy4gKi9cclxuY2xhc3MgRW11bGF0b3JUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsaXN0ZW5lciBpbW1lZGlhdGVseSB0byBtYXRjaCB0aGUgYmVoYXZpb3IgaW4gRmlyZWJhc2UgQXV0aFxyXG4gICAgICAgIC8vIChzZWUgcGFja2FnZXMvYXV0aC9zcmMvYXV0aC5qcyNMMTgwNylcclxuICAgICAgICBsaXN0ZW5lcih0aGlzLmFjY2Vzc1Rva2VuKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHsgfVxyXG4gICAgbm90aWZ5Rm9ySW52YWxpZFRva2VuKCkgeyB9XHJcbn1cclxuLyoqIEEgc3RyaW5nIHRoYXQgaXMgdHJlYXRlZCBhcyBhbiBhZG1pbiBhY2Nlc3MgdG9rZW4gYnkgdGhlIFJUREIgZW11bGF0b3IuIFVzZWQgYnkgQWRtaW4gU0RLLiAqL1xyXG5FbXVsYXRvclRva2VuUHJvdmlkZXIuT1dORVIgPSAnb3duZXInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBQUk9UT0NPTF9WRVJTSU9OID0gJzUnO1xyXG5jb25zdCBWRVJTSU9OX1BBUkFNID0gJ3YnO1xyXG5jb25zdCBUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSA9ICdzJztcclxuY29uc3QgUkVGRVJFUl9QQVJBTSA9ICdyJztcclxuY29uc3QgRk9SR0VfUkVGID0gJ2YnO1xyXG4vLyBNYXRjaGVzIGNvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbSwgZmlyZWJhc2UtY29uc29sZS0qLmNvcnAuZ29vZ2xlLmNvbSBhbmRcclxuLy8gZmlyZWJhc2UuY29ycC5nb29nbGUuY29tXHJcbmNvbnN0IEZPUkdFX0RPTUFJTl9SRSA9IC8oY29uc29sZVxcLmZpcmViYXNlfGZpcmViYXNlLWNvbnNvbGUtXFx3K1xcLmNvcnB8ZmlyZWJhc2VcXC5jb3JwKVxcLmdvb2dsZVxcLmNvbS87XHJcbmNvbnN0IExBU1RfU0VTU0lPTl9QQVJBTSA9ICdscyc7XHJcbmNvbnN0IEFQUExJQ0FUSU9OX0lEX1BBUkFNID0gJ3AnO1xyXG5jb25zdCBBUFBfQ0hFQ0tfVE9LRU5fUEFSQU0gPSAnYWMnO1xyXG5jb25zdCBXRUJTT0NLRVQgPSAnd2Vic29ja2V0JztcclxuY29uc3QgTE9OR19QT0xMSU5HID0gJ2xvbmdfcG9sbGluZyc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaG9sZHMgbWV0YWRhdGEgYWJvdXQgYSBSZXBvIG9iamVjdFxyXG4gKi9cclxuY2xhc3MgUmVwb0luZm8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaG9zdCAtIEhvc3RuYW1lIHBvcnRpb24gb2YgdGhlIHVybCBmb3IgdGhlIHJlcG9cclxuICAgICAqIEBwYXJhbSBzZWN1cmUgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIHJlcG8gaXMgYWNjZXNzZWQgb3ZlciBzc2xcclxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgbmFtZXNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZSByZXBvXHJcbiAgICAgKiBAcGFyYW0gd2ViU29ja2V0T25seSAtIFdoZXRoZXIgdG8gcHJlZmVyIHdlYnNvY2tldHMgb3ZlciBhbGwgb3RoZXIgdHJhbnNwb3J0cyAodXNlZCBieSBOZXN0KS5cclxuICAgICAqIEBwYXJhbSBub2RlQWRtaW4gLSBXaGV0aGVyIHRoaXMgaW5zdGFuY2UgdXNlcyBBZG1pbiBTREsgY3JlZGVudGlhbHNcclxuICAgICAqIEBwYXJhbSBwZXJzaXN0ZW5jZUtleSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNlc3Npb24gcGVyc2lzdGVuY2Ugc3RvcmFnZSBrZXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaG9zdCwgc2VjdXJlLCBuYW1lc3BhY2UsIHdlYlNvY2tldE9ubHksIG5vZGVBZG1pbiA9IGZhbHNlLCBwZXJzaXN0ZW5jZUtleSA9ICcnLCBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyA9IGZhbHNlLCBpc1VzaW5nRW11bGF0b3IgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlO1xyXG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xyXG4gICAgICAgIHRoaXMud2ViU29ja2V0T25seSA9IHdlYlNvY2tldE9ubHk7XHJcbiAgICAgICAgdGhpcy5ub2RlQWRtaW4gPSBub2RlQWRtaW47XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMgPSBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcztcclxuICAgICAgICB0aGlzLmlzVXNpbmdFbXVsYXRvciA9IGlzVXNpbmdFbXVsYXRvcjtcclxuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHRoaXMuX2RvbWFpbiA9IHRoaXMuX2hvc3Quc3Vic3RyKHRoaXMuX2hvc3QuaW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPVxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5nZXQoJ2hvc3Q6JyArIGhvc3QpIHx8IHRoaXMuX2hvc3Q7XHJcbiAgICB9XHJcbiAgICBpc0NhY2hlYWJsZUhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxIb3N0LnN1YnN0cigwLCAyKSA9PT0gJ3MtJztcclxuICAgIH1cclxuICAgIGlzQ3VzdG9tSG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2RvbWFpbiAhPT0gJ2ZpcmViYXNlaW8uY29tJyAmJlxyXG4gICAgICAgICAgICB0aGlzLl9kb21haW4gIT09ICdmaXJlYmFzZWlvLWRlbW8uY29tJyk7XHJcbiAgICB9XHJcbiAgICBnZXQgaG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcclxuICAgIH1cclxuICAgIHNldCBob3N0KG5ld0hvc3QpIHtcclxuICAgICAgICBpZiAobmV3SG9zdCAhPT0gdGhpcy5pbnRlcm5hbEhvc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPSBuZXdIb3N0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NhY2hlYWJsZUhvc3QoKSkge1xyXG4gICAgICAgICAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdob3N0OicgKyB0aGlzLl9ob3N0LCB0aGlzLmludGVybmFsSG9zdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBsZXQgc3RyID0gdGhpcy50b1VSTFN0cmluZygpO1xyXG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnPCcgKyB0aGlzLnBlcnNpc3RlbmNlS2V5ICsgJz4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgdG9VUkxTdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zXHJcbiAgICAgICAgICAgID8gYD9ucz0ke3RoaXMubmFtZXNwYWNlfWBcclxuICAgICAgICAgICAgOiAnJztcclxuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9JHt0aGlzLmhvc3R9LyR7cXVlcnl9YDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvSW5mb05lZWRzUXVlcnlQYXJhbShyZXBvSW5mbykge1xyXG4gICAgcmV0dXJuIChyZXBvSW5mby5ob3N0ICE9PSByZXBvSW5mby5pbnRlcm5hbEhvc3QgfHxcclxuICAgICAgICByZXBvSW5mby5pc0N1c3RvbUhvc3QoKSB8fFxyXG4gICAgICAgIHJlcG9JbmZvLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgd2Vic29ja2V0IFVSTCBmb3IgdGhpcyByZXBvXHJcbiAqIEBwYXJhbSByZXBvSW5mbyAtIFJlcG9JbmZvIG9iamVjdFxyXG4gKiBAcGFyYW0gdHlwZSAtIG9mIGNvbm5lY3Rpb25cclxuICogQHBhcmFtIHBhcmFtcyAtIGxpc3RcclxuICogQHJldHVybnMgVGhlIFVSTCBmb3IgdGhpcyByZXBvXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIHR5cGUsIHBhcmFtcykge1xyXG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgJ3R5cGVvZiB0eXBlIG11c3QgPT0gc3RyaW5nJyk7XHJcbiAgICBhc3NlcnQodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcsICd0eXBlb2YgcGFyYW1zIG11c3QgPT0gb2JqZWN0Jyk7XHJcbiAgICBsZXQgY29ublVSTDtcclxuICAgIGlmICh0eXBlID09PSBXRUJTT0NLRVQpIHtcclxuICAgICAgICBjb25uVVJMID1cclxuICAgICAgICAgICAgKHJlcG9JbmZvLnNlY3VyZSA/ICd3c3M6Ly8nIDogJ3dzOi8vJykgKyByZXBvSW5mby5pbnRlcm5hbEhvc3QgKyAnLy53cz8nO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gTE9OR19QT0xMSU5HKSB7XHJcbiAgICAgICAgY29ublVSTCA9XHJcbiAgICAgICAgICAgIChyZXBvSW5mby5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArXHJcbiAgICAgICAgICAgICAgICByZXBvSW5mby5pbnRlcm5hbEhvc3QgK1xyXG4gICAgICAgICAgICAgICAgJy8ubHA/JztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb25uZWN0aW9uIHR5cGU6ICcgKyB0eXBlKTtcclxuICAgIH1cclxuICAgIGlmIChyZXBvSW5mb05lZWRzUXVlcnlQYXJhbShyZXBvSW5mbykpIHtcclxuICAgICAgICBwYXJhbXNbJ25zJ10gPSByZXBvSW5mby5uYW1lc3BhY2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWlycyA9IFtdO1xyXG4gICAgZWFjaChwYXJhbXMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgcGFpcnMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb25uVVJMICsgcGFpcnMuam9pbignJicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUcmFja3MgYSBjb2xsZWN0aW9uIG9mIHN0YXRzLlxyXG4gKi9cclxuY2xhc3MgU3RhdHNDb2xsZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY291bnRlcnNfID0ge307XHJcbiAgICB9XHJcbiAgICBpbmNyZW1lbnRDb3VudGVyKG5hbWUsIGFtb3VudCA9IDEpIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5zKHRoaXMuY291bnRlcnNfLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzX1tuYW1lXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY291bnRlcnNfW25hbWVdICs9IGFtb3VudDtcclxuICAgIH1cclxuICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gZGVlcENvcHkodGhpcy5jb3VudGVyc18pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGNvbGxlY3Rpb25zID0ge307XHJcbmNvbnN0IHJlcG9ydGVycyA9IHt9O1xyXG5mdW5jdGlvbiBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKSB7XHJcbiAgICBjb25zdCBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcclxuICAgIGlmICghY29sbGVjdGlvbnNbaGFzaFN0cmluZ10pIHtcclxuICAgICAgICBjb2xsZWN0aW9uc1toYXNoU3RyaW5nXSA9IG5ldyBTdGF0c0NvbGxlY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2xsZWN0aW9uc1toYXNoU3RyaW5nXTtcclxufVxyXG5mdW5jdGlvbiBzdGF0c01hbmFnZXJHZXRPckNyZWF0ZVJlcG9ydGVyKHJlcG9JbmZvLCBjcmVhdG9yRnVuY3Rpb24pIHtcclxuICAgIGNvbnN0IGhhc2hTdHJpbmcgPSByZXBvSW5mby50b1N0cmluZygpO1xyXG4gICAgaWYgKCFyZXBvcnRlcnNbaGFzaFN0cmluZ10pIHtcclxuICAgICAgICByZXBvcnRlcnNbaGFzaFN0cmluZ10gPSBjcmVhdG9yRnVuY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXBvcnRlcnNbaGFzaFN0cmluZ107XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZW5zdXJlcyB0aGUgcGFja2V0cyBmcm9tIHRoZSBzZXJ2ZXIgYXJyaXZlIGluIG9yZGVyXHJcbiAqIFRoaXMgY2xhc3MgdGFrZXMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgYW5kIGVuc3VyZXMgaXQgZ2V0cyBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tzIGluIG9yZGVyLlxyXG4gKi9cclxuY2xhc3MgUGFja2V0UmVjZWl2ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlX1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihvbk1lc3NhZ2VfKSB7XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfID0gb25NZXNzYWdlXztcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5jbG9zZUFmdGVyUmVzcG9uc2UgPSAtMTtcclxuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgY2xvc2VBZnRlcihyZXNwb25zZU51bSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IHJlc3BvbnNlTnVtO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGlmICh0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA8IHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlciBjb21lcyB3aXRoIGEgcmVzcG9uc2UgbnVtYmVyLCBhbmQgYW4gYXJyYXkgb2YgZGF0YS4gVGhlIHJlc3BvbnNlTnVtYmVyXHJcbiAgICAgKiBhbGxvd3MgdXMgdG8gZW5zdXJlIHRoYXQgd2UgcHJvY2VzcyB0aGVtIGluIHRoZSByaWdodCBvcmRlciwgc2luY2Ugd2UgY2FuJ3QgYmUgZ3VhcmFudGVlZCB0aGF0IGFsbFxyXG4gICAgICogYnJvd3NlcnMgd2lsbCByZXNwb25kIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSByZXF1ZXN0cyB3ZSBzZW50XHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVJlc3BvbnNlKHJlcXVlc3ROdW0sIGRhdGEpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXNbcmVxdWVzdE51bV0gPSBkYXRhO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvUHJvY2VzcyA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUHJvY2Vzcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvUHJvY2Vzc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VfKHRvUHJvY2Vzc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc3BvbnNlTnVtID09PSB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBVUkwgcXVlcnkgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggbG9uZ3BvbGxpbmdcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0gPSAnc3RhcnQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EID0gJ2Nsb3NlJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FID0gJ3BMUENvbW1hbmQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX0NCX05BTUUgPSAncFJUTFBDQic7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNID0gJ2lkJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU0gPSAncHcnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU0gPSAnc2VyJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU0gPSAnY2InO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSA9ICdzZWcnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgPSAndHMnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNID0gJ2QnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9ESVNDT05OX0ZSQU1FX1JFUVVFU1RfUEFSQU0gPSAnZGZyYW1lJztcclxuLy9EYXRhIHNpemUgY29uc3RhbnRzLlxyXG4vL1RPRE86IFBlcmY6IHRoZSBtYXhpbXVtIGxlbmd0aCBhY3R1YWxseSBkaWZmZXJzIGZyb20gYnJvd3NlciB0byBicm93c2VyLlxyXG4vLyBXZSBzaG91bGQgY2hlY2sgd2hhdCBicm93c2VyIHdlJ3JlIG9uIGFuZCBzZXQgYWNjb3JkaW5nbHkuXHJcbmNvbnN0IE1BWF9VUkxfREFUQV9TSVpFID0gMTg3MDtcclxuY29uc3QgU0VHX0hFQURFUl9TSVpFID0gMzA7IC8vaWU6ICZzZWc9ODI5OTIzNCZ0cz05ODIzODkxMjMmZD1cclxuY29uc3QgTUFYX1BBWUxPQURfU0laRSA9IE1BWF9VUkxfREFUQV9TSVpFIC0gU0VHX0hFQURFUl9TSVpFO1xyXG4vKipcclxuICogS2VlcGFsaXZlIHBlcmlvZFxyXG4gKiBzZW5kIGEgZnJlc2ggcmVxdWVzdCBhdCBtaW5pbXVtIGV2ZXJ5IDI1IHNlY29uZHMuIE9wZXJhIGhhcyBhIG1heGltdW0gcmVxdWVzdFxyXG4gKiBsZW5ndGggb2YgMzAgc2Vjb25kcyB0aGF0IHdlIGNhbid0IGV4Y2VlZC5cclxuICovXHJcbmNvbnN0IEtFRVBBTElWRV9SRVFVRVNUX0lOVEVSVkFMID0gMjUwMDA7XHJcbi8qKlxyXG4gKiBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSBhYm9ydGluZyBhIGxvbmctcG9sbGluZyBjb25uZWN0aW9uIGF0dGVtcHQuXHJcbiAqL1xyXG5jb25zdCBMUF9DT05ORUNUX1RJTUVPVVQgPSAzMDAwMDtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBhIHNpbmdsZSBsb25nLXBvbGxpbmcgY29ubmVjdGlvbi5cclxuICovXHJcbmNsYXNzIEJyb3dzZXJQb2xsQ29ubmVjdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb25uSWQgQW4gaWRlbnRpZmllciBmb3IgdGhpcyBjb25uZWN0aW9uLCB1c2VkIGZvciBsb2dnaW5nXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZCBUaGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3QuXHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbiBUaGUgQXBwQ2hlY2sgdG9rZW4gZm9yIHRoaXMgY2xpZW50LlxyXG4gICAgICogQHBhcmFtIGF1dGhUb2tlbiBUaGUgQXV0aFRva2VuIHRvIHVzZSBmb3IgdGhpcyBjb25uZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uaWQgaWYgd2UgYXJlXHJcbiAgICAgKiByZWNvbm5lY3RpbmcgZm9yIGFuIGV4aXN0aW5nIHRyYW5zcG9ydCBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZSBQZXJzaXN0ZW50Q29ubmVjdGlvbiBoYXNcclxuICAgICAqIGFscmVhZHkgY3JlYXRlZCBhIGNvbm5lY3Rpb24gcHJldmlvdXNseVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25uSWQsIHJlcG9JbmZvLCBhcHBsaWNhdGlvbklkLCBhcHBDaGVja1Rva2VuLCBhdXRoVG9rZW4sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuY29ubklkID0gY29ubklkO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm8gPSByZXBvSW5mbztcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbiA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdXRoVG9rZW47XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQgPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmJ5dGVzU2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcclxuICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcihjb25uSWQpO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XHJcbiAgICAgICAgdGhpcy51cmxGbiA9IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGFkZCB0aGUgdG9rZW4gaWYgd2UgaGF2ZSBvbmUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtc1tBUFBfQ0hFQ0tfVE9LRU5fUEFSQU1dID0gdGhpcy5hcHBDaGVja1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIExPTkdfUE9MTElORywgcGFyYW1zKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cclxuICAgICAqL1xyXG4gICAgb3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyID0gbmV3IFBhY2tldFJlY2VpdmVyKG9uTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LicpO1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgdGhlIGhvc3QgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihMUF9DT05ORUNUX1RJTUVPVVQpKTtcclxuICAgICAgICAvLyBFbnN1cmUgd2UgZGVsYXkgdGhlIGNyZWF0aW9uIG9mIHRoZSBpZnJhbWUgdW50aWwgdGhlIERPTSBpcyBsb2FkZWQuXHJcbiAgICAgICAgZXhlY3V0ZVdoZW5ET01SZWFkeSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vU2V0IHVwIGEgY2FsbGJhY2sgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmNlIGEgY29ubmVjdGlvbiBpcyBzZXQgdXAuXHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyID0gbmV3IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyKCguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbY29tbWFuZCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNF0gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHdlIGNsb3NlZCB0aGUgY29ubmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gYXJnMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gYXJnMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IEZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjbGVhciB0aGUgaG9zdCBjYWNoZS4gV2UgZ290IGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBrbm93IGl0J3MgcmVhY2hhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlbid0IGV4cGVjdGluZyBhbnkgbW9yZSBkYXRhIChvdGhlciB0aGFuIHdoYXQgdGhlIHNlcnZlcidzIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2Ygc2VuZGluZyB1c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIG91ciBhbHJlYWR5IG9wZW4gcG9sbHMpLCBzbyBkb24ndCBzZW5kIGFueSBtb3JlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJnMSBpbiB0aGlzIGNhc2UgaXMgdGhlIGxhc3QgcmVzcG9uc2UgbnVtYmVyIHNlbnQgYnkgdGhlIHNlcnZlci4gV2Ugc2hvdWxkIHRyeSB0byByZWNlaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgcmVzcG9uc2VzIHVwIHRvIHRoaXMgb25lIGJlZm9yZSBjbG9zaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyLmNsb3NlQWZ0ZXIoYXJnMSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGNvbW1hbmQgcmVjZWl2ZWQ6ICcgKyBjb21tYW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtwTiwgZGF0YV0gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyLmhhbmRsZVJlc3BvbnNlKHBOLCBkYXRhKTtcclxuICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgfSwgdGhpcy51cmxGbik7XHJcbiAgICAgICAgICAgIC8vU2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0IHRvIGNvbm5lY3QuIFRoZSBzZXJpYWwgbnVtYmVyIGlzIHNpbXBseSB0byBrZWVwIHRoZSBicm93c2VyIGZyb20gcHVsbGluZyBwcmV2aW91cyByZXN1bHRzXHJcbiAgICAgICAgICAgIC8vZnJvbSBjYWNoZS5cclxuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTV0gPSAndCc7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NyaXB0VGFnSG9sZGVyLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0NBTExCQUNLX0lEX1BBUkFNXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1RSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gdGhpcy5sYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tBUFBMSUNBVElPTl9JRF9QQVJBTV0gPSB0aGlzLmFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSB0aGlzLmFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhvc3RuYW1lICYmXHJcbiAgICAgICAgICAgICAgICBGT1JHRV9ET01BSU5fUkUudGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tSRUZFUkVSX1BBUkFNXSA9IEZPUkdFX1JFRjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0VVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3RpbmcgdmlhIGxvbmctcG9sbCB0byAnICsgY29ubmVjdFVSTCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmFkZFRhZyhjb25uZWN0VVJMLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKiBkbyBub3RoaW5nICovXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHRoaXMgd2hlbiBhIGhhbmRzaGFrZSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBhbmQgd2Ugd2FudCB0byBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZFxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zdGFydExvbmdQb2xsKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xyXG4gICAgICAgIHRoaXMuYWRkRGlzY29ubmVjdFBpbmdGcmFtZSh0aGlzLmlkLCB0aGlzLnBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIGxvbmcgcG9sbGluZyB0byBiZSBjb25zaWRlcmVkIGFzIGEgcG90ZW50aWFsIHRyYW5zcG9ydFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZm9yY2VBbGxvdygpIHtcclxuICAgICAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgbG9uZ3BvbGxpbmcgdG8gbm90IGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JjZURpc2FsbG93KCkge1xyXG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBTdGF0aWMgbWV0aG9kLCB1c2Ugc3RyaW5nIGxpdGVyYWwgc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGluIGEgZ2VuZXJpYyB3YXlcclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBJbiBSZWFjdC1OYXRpdmUgdGhlcmUncyBub3JtYWxseSBubyAnZG9jdW1lbnQnLCBidXQgaWYgeW91IGRlYnVnIGEgUmVhY3QtTmF0aXZlIGFwcCBpblxyXG4gICAgICAgICAgICAvLyB0aGUgQ2hyb21lIGRlYnVnZ2VyLCAnZG9jdW1lbnQnIGlzIGRlZmluZWQsIGJ1dCBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzIG51bGwgKDIwMTUvMDYvMDgpLlxyXG4gICAgICAgICAgICByZXR1cm4gKCFCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCgpICYmXHJcbiAgICAgICAgICAgICAgICAhaXNXaW5kb3dzU3RvcmVBcHAoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOby1vcCBmb3IgcG9sbGluZ1xyXG4gICAgICovXHJcbiAgICBtYXJrQ29ubmVjdGlvbkhlYWx0aHkoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgcG9sbGluZyBhbmQgY2xlYW5zIHVwIHRoZSBpZnJhbWVcclxuICAgICAqL1xyXG4gICAgc2h1dGRvd25fKCkge1xyXG4gICAgICAgIHRoaXMuaXNDbG9zZWRfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3JlbW92ZSB0aGUgZGlzY29ubmVjdCBmcmFtZSwgd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIFhIUiBjYWxsIHRvIHRoZSBzZXJ2ZXIgdG8gdGVsbCBpdCB3ZSdyZSBsZWF2aW5nLlxyXG4gICAgICAgIGlmICh0aGlzLm15RGlzY29ubkZyYW1lKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5teURpc2Nvbm5GcmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhpcyB0cmFuc3BvcnQgaXMgY2xvc2VkXHJcbiAgICAgKi9cclxuICAgIG9uQ2xvc2VkXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgY2xvc2luZyBpdHNlbGYnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKHRoaXMuZXZlckNvbm5lY3RlZF8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuIFJlYWxUaW1lIGhhcyByZXF1ZXN0ZWQgd2Ugc2h1dCBkb3duLiBLaWxsIG91ciBjb25uZWN0aW9uIGFuZCB0ZWxsIHRoZSBzZXJ2ZXJcclxuICAgICAqIHRoYXQgd2UndmUgbGVmdC5cclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0xvbmdwb2xsIGlzIGJlaW5nIGNsb3NlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgdGhlIEpTT04gb2JqZWN0IGRvd24gdG8gdGhlIHNlcnZlci4gSXQgd2lsbCBuZWVkIHRvIGJlIHN0cmluZ2lmaWVkLCBiYXNlNjQgZW5jb2RlZCwgYW5kIHRoZW5cclxuICAgICAqIGJyb2tlbiBpbnRvIGNodW5rcyAoc2luY2UgVVJMcyBoYXZlIGEgc21hbGwgbWF4aW11bSBsZW5ndGgpLlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgSlNPTiBkYXRhIHRvIHRyYW5zbWl0LlxyXG4gICAgICovXHJcbiAgICBzZW5kKGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XHJcbiAgICAgICAgLy9maXJzdCwgbGV0cyBnZXQgdGhlIGJhc2U2NC1lbmNvZGVkIGRhdGFcclxuICAgICAgICBjb25zdCBiYXNlNjRkYXRhID0gYmFzZTY0RW5jb2RlKGRhdGFTdHIpO1xyXG4gICAgICAgIC8vV2UgY2FuIG9ubHkgZml0IGEgY2VydGFpbiBhbW91bnQgaW4gZWFjaCBVUkwsIHNvIHdlIG5lZWQgdG8gc3BsaXQgdGhpcyByZXF1ZXN0XHJcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cclxuICAgICAgICBjb25zdCBkYXRhU2VncyA9IHNwbGl0U3RyaW5nQnlTaXplKGJhc2U2NGRhdGEsIE1BWF9QQVlMT0FEX1NJWkUpO1xyXG4gICAgICAgIC8vRW5xdWV1ZSBlYWNoIHNlZ21lbnQgZm9yIHRyYW5zbWlzc2lvbi4gV2UgYXNzaWduIGVhY2ggY2h1bmsgYSBzZXF1ZW50aWFsIElEIGFuZCBhIHRvdGFsIG51bWJlclxyXG4gICAgICAgIC8vb2Ygc2VnbWVudHMgc28gdGhhdCB3ZSBjYW4gcmVhc3NlbWJsZSB0aGUgcGFja2V0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5lbnF1ZXVlU2VnbWVudCh0aGlzLmN1clNlZ21lbnROdW0sIGRhdGFTZWdzLmxlbmd0aCwgZGF0YVNlZ3NbaV0pO1xyXG4gICAgICAgICAgICB0aGlzLmN1clNlZ21lbnROdW0rKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgc2VydmVyIHRoYXQgd2UncmUgbGVhdmluZy5cclxuICAgICAqIFdlIGFyZW4ndCBhYmxlIHRvIHNlbmQgcmVxdWVzdHMgd2l0aCBESFRNTCBvbiBhIHdpbmRvdyBjbG9zZSBldmVudCwgYnV0IHdlIGNhblxyXG4gICAgICogdHJpZ2dlciBYSFIgcmVxdWVzdHMgaW4gc29tZSBicm93c2VycyAoZXZlcnl0aGluZyBidXQgT3BlcmEgYmFzaWNhbGx5KS5cclxuICAgICAqL1xyXG4gICAgYWRkRGlzY29ubmVjdFBpbmdGcmFtZShpZCwgcHcpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTV0gPSAndCc7XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IGlkO1xyXG4gICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSBwdztcclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnNyYyA9IHRoaXMudXJsRm4odXJsUGFyYW1zKTtcclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byB0cmFjayB0aGUgYnl0ZXMgcmVjZWl2ZWQgYnkgdGhpcyBjbGllbnRcclxuICAgICAqL1xyXG4gICAgaW5jcmVtZW50SW5jb21pbmdCeXRlc18oYXJncykge1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYW4gYW5ub3lpbmcgcGVyZiBoaXQganVzdCB0byB0cmFjayB0aGUgbnVtYmVyIG9mIGluY29taW5nIGJ5dGVzLiAgTWF5YmUgaXQgc2hvdWxkIGJlIG9wdC1pbi5cclxuICAgICAgICBjb25zdCBieXRlc1JlY2VpdmVkID0gc3RyaW5naWZ5KGFyZ3MpLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gYnl0ZXNSZWNlaXZlZDtcclxuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19yZWNlaXZlZCcsIGJ5dGVzUmVjZWl2ZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBpZnJhbWUgdGhhdCBpcyB1c2VkIGFzIGEgbG9uZy1wb2xsaW5nIHNjcmlwdCBob2xkZXIuXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbmNsYXNzIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbW1hbmRDQiAtIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBjb250cm9sIGNvbW1hbmRzIGFyZSByZWNldmllZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlQ0IgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gcmVzcG9uc2VzIGFycml2ZSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0IC0gVGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgdGFnIGhvbGRlciBpcyBjbG9zZWRcclxuICAgICAqIEBwYXJhbSB1cmxGbiAtIEEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyB0aGUgVVJMIG9mIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRDQiwgb25NZXNzYWdlQ0IsIG9uRGlzY29ubmVjdCwgdXJsRm4pIHtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG9uRGlzY29ubmVjdDtcclxuICAgICAgICB0aGlzLnVybEZuID0gdXJsRm47XHJcbiAgICAgICAgLy9XZSBtYWludGFpbiBhIGNvdW50IG9mIGFsbCBvZiB0aGUgb3V0c3RhbmRpbmcgcmVxdWVzdHMsIGJlY2F1c2UgaWYgd2UgaGF2ZSB0b28gbWFueSBhY3RpdmUgYXQgb25jZSBpdCBjYW4gY2F1c2VcclxuICAgICAgICAvL3Byb2JsZW1zIGluIHNvbWUgYnJvd3NlcnMuXHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1JlcXVlc3RzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8vQSBxdWV1ZSBvZiB0aGUgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cclxuICAgICAgICB0aGlzLnBlbmRpbmdTZWdzID0gW107XHJcbiAgICAgICAgLy9BIHNlcmlhbCBudW1iZXIuIFdlIHVzZSB0aGlzIGZvciB0d28gdGhpbmdzOlxyXG4gICAgICAgIC8vIDEpIEEgd2F5IHRvIGVuc3VyZSB0aGUgYnJvd3NlciBkb2Vzbid0IGNhY2hlIHJlc3BvbnNlcyB0byBwb2xsc1xyXG4gICAgICAgIC8vIDIpIEEgd2F5IHRvIG1ha2UgdGhlIHNlcnZlciBhd2FyZSB3aGVuIGxvbmctcG9sbHMgYXJyaXZlIGluIGEgZGlmZmVyZW50IG9yZGVyIHRoYW4gd2Ugc3RhcnRlZCB0aGVtLiBUaGVcclxuICAgICAgICAvLyAgICBzZXJ2ZXIgbmVlZHMgdG8gcmVsZWFzZSBib3RoIHBvbGxzIGluIHRoaXMgY2FzZSBvciBpdCB3aWxsIGNhdXNlIHByb2JsZW1zIGluIE9wZXJhIHNpbmNlIE9wZXJhIGNhbiBvbmx5IGV4ZWN1dGVcclxuICAgICAgICAvLyAgICBKU09OUCBjb2RlIGluIHRoZSBvcmRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIGlmcmFtZS5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xyXG4gICAgICAgIC8vIFRoaXMgZ2V0cyBzZXQgdG8gZmFsc2Ugd2hlbiB3ZSdyZSBcImNsb3NpbmcgZG93blwiIHRoZSBjb25uZWN0aW9uIChlLmcuIHdlJ3JlIHN3aXRjaGluZyB0cmFuc3BvcnRzIGJ1dCB0aGVyZSdzIHN0aWxsXHJcbiAgICAgICAgLy8gaW5jb21pbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSB3YWl0aW5nIGZvcikuXHJcbiAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSB0cnVlO1xyXG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgLy9FYWNoIHNjcmlwdCBob2xkZXIgcmVnaXN0ZXJzIGEgY291cGxlIG9mIHVuaXF1ZWx5IG5hbWVkIGNhbGxiYWNrcyB3aXRoIHRoZSB3aW5kb3cuIFRoZXNlIGFyZSBjYWxsZWQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy9pZnJhbWVzIHdoZXJlIHdlIHB1dCB0aGUgbG9uZy1wb2xsaW5nIHNjcmlwdCB0YWdzLiBXZSBoYXZlIHR3byBjYWxsYmFja3M6XHJcbiAgICAgICAgICAgIC8vICAgMSkgQ29tbWFuZCBDYWxsYmFjayAtIFRyaWdnZXJlZCBmb3IgY29udHJvbCBpc3N1ZXMsIGxpa2Ugc3RhcnRpbmcgYSBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAvLyAgIDIpIE1lc3NhZ2UgQ2FsbGJhY2sgLSBUcmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBhcnJpdmVzLlxyXG4gICAgICAgICAgICB0aGlzLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllciA9IExVSURHZW5lcmF0b3IoKTtcclxuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0NPTU1BTkRfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9IGNvbW1hbmRDQjtcclxuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9XHJcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2VDQjtcclxuICAgICAgICAgICAgLy9DcmVhdGUgYW4gaWZyYW1lIGZvciB1cyB0byBhZGQgc2NyaXB0IHRhZ3MgdG8uXHJcbiAgICAgICAgICAgIHRoaXMubXlJRnJhbWUgPSBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5jcmVhdGVJRnJhbWVfKCk7XHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaWZyYW1lJ3MgY29udGVudHMuXHJcbiAgICAgICAgICAgIGxldCBzY3JpcHQgPSAnJztcclxuICAgICAgICAgICAgLy8gaWYgd2Ugc2V0IGEgamF2YXNjcmlwdCB1cmwsIGl0J3MgSUUgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBkb21haW4uIFRoZSBqYXZhc2NyaXB0IHVybCBpcyBzdWZmaWNpZW50XHJcbiAgICAgICAgICAgIC8vIGZvciBpZTksIGJ1dCBpZTggbmVlZHMgdG8gZG8gaXQgYWdhaW4gaW4gdGhlIGRvY3VtZW50IGl0c2VsZi5cclxuICAgICAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUuc3JjICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLnNyYy5zdWJzdHIoMCwgJ2phdmFzY3JpcHQ6Jy5sZW5ndGgpID09PSAnamF2YXNjcmlwdDonKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gJzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJyArIGN1cnJlbnREb21haW4gKyAnXCI7PC9zY3JpcHQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpZnJhbWVDb250ZW50cyA9ICc8aHRtbD48Ym9keT4nICsgc2NyaXB0ICsgJzwvYm9keT48L2h0bWw+JztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLndyaXRlKGlmcmFtZUNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnZnJhbWUgd3JpdGluZyBleGNlcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLnN0YWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9nKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRDQiA9IGNvbW1hbmRDQjtcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VDQiA9IG9uTWVzc2FnZUNCO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBicm93c2VyIGhhcyBpdHMgb3duIGZ1bm55IHdheSB0byBoYW5kbGUgaWZyYW1lcy4gSGVyZSB3ZSBtdXNoIHRoZW0gYWxsIHRvZ2V0aGVyIGludG8gb25lIG9iamVjdCB0aGF0IEkgY2FuXHJcbiAgICAgKiBhY3R1YWxseSB1c2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVJRnJhbWVfKCkge1xyXG4gICAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xyXG4gICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIGluaXRpYWxpemUgdGhlIGRvY3VtZW50IGluc2lkZSB0aGUgaWZyYW1lXHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIG1vZGlmaWVkIGluIElFLCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IsIGFuZCB3ZSBuZWVkIHRvIHNldCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGRvbWFpbiBvZiB0aGUgaWZyYW1lJ3MgZG9jdW1lbnQgbWFudWFsbHkuIFdlIGNhbiBkbyB0aGlzIHZpYSBhIGphdmFzY3JpcHQ6IHVybCBhcyB0aGUgc3JjIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgd2UgbXVzdCBkbyB0aGlzICphZnRlciogdGhlIGlmcmFtZSBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgcGFnZS4gT3RoZXJ3aXNlIGl0IGRvZXNuJ3Qgd29yay5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwb2xvZ2llcyBmb3IgdGhlIGxvZy1zcGFtLCBJIG5lZWQgdG8gZG8gc29tZXRoaW5nIHRvIGtlZXAgY2xvc3VyZSBmcm9tIG9wdGltaXppbmcgb3V0IHRoZSBhc3NpZ25tZW50IGFib3ZlLlxyXG4gICAgICAgICAgICAgICAgICAgIGxvZygnTm8gSUUgZG9tYWluIHNldHRpbmcgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgaWZyYW1lLnNyYyA9XHJcbiAgICAgICAgICAgICAgICAgICAgXCJqYXZhc2NyaXB0OnZvaWQoKGZ1bmN0aW9uKCl7ZG9jdW1lbnQub3BlbigpO2RvY3VtZW50LmRvbWFpbj0nXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic7ZG9jdW1lbnQuY2xvc2UoKTt9KSgpKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBMb25nUG9sbENvbm5lY3Rpb24gYXR0ZW1wdHMgdG8gZGVsYXkgaW5pdGlhbGl6YXRpb24gdW50aWwgdGhlIGRvY3VtZW50IGlzIHJlYWR5LCBzbyBob3BlZnVsbHkgdGhpc1xyXG4gICAgICAgICAgICAvLyBuZXZlciBnZXRzIGhpdC5cclxuICAgICAgICAgICAgdGhyb3cgJ0RvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZXQgdGhlIGRvY3VtZW50IG9mIHRoZSBpZnJhbWUgaW4gYSBicm93c2VyLXNwZWNpZmljIHdheS5cclxuICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudDsgLy8gRmlyZWZveCwgT3BlcmEsIFNhZmFyaVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpZnJhbWUuY29udGVudFdpbmRvdykge1xyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7IC8vIEludGVybmV0IEV4cGxvcmVyXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlmcmFtZS5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmRvY3VtZW50OyAvL290aGVycz9cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlmcmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VsIGFsbCBvdXRzdGFuZGluZyBxdWVyaWVzIGFuZCByZW1vdmUgdGhlIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICAvL01hcmsgdGhpcyBpZnJhbWUgYXMgZGVhZCwgc28gbm8gbmV3IHJlcXVlc3RzIGFyZSBzZW50LlxyXG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5teUlGcmFtZSkge1xyXG4gICAgICAgICAgICAvL1dlIGhhdmUgdG8gYWN0dWFsbHkgcmVtb3ZlIGFsbCBvZiB0aGUgaHRtbCBpbnNpZGUgdGhpcyBpZnJhbWUgYmVmb3JlIHJlbW92aW5nIGl0IGZyb20gdGhlXHJcbiAgICAgICAgICAgIC8vd2luZG93LCBvciBJRSB3aWxsIGNvbnRpbnVlIGxvYWRpbmcgYW5kIGV4ZWN1dGluZyB0aGUgc2NyaXB0IHRhZ3Mgd2UndmUgYWxyZWFkeSBhZGRlZCwgd2hpY2hcclxuICAgICAgICAgICAgLy9jYW4gbGVhZCB0byBzb21lIGVycm9ycyBiZWluZyB0aHJvd24uIFNldHRpbmcgdGV4dENvbnRlbnQgc2VlbXMgdG8gYmUgdGhlIHNhZmVzdCB3YXkgdG8gZG8gdGhpcy5cclxuICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuYm9keS50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm15SUZyYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15SUZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb3RlY3QgZnJvbSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkuXHJcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgaWYgKG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWN0dWFsbHkgc3RhcnQgdGhlIGxvbmctcG9sbGluZyBzZXNzaW9uIGJ5IGFkZGluZyB0aGUgZmlyc3Qgc2NyaXB0IHRhZyhzKSB0byB0aGUgaWZyYW1lLlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICogQHBhcmFtIHB3IC0gVGhlIHBhc3N3b3JkIGZvciB0aGlzIGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgc3RhcnRMb25nUG9sbChpZCwgcHcpIHtcclxuICAgICAgICB0aGlzLm15SUQgPSBpZDtcclxuICAgICAgICB0aGlzLm15UFcgPSBwdztcclxuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcclxuICAgICAgICAvL3NlbmQgdGhlIGluaXRpYWwgcmVxdWVzdC4gSWYgdGhlcmUgYXJlIHJlcXVlc3RzIHF1ZXVlZCwgbWFrZSBzdXJlIHRoYXQgd2UgdHJhbnNtaXQgYXMgbWFueSBhcyB3ZSBhcmUgY3VycmVudGx5IGFibGUgdG8uXHJcbiAgICAgICAgd2hpbGUgKHRoaXMubmV3UmVxdWVzdF8oKSkgeyB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGFueSB0aW1lIHNvbWVvbmUgbWlnaHQgd2FudCBhIHNjcmlwdCB0YWcgdG8gYmUgYWRkZWQuIEl0IGFkZHMgYSBzY3JpcHQgdGFnIHdoZW4gdGhlcmUgYXJlbid0XHJcbiAgICAgKiB0b28gbWFueSBvdXRzdGFuZGluZyByZXF1ZXN0cyBhbmQgd2UgYXJlIHN0aWxsIGFsaXZlLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZXJlIGFyZSBvdXRzdGFuZGluZyBwYWNrZXQgc2VnbWVudHMgdG8gc2VuZCwgaXQgc2VuZHMgb25lLiBJZiB0aGVyZSBhcmVuJ3QsIGl0IHNlbmRzIGEgbG9uZy1wb2xsIGFueXdheXMgaWZcclxuICAgICAqIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgbmV3UmVxdWVzdF8oKSB7XHJcbiAgICAgICAgLy8gV2Uga2VlcCBvbmUgb3V0c3RhbmRpbmcgcmVxdWVzdCBvcGVuIGFsbCB0aGUgdGltZSB0byByZWNlaXZlIGRhdGEsIGJ1dCBpZiB3ZSBuZWVkIHRvIHNlbmQgZGF0YVxyXG4gICAgICAgIC8vIChwZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB0aGVuIHdlIGNyZWF0ZSBhIG5ldyByZXF1ZXN0IHRvIHNlbmQgdGhlIGRhdGEuICBUaGUgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseVxyXG4gICAgICAgIC8vIGNsb3NlIHRoZSBvbGQgcmVxdWVzdC5cclxuICAgICAgICBpZiAodGhpcy5hbGl2ZSAmJlxyXG4gICAgICAgICAgICB0aGlzLnNlbmROZXdQb2xscyAmJlxyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuc2l6ZSA8ICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDAgPyAyIDogMSkpIHtcclxuICAgICAgICAgICAgLy9jb25zdHJ1Y3Qgb3VyIHVybFxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwrKztcclxuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTV0gPSB0aGlzLm15SUQ7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSB0aGlzLm15UFc7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gdGhpcy5jdXJyZW50U2VyaWFsO1xyXG4gICAgICAgICAgICBsZXQgdGhlVVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgICAgICAvL05vdyBhZGQgYXMgbXVjaCBkYXRhIGFzIHdlIGNhbi5cclxuICAgICAgICAgICAgbGV0IGN1ckRhdGFTdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0LCBsZXRzIHNlZSBpZiB0aGUgbmV4dCBzZWdtZW50IHdpbGwgZml0LlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFNlZyA9IHRoaXMucGVuZGluZ1NlZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlZy5kLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgU0VHX0hFQURFUl9TSVpFICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nLmxlbmd0aCA8PVxyXG4gICAgICAgICAgICAgICAgICAgIE1BWF9VUkxfREFUQV9TSVpFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ncmVhdCwgdGhlIHNlZ21lbnQgd2lsbCBmaXQuIExldHMgYXBwZW5kIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoZVNlZyA9IHRoaXMucGVuZGluZ1NlZ3Muc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRGF0YVN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVF9OVU1fUEFSQU0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnNlZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVFNfSU5fUEFDS0VUICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy50cyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfREFUQV9QQVJBTSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcuZDtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGVVUkwgPSB0aGVVUkwgKyBjdXJEYXRhU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLmFkZExvbmdQb2xsVGFnXyh0aGVVUkwsIHRoaXMuY3VycmVudFNlcmlhbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUXVldWUgYSBwYWNrZXQgZm9yIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHNlZ251bSAtIEEgc2VxdWVudGlhbCBpZCBmb3IgdGhpcyBwYWNrZXQgc2VnbWVudCB1c2VkIGZvciByZWFzc2VtYmx5XHJcbiAgICAgKiBAcGFyYW0gdG90YWxzZWdzIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhY2tldFxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSBmb3IgdGhpcyBzZWdtZW50LlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlU2VnbWVudChzZWdudW0sIHRvdGFsc2VncywgZGF0YSkge1xyXG4gICAgICAgIC8vYWRkIHRoaXMgdG8gdGhlIHF1ZXVlIG9mIHNlZ21lbnRzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nU2Vncy5wdXNoKHsgc2VnOiBzZWdudW0sIHRzOiB0b3RhbHNlZ3MsIGQ6IGRhdGEgfSk7XHJcbiAgICAgICAgLy9zZW5kIHRoZSBkYXRhIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGlzbid0IGFscmVhZHkgZGF0YSBiZWluZyB0cmFuc21pdHRlZCwgdW5sZXNzXHJcbiAgICAgICAgLy9zdGFydExvbmdQb2xsIGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXHJcbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdSZXF1ZXN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NyaXB0IHRhZyBmb3IgYSByZWd1bGFyIGxvbmctcG9sbCByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2YgdGhlIHNjcmlwdCB0YWcuXHJcbiAgICAgKiBAcGFyYW0gc2VyaWFsIC0gVGhlIHNlcmlhbCBudW1iZXIgb2YgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGFkZExvbmdQb2xsVGFnXyh1cmwsIHNlcmlhbCkge1xyXG4gICAgICAgIC8vcmVtZW1iZXIgdGhhdCB3ZSBzZW50IHRoaXMgcmVxdWVzdC5cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuYWRkKHNlcmlhbCk7XHJcbiAgICAgICAgY29uc3QgZG9OZXdSZXF1ZXN0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuZGVsZXRlKHNlcmlhbCk7XHJcbiAgICAgICAgICAgIHRoaXMubmV3UmVxdWVzdF8oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIElmIHRoaXMgcmVxdWVzdCBkb2Vzbid0IHJldHVybiBvbiBpdHMgb3duIGFjY29yZCAoYnkgdGhlIHNlcnZlciBzZW5kaW5nIHVzIHNvbWUgZGF0YSksIHdlJ2xsXHJcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IG9uZSBhZnRlciB0aGUgS0VFUEFMSVZFIGludGVydmFsIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMga2VlcCBhIGZyZXNoIHJlcXVlc3Qgb3Blbi5cclxuICAgICAgICBjb25zdCBrZWVwYWxpdmVUaW1lb3V0ID0gc2V0VGltZW91dChkb05ld1JlcXVlc3QsIE1hdGguZmxvb3IoS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwpKTtcclxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ0IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgY29tcGxldGVkLiAgQ2FuY2VsIHRoZSBrZWVwYWxpdmUuXHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVwYWxpdmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciBhIG5ldyByZXF1ZXN0IHNvIHdlIGNhbiBjb250aW51ZSByZWNlaXZpbmcgZGF0YS5cclxuICAgICAgICAgICAgZG9OZXdSZXF1ZXN0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZFRhZyh1cmwsIHJlYWR5U3RhdGVDQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBhcmJpdHJhcnkgc2NyaXB0IHRhZyB0byB0aGUgaWZyYW1lLlxyXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgZm9yIHRoZSBzY3JpcHQgdGFnIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSBsb2FkQ0IgLSBBIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSBzY3JpcHQgaGFzIGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkVGFnKHVybCwgbG9hZENCKSB7XHJcbiAgICAgICAgaWYgKGlzTm9kZVNkaygpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHRoaXMuZG9Ob2RlTG9uZ1BvbGwodXJsLCBsb2FkQ0IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGFscmVhZHkgY2xvc2VkLCBkb24ndCBhZGQgdGhpcyBwb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbmROZXdQb2xscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NjcmlwdCA9IHRoaXMubXlJRnJhbWUuZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQuc3JjID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IG5ld1NjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnN0YXRlID0gbmV3U2NyaXB0LnJlYWR5U3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJzdGF0ZSB8fCByc3RhdGUgPT09ICdsb2FkZWQnIHx8IHJzdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IG5ld1NjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTY3JpcHQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXdTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ0IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCdMb25nLXBvbGwgc2NyaXB0IGZhaWxlZCB0byBsb2FkOiAnICsgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuYm9keS5hcHBlbmRDaGlsZChuZXdTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgbWFrZSB0aGlzIGVycm9yIHZpc2libGUgc29tZWhvd1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDEpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFID0gMTYzODQ7XHJcbmNvbnN0IFdFQlNPQ0tFVF9LRUVQQUxJVkVfSU5URVJWQUwgPSA0NTAwMDtcclxubGV0IFdlYlNvY2tldEltcGwgPSBudWxsO1xyXG5pZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBNb3pXZWJTb2NrZXQ7XHJcbn1cclxuZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBXZWJTb2NrZXQ7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyB3ZWJzb2NrZXQgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja3MuXHJcbiAqL1xyXG5jbGFzcyBXZWJTb2NrZXRDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbm5JZCBpZGVudGlmaWVyIGZvciB0aGlzIHRyYW5zcG9ydFxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIFRoZSBpbmZvIGZvciB0aGUgd2Vic29ja2V0IGVuZHBvaW50LlxyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWQgVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0LlxyXG4gICAgICogQHBhcmFtIGFwcENoZWNrVG9rZW4gVGhlIEFwcCBDaGVjayBUb2tlbiBmb3IgdGhpcyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuIFRoZSBBdXRoIFRva2VuIGZvciB0aGlzIGNsaWVudC5cclxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZ1xyXG4gICAgICogdG8gYW4gZXhpc3RpbmcgdHJhbnNwb3J0IHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXNcclxuICAgICAqIGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29ubklkLCByZXBvSW5mbywgYXBwbGljYXRpb25JZCwgYXBwQ2hlY2tUb2tlbiwgYXV0aFRva2VuLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLmNvbm5JZCA9IGNvbm5JZDtcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbiA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdXRoVG9rZW47XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9nXyA9IGxvZ1dyYXBwZXIodGhpcy5jb25uSWQpO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XHJcbiAgICAgICAgdGhpcy5jb25uVVJMID0gV2ViU29ja2V0Q29ubmVjdGlvbi5jb25uZWN0aW9uVVJMXyhyZXBvSW5mbywgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkLCBhcHBDaGVja1Rva2VuLCBhcHBsaWNhdGlvbklkKTtcclxuICAgICAgICB0aGlzLm5vZGVBZG1pbiA9IHJlcG9JbmZvLm5vZGVBZG1pbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIC0gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0U2Vzc2lvbklkIC0gT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCAtIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxyXG4gICAgICogQHJldHVybnMgY29ubmVjdGlvbiB1cmxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbm5lY3Rpb25VUkxfKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQsIGFwcENoZWNrVG9rZW4sIGFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICB1cmxQYXJhbXNbVkVSU0lPTl9QQVJBTV0gPSBQUk9UT0NPTF9WRVJTSU9OO1xyXG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICBsb2NhdGlvbi5ob3N0bmFtZSAmJlxyXG4gICAgICAgICAgICBGT1JHRV9ET01BSU5fUkUudGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhbnNwb3J0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTV0gPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSBhcHBDaGVja1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbQVBQTElDQVRJT05fSURfUEFSQU1dID0gYXBwbGljYXRpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgV0VCU09DS0VULCB1cmxQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cclxuICAgICAqL1xyXG4gICAgb3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMub25NZXNzYWdlID0gb25NZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RpbmcgdG8gJyArIHRoaXMuY29ublVSTCk7XHJcbiAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEFzc3VtZSBmYWlsdXJlIHVudGlsIHByb3ZlbiBvdGhlcndpc2UuXHJcbiAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScsIHRydWUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBvcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMubm9kZUFkbWluID8gJ0FkbWluTm9kZScgOiAnTm9kZSc7XHJcbiAgICAgICAgICAgICAgICAvLyBVQSBGb3JtYXQ6IEZpcmViYXNlLzx3aXJlX3Byb3RvY29sPi88c2RrX3ZlcnNpb24+LzxwbGF0Zm9ybT4vPGRldmljZT5cclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IGBGaXJlYmFzZS8ke1BST1RPQ09MX1ZFUlNJT059LyR7U0RLX1ZFUlNJT059LyR7cHJvY2Vzcy5wbGF0Zm9ybX0vJHtkZXZpY2V9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtRmlyZWJhc2UtR01QSUQnOiB0aGlzLmFwcGxpY2F0aW9uSWQgfHwgJydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgTm9kZSB3aXRoIGFkbWluIGNyZWRzLCBBcHBDaGVjay1yZWxhdGVkIGNoZWNrcyBhcmUgdW5uZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugc2VuZCB0aGUgY3JlZGVudGlhbHMgaGVyZSBldmVuIGlmIHRoZXkgYXJlbid0IGFkbWluIGNyZWRlbnRpYWxzLCB3aGljaCBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgcHJvYmxlbS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGhlYWRlciBpcyBqdXN0IHVzZWQgdG8gYnlwYXNzIGFwcGNoZWNrLCBhbmQgdGhlIHRva2VuIHNob3VsZCBzdGlsbCBiZSBzZW50XHJcbiAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBvbmNlIGl0IGlzIGVzdGFibGlzaGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5hdXRoVG9rZW59YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXSA9IHRoaXMuYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFBsdW1iIGFwcHJvcHJpYXRlIGh0dHBfcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgaW50byBmYXllLXdlYnNvY2tldCBpZiBpdCBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBwcm9jZXNzWydlbnYnXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gdGhpcy5jb25uVVJMLmluZGV4T2YoJ3dzczovLycpID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBlbnZbJ0hUVFBTX1BST1hZJ10gfHwgZW52WydodHRwc19wcm94eSddXHJcbiAgICAgICAgICAgICAgICAgICAgOiBlbnZbJ0hUVFBfUFJPWFknXSB8fCBlbnZbJ2h0dHBfcHJveHknXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm94eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3Byb3h5J10gPSB7IG9yaWdpbjogcHJveHkgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG5ldyBXZWJTb2NrZXRJbXBsKHRoaXMuY29ublVSTCwgW10sIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Vycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LicpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGUubWVzc2FnZSB8fCBlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXlTb2NrLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGVkLicpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRpc2Nvbm5lY3RlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5teVNvY2sub25tZXNzYWdlID0gbSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdGcmFtZShtKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9uZXJyb3IgPSBlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZS5tZXNzYWdlIHx8IGUuZGF0YTtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTm8tb3AgZm9yIHdlYnNvY2tldHMsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBjb25maXJtZWQgYXMgb3BlblxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHsgfVxyXG4gICAgc3RhdGljIGZvcmNlRGlzYWxsb3coKSB7XHJcbiAgICAgICAgV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XHJcbiAgICAgICAgbGV0IGlzT2xkQW5kcm9pZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEFuZHJvaWRSZWdleCA9IC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLztcclxuICAgICAgICAgICAgY29uc3Qgb2xkQW5kcm9pZE1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChvbGRBbmRyb2lkUmVnZXgpO1xyXG4gICAgICAgICAgICBpZiAob2xkQW5kcm9pZE1hdGNoICYmIG9sZEFuZHJvaWRNYXRjaC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChvbGRBbmRyb2lkTWF0Y2hbMV0pIDwgNC40KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNPbGRBbmRyb2lkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCFpc09sZEFuZHJvaWQgJiZcclxuICAgICAgICAgICAgV2ViU29ja2V0SW1wbCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAhV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93Xyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBwcmV2aW91c2x5IGZhaWxlZCB0byBjb25uZWN0IHdpdGggdGhpcyB0cmFuc3BvcnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwcmV2aW91c2x5RmFpbGVkKCkge1xyXG4gICAgICAgIC8vIElmIG91ciBwZXJzaXN0ZW50IHN0b3JhZ2UgaXMgYWN0dWFsbHkgb25seSBpbi1tZW1vcnkgc3RvcmFnZSxcclxuICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIGFzc3VtaW5nIHRoYXQgaXQgcHJldmlvdXNseSBmYWlsZWQgdG8gYmUgc2FmZS5cclxuICAgICAgICByZXR1cm4gKFBlcnNpc3RlbnRTdG9yYWdlLmlzSW5NZW1vcnlTdG9yYWdlIHx8XHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLmdldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKSA9PT0gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXJrQ29ubmVjdGlvbkhlYWx0aHkoKSB7XHJcbiAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2UucmVtb3ZlKCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScpO1xyXG4gICAgfVxyXG4gICAgYXBwZW5kRnJhbWVfKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmZyYW1lcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcy5sZW5ndGggPT09IHRoaXMudG90YWxGcmFtZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZnVsbE1lc3MgPSB0aGlzLmZyYW1lcy5qb2luKCcnKTtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBqc29uTWVzcyA9IGpzb25FdmFsKGZ1bGxNZXNzKTtcclxuICAgICAgICAgICAgLy9oYW5kbGUgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoanNvbk1lc3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZyYW1lQ291bnQgLSBUaGUgbnVtYmVyIG9mIGZyYW1lcyB3ZSBhcmUgZXhwZWN0aW5nIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBoYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGZyYW1lQ291bnQ7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgYSBmcmFtZSBjb3VudCBvdXQgb2Ygc29tZSB0ZXh0LiBJZiBpdCBjYW4ndCwgYXNzdW1lcyBhIHZhbHVlIG9mIDFcclxuICAgICAqIEByZXR1cm5zIEFueSByZW1haW5pbmcgZGF0YSB0byBiZSBwcm9jZXNzLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmVcclxuICAgICAqL1xyXG4gICAgZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5mcmFtZXMgPT09IG51bGwsICdXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXInKTtcclxuICAgICAgICAvLyBUT0RPOiBUaGUgc2VydmVyIGlzIG9ubHkgc3VwcG9zZWQgdG8gc2VuZCB1cCB0byA5OTk5IGZyYW1lcyAoaS5lLiBsZW5ndGggPD0gNCksIGJ1dCB0aGF0IGlzbid0IGJlaW5nIGVuZm9yY2VkXHJcbiAgICAgICAgLy8gY3VycmVudGx5LiAgU28gYWxsb3dpbmcgbGFyZ2VyIGZyYW1lIGNvdW50cyAobGVuZ3RoIDw9IDYpLiAgU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wL3NlYXJjaC84Njg4NTk4OTk4MzgwLzgyMzc2MDgwNDI1MDhcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gNikge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFtZUNvdW50ID0gTnVtYmVyKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGZyYW1lQ291bnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU5ld0ZyYW1lQ291bnRfKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XygxKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyBhIHdlYnNvY2tldCBmcmFtZSB0aGF0IGhhcyBhcnJpdmVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBtZXNzIC0gVGhlIGZyYW1lIGRhdGFcclxuICAgICAqL1xyXG4gICAgaGFuZGxlSW5jb21pbmdGcmFtZShtZXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubXlTb2NrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gQ2hyb21lIGFwcGFyZW50bHkgZGVsaXZlcnMgaW5jb21pbmcgcGFja2V0cyBldmVuIGFmdGVyIHdlIC5jbG9zZSgpIHRoZSBjb25uZWN0aW9uIHNvbWV0aW1lcy5cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IG1lc3NbJ2RhdGEnXTtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB3ZSdyZSBidWZmZXJpbmdcclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0cnkgdG8gcGFyc2Ugb3V0IGEgZnJhbWUgY291bnQsIG90aGVyd2lzZSwgYXNzdW1lIDEgYW5kIHByb2Nlc3MgaXRcclxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGF0YSA9IHRoaXMuZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8ocmVtYWluaW5nRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXJcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIEpTT04gb2JqZWN0IHRvIHRyYW5zbWl0XHJcbiAgICAgKi9cclxuICAgIHNlbmQoZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcclxuICAgICAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XHJcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIHdlYnNvY2tldCBmcmFtZSwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcclxuICAgICAgICAvL3VwIGludG8gbXVsdGlwbGUgcGllY2VzIGlmIGl0IGRvZXNuJ3QgZml0IGluIG9uZSByZXF1ZXN0LlxyXG4gICAgICAgIGNvbnN0IGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoZGF0YVN0ciwgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFKTtcclxuICAgICAgICAvL1NlbmQgdGhlIGxlbmd0aCBoZWFkZXJcclxuICAgICAgICBpZiAoZGF0YVNlZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKFN0cmluZyhkYXRhU2Vncy5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9TZW5kIHRoZSBhY3R1YWwgZGF0YSBpbiBzZWdtZW50cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oZGF0YVNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNodXRkb3duXygpIHtcclxuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm15U29jaykge1xyXG4gICAgICAgICAgICB0aGlzLm15U29jay5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25DbG9zZWRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGYnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhbiBpbnRlcm5hbCBjbG9zZSwgdHJpZ2dlciB0aGUgY2xvc2UgbGlzdGVuZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCh0aGlzLmV2ZXJDb25uZWN0ZWRfKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuXHJcbiAgICAgKiBDbG9zZSB0aGUgd2Vic29ja2V0IGFuZCBraWxsIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogS2lsbCB0aGUgY3VycmVudCBrZWVwYWxpdmUgdGltZXIgYW5kIHN0YXJ0IGEgbmV3IG9uZSwgdG8gZW5zdXJlIHRoYXQgaXQgYWx3YXlzIGZpcmVzIE4gc2Vjb25kcyBhZnRlclxyXG4gICAgICogdGhlIGxhc3QgYWN0aXZpdHkuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0S2VlcEFsaXZlKCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgLy9JZiB0aGVyZSBoYXMgYmVlbiBubyB3ZWJzb2NrZXQgYWN0aXZpdHkgZm9yIGEgd2hpbGUsIHNlbmQgYSBuby1vcFxyXG4gICAgICAgICAgICBpZiAodGhpcy5teVNvY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBzdHJpbmcgb3ZlciB0aGUgd2Vic29ja2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gc2VuZC5cclxuICAgICAqL1xyXG4gICAgc2VuZFN0cmluZ18oc3RyKSB7XHJcbiAgICAgICAgLy8gRmlyZWZveCBzZWVtcyB0byBzb21ldGltZXMgdGhyb3cgZXhjZXB0aW9ucyAoTlNfRVJST1JfVU5FWFBFQ1RFRCkgZnJvbSB3ZWJzb2NrZXQgLnNlbmQoKVxyXG4gICAgICAgIC8vIGNhbGxzIGZvciBzb21lIHVua25vd24gcmVhc29uLiAgV2UgdHJlYXQgdGhlc2UgYXMgYW4gZXJyb3IgYW5kIGRpc2Nvbm5lY3QuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wLzU4OTI2MTExNDAyMjkyLzY4MDIxMzQwMjUwNDEwXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2suc2VuZChzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0V4Y2VwdGlvbiB0aHJvd24gZnJvbSBXZWJTb2NrZXQuc2VuZCgpOicsIGUubWVzc2FnZSB8fCBlLmRhdGEsICdDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5vbkNsb3NlZF8uYmluZCh0aGlzKSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBOdW1iZXIgb2YgcmVzcG9uc2UgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIFwiaGVhbHRoeS5cIlxyXG4gKi9cclxuV2ViU29ja2V0Q29ubmVjdGlvbi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5ID0gMjtcclxuLyoqXHJcbiAqIFRpbWUgdG8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdGUgYmVjb21lIGhlYWx0aHkgYmVmb3JlIGdpdmluZyB1cC5cclxuICovXHJcbldlYlNvY2tldENvbm5lY3Rpb24uaGVhbHRoeVRpbWVvdXQgPSAzMDAwMDtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEN1cnJlbnRseSBzaW1wbGlzdGljLCB0aGlzIGNsYXNzIG1hbmFnZXMgd2hhdCB0cmFuc3BvcnQgYSBDb25uZWN0aW9uIHNob3VsZCB1c2UgYXQgdmFyaW91cyBzdGFnZXMgb2YgaXRzXHJcbiAqIGxpZmVjeWNsZS5cclxuICpcclxuICogSXQgc3RhcnRzIHdpdGggbG9uZ3BvbGxpbmcgaW4gYSBicm93c2VyLCBhbmQgaHR0cHBvbGxpbmcgb24gbm9kZS4gSXQgdGhlbiB1cGdyYWRlcyB0byB3ZWJzb2NrZXRzIGlmXHJcbiAqIHRoZXkgYXJlIGF2YWlsYWJsZS5cclxuICovXHJcbmNsYXNzIFRyYW5zcG9ydE1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gLSBNZXRhZGF0YSBhcm91bmQgdGhlIG5hbWVzcGFjZSB3ZSdyZSBjb25uZWN0aW5nIHRvXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvKSB7XHJcbiAgICAgICAgdGhpcy5pbml0VHJhbnNwb3J0c18ocmVwb0luZm8pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBBTExfVFJBTlNQT1JUUygpIHtcclxuICAgICAgICByZXR1cm4gW0Jyb3dzZXJQb2xsQ29ubmVjdGlvbiwgV2ViU29ja2V0Q29ubmVjdGlvbl07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0cmFuc3BvcnQgaGFzIGJlZW4gc2VsZWN0ZWQgdG8gZW5zdXJlIFdlYlNvY2tldENvbm5lY3Rpb24gb3IgQnJvd3NlclBvbGxDb25uZWN0aW9uIGFyZSBub3QgY2FsbGVkIGFmdGVyXHJcbiAgICAgKiBUcmFuc3BvcnRNYW5hZ2VyIGhhcyBhbHJlYWR5IHNldCB1cCB0cmFuc3BvcnRzX1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IElTX1RSQU5TUE9SVF9JTklUSUFMSVpFRCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF87XHJcbiAgICB9XHJcbiAgICBpbml0VHJhbnNwb3J0c18ocmVwb0luZm8pIHtcclxuICAgICAgICBjb25zdCBpc1dlYlNvY2tldHNBdmFpbGFibGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uICYmIFdlYlNvY2tldENvbm5lY3Rpb25bJ2lzQXZhaWxhYmxlJ10oKTtcclxuICAgICAgICBsZXQgaXNTa2lwUG9sbENvbm5lY3Rpb24gPSBpc1dlYlNvY2tldHNBdmFpbGFibGUgJiYgIVdlYlNvY2tldENvbm5lY3Rpb24ucHJldmlvdXNseUZhaWxlZCgpO1xyXG4gICAgICAgIGlmIChyZXBvSW5mby53ZWJTb2NrZXRPbmx5KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNXZWJTb2NrZXRzQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc1NraXBQb2xsQ29ubmVjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1NraXBQb2xsQ29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHNfID0gW1dlYlNvY2tldENvbm5lY3Rpb25dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0cyA9ICh0aGlzLnRyYW5zcG9ydHNfID0gW10pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zcG9ydCBvZiBUcmFuc3BvcnRNYW5hZ2VyLkFMTF9UUkFOU1BPUlRTKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0ICYmIHRyYW5zcG9ydFsnaXNBdmFpbGFibGUnXSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJhbnNwb3J0TWFuYWdlci5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgaW5pdGlhbCB0cmFuc3BvcnQgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxUcmFuc3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIG5leHQgdHJhbnNwb3J0LCBvciBudWxsXHJcbiAgICAgKi9cclxuICAgIHVwZ3JhZGVUcmFuc3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0c18ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSBUcmFuc3BvcnRNYW5hZ2VyIGhhcyBhbHJlYWR5IGNob3NlbiBhIHRyYW5zcG9ydCB0byB1c2VcclxuVHJhbnNwb3J0TWFuYWdlci5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8gPSBmYWxzZTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQWJvcnQgdXBncmFkZSBhdHRlbXB0IGlmIGl0IHRha2VzIGxvbmdlciB0aGFuIDYwcy5cclxuY29uc3QgVVBHUkFERV9USU1FT1VUID0gNjAwMDA7XHJcbi8vIEZvciBzb21lIHRyYW5zcG9ydHMgKFdlYlNvY2tldHMpLCB3ZSBuZWVkIHRvIFwidmFsaWRhdGVcIiB0aGUgdHJhbnNwb3J0IGJ5IGV4Y2hhbmdpbmcgYSBmZXcgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy5cclxuLy8gSWYgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB3aXRoaW4gNXMsIHdlJ2xsIHN0YXJ0IHNlbmRpbmcgbm9vcCBwaW5nIHJlcXVlc3RzLlxyXG5jb25zdCBERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUyA9IDUwMDA7XHJcbi8vIElmIHRoZSBpbml0aWFsIGRhdGEgc2VudCB0cmlnZ2VycyBhIGxvdCBvZiBiYW5kd2lkdGggKGkuZS4gaXQncyBhIGxhcmdlIHB1dCBvciBhIGxpc3RlbiBmb3IgYSBsYXJnZSBhbW91bnQgb2YgZGF0YSlcclxuLy8gdGhlbiB3ZSBtYXkgbm90IGJlIGFibGUgdG8gZXhjaGFuZ2Ugb3VyIHBpbmcvcG9uZyByZXF1ZXN0cyB3aXRoaW4gdGhlIGhlYWx0aHkgdGltZW91dC4gIFNvIGlmIHdlIHJlYWNoIHRoZSB0aW1lb3V0XHJcbi8vIGJ1dCB3ZSd2ZSBzZW50L3JlY2VpdmVkIGVub3VnaCBieXRlcywgd2UgZG9uJ3QgY2FuY2VsIHRoZSBjb25uZWN0aW9uLlxyXG5jb25zdCBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUgPSAxMCAqIDEwMjQ7XHJcbmNvbnN0IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUgPSAxMDAgKiAxMDI0O1xyXG5jb25zdCBNRVNTQUdFX1RZUEUgPSAndCc7XHJcbmNvbnN0IE1FU1NBR0VfREFUQSA9ICdkJztcclxuY29uc3QgQ09OVFJPTF9TSFVURE9XTiA9ICdzJztcclxuY29uc3QgQ09OVFJPTF9SRVNFVCA9ICdyJztcclxuY29uc3QgQ09OVFJPTF9FUlJPUiA9ICdlJztcclxuY29uc3QgQ09OVFJPTF9QT05HID0gJ28nO1xyXG5jb25zdCBTV0lUQ0hfQUNLID0gJ2EnO1xyXG5jb25zdCBFTkRfVFJBTlNNSVNTSU9OID0gJ24nO1xyXG5jb25zdCBQSU5HID0gJ3AnO1xyXG5jb25zdCBTRVJWRVJfSEVMTE8gPSAnaCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWwtdGltZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgdXNpbmcgd2hpY2hldmVyIG1ldGhvZCB3b3Jrc1xyXG4gKiBiZXN0IGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXHJcbiAqL1xyXG5jbGFzcyBDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkIC0gYW4gaWQgZm9yIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIHRoZSBpbmZvIGZvciB0aGUgZW5kcG9pbnQgdG8gY29ubmVjdCB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gdGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbl8gLSBUaGUgQXBwIENoZWNrIFRva2VuIGZvciB0aGlzIGRldmljZS5cclxuICAgICAqIEBwYXJhbSBhdXRoVG9rZW5fIC0gVGhlIGF1dGggdG9rZW4gZm9yIHRoaXMgc2Vzc2lvbi5cclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgc2VydmVyLXB1c2ggbWVzc2FnZSBhcnJpdmVzXHJcbiAgICAgKiBAcGFyYW0gb25SZWFkeV8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGlzIHJlYWR5IHRvIHNlbmQgbWVzc2FnZXMuXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiBhIGNvbm5lY3Rpb24gd2FzIGxvc3RcclxuICAgICAqIEBwYXJhbSBvbktpbGxfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBoYXMgcGVybWFuZW50bHkgc2h1dCBkb3duLlxyXG4gICAgICogQHBhcmFtIGxhc3RTZXNzaW9uSWQgLSBsYXN0IHNlc3Npb24gaWQgaW4gcGVyc2lzdGVudCBjb25uZWN0aW9uLiBpcyB1c2VkIHRvIGNsZWFuIHVwIG9sZCBzZXNzaW9uIGluIHJlYWwtdGltZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHJlcG9JbmZvXywgYXBwbGljYXRpb25JZF8sIGFwcENoZWNrVG9rZW5fLCBhdXRoVG9rZW5fLCBvbk1lc3NhZ2VfLCBvblJlYWR5Xywgb25EaXNjb25uZWN0Xywgb25LaWxsXywgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWRfID0gYXBwbGljYXRpb25JZF87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IGFwcENoZWNrVG9rZW5fO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IGF1dGhUb2tlbl87XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfID0gb25NZXNzYWdlXztcclxuICAgICAgICB0aGlzLm9uUmVhZHlfID0gb25SZWFkeV87XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0XztcclxuICAgICAgICB0aGlzLm9uS2lsbF8gPSBvbktpbGxfO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IGxhc3RTZXNzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMCAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcgKi87XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcignYzonICsgdGhpcy5pZCArICc6Jyk7XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyXyA9IG5ldyBUcmFuc3BvcnRNYW5hZ2VyKHJlcG9JbmZvXyk7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGNyZWF0ZWQnKTtcclxuICAgICAgICB0aGlzLnN0YXJ0XygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBjb25uZWN0aW9uIGF0dGVtcHRcclxuICAgICAqL1xyXG4gICAgc3RhcnRfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLmluaXRpYWxUcmFuc3BvcnQoKTtcclxuICAgICAgICB0aGlzLmNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIG51bGwsIHRoaXMubGFzdFNlc3Npb25JZCk7XHJcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXHJcbiAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID0gY29ublsncmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSddIHx8IDA7XHJcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlUmVjZWl2ZWQgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5jb25uXyk7XHJcbiAgICAgICAgY29uc3Qgb25Db25uZWN0aW9uTG9zdCA9IHRoaXMuZGlzY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcclxuICAgICAgICB0aGlzLnR4XyA9IHRoaXMuY29ubl87XHJcbiAgICAgICAgdGhpcy5yeF8gPSB0aGlzLmNvbm5fO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IGZhbHNlO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRmlyZWZveCBkb2Vzbid0IGxpa2Ugd2hlbiBjb2RlIGZyb20gb25lIGlmcmFtZSB0cmllcyB0byBjcmVhdGUgYW5vdGhlciBpZnJhbWUgYnkgd2F5IG9mIHRoZSBwYXJlbnQgZnJhbWUuXHJcbiAgICAgICAgICogVGhpcyBjYW4gb2NjdXIgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgaS5lLiB3ZSBndWVzc2VkIHdyb25nIG9uIHdoYXQgc2VydmVyIHRvIGNvbm5lY3QgdG8gYW5kIHJlY2VpdmVkIGEgcmVzZXQuXHJcbiAgICAgICAgICogU29tZWhvdywgc2V0VGltZW91dCBzZWVtcyB0byBtYWtlIHRoaXMgb2suIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIGZyb20gYSBzZWN1cml0eSBwZXJzcGVjdGl2ZSwgc2luY2UgeW91IHNob3VsZFxyXG4gICAgICAgICAqIHN0aWxsIGhhdmUgdGhlIGNvbnRleHQgb2YgeW91ciBvcmlnaW5hdGluZyBmcmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gdGhpcy5jb25uXyBnZXRzIHNldCB0byBudWxsIGluIHNvbWUgb2YgdGhlIHRlc3RzLiBDaGVjayB0byBtYWtlIHN1cmUgaXQgc3RpbGwgZXhpc3RzIGJlZm9yZSB1c2luZyBpdFxyXG4gICAgICAgICAgICB0aGlzLmNvbm5fICYmIHRoaXMuY29ubl8ub3Blbihvbk1lc3NhZ2VSZWNlaXZlZCwgb25Db25uZWN0aW9uTG9zdCk7XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICAgICAgY29uc3QgaGVhbHRoeVRpbWVvdXRNUyA9IGNvbm5bJ2hlYWx0aHlUaW1lb3V0J10gfHwgMDtcclxuICAgICAgICBpZiAoaGVhbHRoeVRpbWVvdXRNUyA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uXyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzUmVjZWl2ZWQgPiBCWVRFU19SRUNFSVZFRF9IRUFMVEhZX09WRVJSSURFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyByZWNlaXZlZCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNSZWNlaXZlZCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29ubl8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5ieXRlc1NlbnQgPiBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHNlbnQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzU2VudCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTGVhdmluZyBjb25uZWN0aW9uIGFsaXZlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCB3YW50IHRvIG1hcmsgaXQgaGVhbHRoeSwgc2luY2Ugd2UgaGF2ZSBubyBndWFyYW50ZWUgdGhhdCB0aGUgYnl0ZXMgaGF2ZSBtYWRlIGl0IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0Nsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoaGVhbHRoeVRpbWVvdXRNUykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5leHRUcmFuc3BvcnRJZF8oKSB7XHJcbiAgICAgICAgcmV0dXJuICdjOicgKyB0aGlzLmlkICsgJzonICsgdGhpcy5jb25uZWN0aW9uQ291bnQrKztcclxuICAgIH1cclxuICAgIGRpc2Nvbm5SZWNlaXZlcl8oY29ubikge1xyXG4gICAgICAgIHJldHVybiBldmVyQ29ubmVjdGVkID0+IHtcclxuICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMuY29ubl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uTG9zdF8oZXZlckNvbm5lY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdTZWNvbmRhcnkgY29ubmVjdGlvbiBsb3N0LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29ublJlY2VpdmVyXyhjb25uKSB7XHJcbiAgICAgICAgcmV0dXJuIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMiAvKiBSZWFsdGltZVN0YXRlLkRJU0NPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMucnhfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdtZXNzYWdlIG9uIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZGF0YU1zZyAtIEFuIGFyYml0cmFyeSBkYXRhIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIHNlbmRSZXF1ZXN0KGRhdGFNc2cpIHtcclxuICAgICAgICAvLyB3cmFwIGluIGEgZGF0YSBtZXNzYWdlIGVudmVsb3BlIGFuZCBzZW5kIGl0IG9uXHJcbiAgICAgICAgY29uc3QgbXNnID0geyB0OiAnZCcsIGQ6IGRhdGFNc2cgfTtcclxuICAgICAgICB0aGlzLnNlbmREYXRhXyhtc2cpO1xyXG4gICAgfVxyXG4gICAgdHJ5Q2xlYW51cENvbm5lY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fICYmIHRoaXMucnhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246ICcgKyB0aGlzLnNlY29uZGFyeUNvbm5fLmNvbm5JZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciB3aWxsIHNodXRkb3duIHRoZSBvbGQgY29ubmVjdGlvblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5Q29udHJvbF8oY29udHJvbERhdGEpIHtcclxuICAgICAgICBpZiAoTUVTU0FHRV9UWVBFIGluIGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGNvbnRyb2xEYXRhW01FU1NBR0VfVFlQRV07XHJcbiAgICAgICAgICAgIGlmIChjbWQgPT09IFNXSVRDSF9BQ0spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IHRoZSBzZXNzaW9uIHdhc24ndCB2YWxpZC4gQWJhbmRvbiB0aGUgc3dpdGNoIGF0dGVtcHRcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnR290IGEgcmVzZXQgb24gc2Vjb25kYXJ5LCBjbG9zaW5nIGl0Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFscmVhZHkgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGZvciBzb21ldGhpbmcsIHRoYW4gd2UgbmVlZCB0byBmdWxseSBjbG9zZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyhwYXJzZWREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgLy8gZ290IGEgZGF0YSBtZXNzYWdlLCBidXQgd2UncmUgc3RpbGwgc2Vjb25kIGNvbm5lY3Rpb24uIE5lZWQgdG8gYnVmZmVyIGl0IHVwXHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3RvY29sIGxheWVyOiAnICsgbGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZWVkV2l0aFVwZ3JhZGVfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTZW5kIGEgcGluZyB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZWVkV2l0aFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIC8vIHRlbGwgdGhpcyBjb25uZWN0aW9uIHRvIGNvbnNpZGVyIGl0c2VsZiBvcGVuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zdGFydCgpO1xyXG4gICAgICAgIC8vIHNlbmQgYWNrXHJcbiAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIGNsaWVudCBhY2sgb24gc2Vjb25kYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IFNXSVRDSF9BQ0ssIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgLy8gc2VuZCBlbmQgcGFja2V0IG9uIHByaW1hcnkgdHJhbnNwb3J0LCBzd2l0Y2ggdG8gc2VuZGluZyBvbiB0aGlzIG9uZVxyXG4gICAgICAgIC8vIGNhbiByZWNlaXZlIG9uIHRoaXMgb25lLCBidWZmZXIgcmVzcG9uc2VzIHVudGlsIGVuZCByZWNlaXZlZCBvbiBwcmltYXJ5IHRyYW5zcG9ydFxyXG4gICAgICAgIHRoaXMubG9nXygnRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IEVORF9UUkFOU01JU1NJT04sIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgdGhpcy50eF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuICAgIG9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8ocGFyc2VkRGF0YSkge1xyXG4gICAgICAgIC8vIE11c3QgcmVmZXIgdG8gcGFyc2VkRGF0YSBwcm9wZXJ0aWVzIGluIHF1b3Rlcywgc28gY2xvc3VyZSBkb2Vzbid0IHRvdWNoIHRoZW0uXHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcclxuICAgICAgICAvLyBXZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIGRhdGEgbWVzc2FnZXMsIGp1c3Qga2ljayB0aGVtIHVwIGEgbGV2ZWxcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8obWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBvblByaW1hcnlSZXNwb25zZV8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfLS07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25Db250cm9sXyhjb250cm9sRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNtZCA9IHJlcXVpcmVLZXkoTUVTU0FHRV9UWVBFLCBjb250cm9sRGF0YSk7XHJcbiAgICAgICAgaWYgKE1FU1NBR0VfREFUQSBpbiBjb250cm9sRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gY29udHJvbERhdGFbTUVTU0FHRV9EQVRBXTtcclxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU0VSVkVSX0hFTExPKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kc2hha2VQYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18uaXNVc2luZ0VtdWxhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBvbiBjb25uZWN0aW5nLCB0aGUgZW11bGF0b3Igd2lsbCBwYXNzIHRoZSBob3N0bmFtZSB0aGF0IGl0J3MgYXdhcmUgb2YsIGJ1dCB3ZSBwcmVmZXIgdGhlIHVzZXIncyBzZXQgaG9zdG5hbWUgdmlhIGBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcmAgb3ZlciB3aGF0IHRoZSBlbXVsYXRvciBwYXNzZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlUGF5bG9hZC5oID0gdGhpcy5yZXBvSW5mb18uaG9zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kc2hha2VfKGhhbmRzaGFrZVBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gRU5EX1RSQU5TTUlTU0lPTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdyZWN2ZCBlbmQgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnknKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucnhfID0gdGhpcy5zZWNvbmRhcnlDb25uXztcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyh0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUNsZWFudXBDb25uZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1NIVVRET1dOKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcyBwcmV2aW91c2x5IHRoZSAnb25LaWxsJyBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGxvd2VyLWxldmVsIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaW4gdGhpcyBjYXNlIGlzIHRoZSByZWFzb24gZm9yIHRoZSBzaHV0ZG93bi4gR2VuZXJhbGx5IGEgaHVtYW4tcmVhZGFibGUgZXJyb3JcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uU2h1dGRvd25fKHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9SRVNFVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIGhvc3Qgd2Ugc2hvdWxkIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHRoaXMub25SZXNldF8ocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX0VSUk9SKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignU2VydmVyIEVycm9yOiAnICsgcGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gcHJpbWFyeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25QcmltYXJ5UmVzcG9uc2VfKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiAnICsgY21kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGhhbmRzaGFrZSAtIFRoZSBoYW5kc2hha2UgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgb25IYW5kc2hha2VfKGhhbmRzaGFrZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGhhbmRzaGFrZS50cztcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaGFuZHNoYWtlLnY7XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGhhbmRzaGFrZS5oO1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gaGFuZHNoYWtlLnM7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgLy8gaWYgd2UndmUgYWxyZWFkeSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24sIHRoZW4gZG9uJ3QgYm90aGVyIHRyeWluZyB0byBwcm9ncmVzcyBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAwIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5fLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRXN0YWJsaXNoZWRfKHRoaXMuY29ubl8sIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIGlmIChQUk9UT0NPTF9WRVJTSU9OICE9PSB2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCdQcm90b2NvbCB2ZXJzaW9uIG1pc21hdGNoIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2Ugd2FudCB0byB1cGdyYWRlPyB3aGVuPyBtYXliZSBhIGRlbGF5P1xyXG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0VXBncmFkZV8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cnlTdGFydFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLnVwZ3JhZGVUcmFuc3BvcnQoKTtcclxuICAgICAgICBpZiAoY29ubikge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VXBncmFkZV8oY29ubik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRVcGdyYWRlXyhjb25uKSB7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG5ldyBjb25uKHRoaXMubmV4dFRyYW5zcG9ydElkXygpLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5hcHBsaWNhdGlvbklkXywgdGhpcy5hcHBDaGVja1Rva2VuXywgdGhpcy5hdXRoVG9rZW5fLCB0aGlzLnNlc3Npb25JZCk7XHJcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8gPVxyXG4gICAgICAgICAgICBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcclxuICAgICAgICBjb25zdCBvbk1lc3NhZ2UgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XHJcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuc2Vjb25kYXJ5Q29ubl8pO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8ub3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCk7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzdWNjZXNzZnVsbHkgdXBncmFkZWQgYWZ0ZXIgVVBHUkFERV9USU1FT1VULCBnaXZlIHVwIGFuZCBraWxsIHRoZSBzZWNvbmRhcnkuXHJcbiAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byB1cGdyYWRlLicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihVUEdSQURFX1RJTUVPVVQpKTtcclxuICAgIH1cclxuICAgIG9uUmVzZXRfKGhvc3QpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1Jlc2V0IHBhY2tldCByZWNlaXZlZC4gIE5ldyBob3N0OiAnICsgaG9zdCk7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgLy8gVE9ETzogaWYgd2UncmUgYWxyZWFkeSBcImNvbm5lY3RlZFwiLCB3ZSBuZWVkIHRvIHRyaWdnZXIgYSBkaXNjb25uZWN0IGF0IHRoZSBuZXh0IGxheWVyIHVwLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IHJlc2V0cyBhZnRlciB0aGUgY29ubmVjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGVzdGFibGlzaGVkXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAxIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENsb3NlIHdoYXRldmVyIGNvbm5lY3Rpb25zIHdlIGhhdmUgb3BlbiBhbmQgc3RhcnQgYWdhaW4uXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8oY29ubiwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkLicpO1xyXG4gICAgICAgIHRoaXMuY29ubl8gPSBjb25uO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLztcclxuICAgICAgICBpZiAodGhpcy5vblJlYWR5Xykge1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfKHRpbWVzdGFtcCwgdGhpcy5zZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYWZ0ZXIgNSBzZWNvbmRzIHdlIGhhdmVuJ3Qgc2VudCBlbm91Z2ggcmVxdWVzdHMgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIGNvbm5lY3Rpb24gaGVhbHRoeSxcclxuICAgICAgICAvLyBzZW5kIHNvbWUgcGluZ3MuXHJcbiAgICAgICAgaWYgKHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKTtcclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcihERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCkge1xyXG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzbid0IGNvbnNpZGVyZWQgaGVhbHRoeSB5ZXQsIHdlJ2xsIHNlbmQgYSBub29wIHBpbmcgcGFja2V0IHJlcXVlc3QuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8gJiYgdGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kRGF0YV8oeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpIHtcclxuICAgICAgICBjb25zdCBjb25uID0gdGhpcy5zZWNvbmRhcnlDb25uXztcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy50eF8gPT09IGNvbm4gfHwgdGhpcy5yeF8gPT09IGNvbm4pIHtcclxuICAgICAgICAgICAgLy8gd2UgYXJlIHJlbHlpbmcgb24gdGhpcyBjb25uZWN0aW9uIGFscmVhZHkgaW4gc29tZSBjYXBhY2l0eS4gVGhlcmVmb3JlLCBhIGZhaWx1cmUgaXMgcmVhbFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZlckNvbm5lY3RlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSBjb25uZWN0aW9uIGV2ZXIgcmVhY2hlZCBhIHNlcnZlci4gVXNlZCB0byBkZXRlcm1pbmUgaWZcclxuICAgICAqIHdlIHNob3VsZCBmbHVzaCB0aGUgaG9zdCBjYWNoZVxyXG4gICAgICovXHJcbiAgICBvbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XHJcbiAgICAgICAgLy8gTk9URTogSUYgeW91J3JlIHNlZWluZyBhIEZpcmVmb3ggZXJyb3IgZm9yIHRoaXMgbGluZSwgSSB0aGluayBpdCBtaWdodCBiZSBiZWNhdXNlIGl0J3MgZ2V0dGluZ1xyXG4gICAgICAgIC8vIGNhbGxlZCBvbiB3aW5kb3cgY2xvc2UgYW5kIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyBpcyBubyBsb25nZXIgZGVmaW5lZC4gIEp1c3QgYSBndWVzcy5cclxuICAgICAgICBpZiAoIWV2ZXJDb25uZWN0ZWQgJiYgdGhpcy5zdGF0ZV8gPT09IDAgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuJyk7XHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGZhaWxlZCB0byBjb25uZWN0IGF0IGFsbCwgY2xlYXIgYW55IGNhY2hlZCBlbnRyeSBmb3IgdGhpcyBuYW1lc3BhY2UgaW4gY2FzZSB0aGUgbWFjaGluZSB3ZW50IGF3YXlcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5yZW1vdmUoJ2hvc3Q6JyArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludGVybmFsIGhvc3QgdG8gd2hhdCB3ZSB3b3VsZCBzaG93IHRoZSB1c2VyLCBpLmUuIDxucz4uZmlyZWJhc2Vpby5jb21cclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmludGVybmFsSG9zdCA9IHRoaXMucmVwb0luZm9fLmhvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGxvc3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIG9uQ29ubmVjdGlvblNodXRkb3duXyhyZWFzb24pIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gc2h1dGRvd24gY29tbWFuZCByZWNlaXZlZC4gU2h1dHRpbmcgZG93bi4uLicpO1xyXG4gICAgICAgIGlmICh0aGlzLm9uS2lsbF8pIHtcclxuICAgICAgICAgICAgdGhpcy5vbktpbGxfKHJlYXNvbik7XHJcbiAgICAgICAgICAgIHRoaXMub25LaWxsXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3Qgd2FudCB0byBmaXJlIG9uRGlzY29ubmVjdCAoa2lsbCBpcyBhIGRpZmZlcmVudCBjYXNlKSxcclxuICAgICAgICAvLyBzbyBjbGVhciB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kRGF0YV8oZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aHJvdyAnQ29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHhfLnNlbmQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbnMgdXAgdGhpcyBjb25uZWN0aW9uLCBjYWxsaW5nIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAyIC8qIFJlYWx0aW1lU3RhdGUuRElTQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyByZWFsdGltZSBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlXyA9IDIgLyogUmVhbHRpbWVTdGF0ZS5ESVNDT05ORUNURUQgKi87XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvc2VDb25uZWN0aW9uc18oKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdTaHV0dGluZyBkb3duIGFsbCBjb25uZWN0aW9ucycpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhlYWx0aHlUaW1lb3V0Xykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFsdGh5VGltZW91dF8pO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgZGVmaW5pbmcgdGhlIHNldCBvZiBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBhZ2FpbnN0IHRoZSBGaXJlYmFzZSBzZXJ2ZXJcclxuICogKGJhc2ljYWxseSBjb3JyZXNwb25kcyB0byBvdXIgd2lyZSBwcm90b2NvbCkuXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFNlcnZlckFjdGlvbnMge1xyXG4gICAgcHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHsgfVxyXG4gICAgbWVyZ2UocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkgeyB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyB0aGUgYXV0aCB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRoZSBhdXRoZW50aWNhdGlvbiB0b2tlblxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQXV0aFRva2VuKHRva2VuKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBhcHAgY2hlY2sgdG9rZW4gZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIGFwcCBjaGVjayB0b2tlblxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQXBwQ2hlY2tUb2tlbih0b2tlbikgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RQdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RNZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIG9uRGlzY29ubmVjdENhbmNlbChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7IH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQmFzZSBjbGFzcyB0byBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIGVtaXQgZXZlbnRzLiBDYWxsIHRoZSBjb25zdHJ1Y3RvciB3aXRoXHJcbiAqIHRoZSBzZXQgb2YgYWxsb3dlZCBldmVudCBuYW1lcy5cclxuICovXHJcbmNsYXNzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhbGxvd2VkRXZlbnRzXykge1xyXG4gICAgICAgIHRoaXMuYWxsb3dlZEV2ZW50c18gPSBhbGxvd2VkRXZlbnRzXztcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc18gPSB7fTtcclxuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShhbGxvd2VkRXZlbnRzXykgJiYgYWxsb3dlZEV2ZW50c18ubGVuZ3RoID4gMCwgJ1JlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvIGJlIGNhbGxlZCBieSBkZXJpdmVkIGNsYXNzZXMgdG8gdHJpZ2dlciBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIHRyaWdnZXIoZXZlbnRUeXBlLCAuLi52YXJBcmdzKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0pKSB7XHJcbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBsaXN0LCBzaW5jZSBjYWxsYmFja3MgY291bGQgYWRkL3JlbW92ZSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFsuLi50aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbGJhY2suYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIHZhckFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb24oZXZlbnRUeXBlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSB8fCBbXTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXS5wdXNoKHsgY2FsbGJhY2ssIGNvbnRleHQgfSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gdGhpcy5nZXRJbml0aWFsRXZlbnQoZXZlbnRUeXBlKTtcclxuICAgICAgICBpZiAoZXZlbnREYXRhKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlRXZlbnRUeXBlXyhldmVudFR5cGUpO1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgICAgICAoIWNvbnRleHQgfHwgY29udGV4dCA9PT0gbGlzdGVuZXJzW2ldLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmFsbG93ZWRFdmVudHNfLmZpbmQoZXQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXQgPT09IGV2ZW50VHlwZTtcclxuICAgICAgICB9KSwgJ1Vua25vd24gZXZlbnQ6ICcgKyBldmVudFR5cGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNb25pdG9ycyBvbmxpbmUgc3RhdGUgKGFzIHJlcG9ydGVkIGJ5IHdpbmRvdy5vbmxpbmUvb2ZmbGluZSBldmVudHMpLlxyXG4gKlxyXG4gKiBUaGUgZXhwZWN0YXRpb24gaXMgdGhhdCB0aGlzIGNvdWxkIGhhdmUgbWFueSBmYWxzZSBwb3NpdGl2ZXMgKHRoaW5rcyB3ZSBhcmUgb25saW5lXHJcbiAqIHdoZW4gd2UncmUgbm90KSwgYnV0IG5vIGZhbHNlIG5lZ2F0aXZlcy4gIFNvIHdlIGNhbiBzYWZlbHkgdXNlIGl0IHRvIGRldGVybWluZSB3aGVuXHJcbiAqIHdlIGRlZmluaXRlbHkgY2Fubm90IHJlYWNoIHRoZSBpbnRlcm5ldC5cclxuICovXHJcbmNsYXNzIE9ubGluZU1vbml0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoWydvbmxpbmUnXSk7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVfID0gdHJ1ZTtcclxuICAgICAgICAvLyBXZSd2ZSBoYWQgcmVwZWF0ZWQgY29tcGxhaW50cyB0aGF0IENvcmRvdmEgYXBwcyBjYW4gZ2V0IHN0dWNrIFwib2ZmbGluZVwiLCBlLmcuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9mb3J1bS5pb25pY2ZyYW1ld29yay5jb20vdC9maXJlYmFzZS1jb25uZWN0aW9uLWlzLWxvc3QtYW5kLW5ldmVyLWNvbWUtYmFjay80MzgxMFxyXG4gICAgICAgIC8vIEl0IHdvdWxkIHNlZW0gdGhhdCB0aGUgJ29ubGluZScgZXZlbnQgZG9lcyBub3QgYWx3YXlzIGZpcmUgY29uc2lzdGVudGx5LiBTbyB3ZSBkaXNhYmxlIGl0XHJcbiAgICAgICAgLy8gZm9yIENvcmRvdmEuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgIWlzTW9iaWxlQ29yZG92YSgpKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub25saW5lXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25saW5lXyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdvbmxpbmUnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubGluZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ubGluZV8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29ubGluZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9ubGluZU1vbml0b3IoKTtcclxuICAgIH1cclxuICAgIGdldEluaXRpYWxFdmVudChldmVudFR5cGUpIHtcclxuICAgICAgICBhc3NlcnQoZXZlbnRUeXBlID09PSAnb25saW5lJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9ubGluZV9dO1xyXG4gICAgfVxyXG4gICAgY3VycmVudGx5T25saW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9ubGluZV87XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIE1heGltdW0ga2V5IGRlcHRoLiAqL1xyXG5jb25zdCBNQVhfUEFUSF9ERVBUSCA9IDMyO1xyXG4vKiogTWF4aW11bSBudW1iZXIgb2YgKFVURjgpIGJ5dGVzIGluIGEgRmlyZWJhc2UgcGF0aC4gKi9cclxuY29uc3QgTUFYX1BBVEhfTEVOR1RIX0JZVEVTID0gNzY4O1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBwYXJzZWQgcGF0aC4gIEl0J3MgaW1tdXRhYmxlIHNvIHRoYXQgeW91XHJcbiAqIGNhbiBwYXNzIHRoZW0gYXJvdW5kIHRvIG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHRoZW0gY2hhbmdpbmdcclxuICogaXQuXHJcbiAqL1xyXG5jbGFzcyBQYXRoIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdGhPclN0cmluZyAtIFBhdGggc3RyaW5nIHRvIHBhcnNlLCBvciBhbm90aGVyIHBhdGgsIG9yIHRoZSByYXdcclxuICAgICAqIHRva2VucyBhcnJheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoT3JTdHJpbmcsIHBpZWNlTnVtKSB7XHJcbiAgICAgICAgaWYgKHBpZWNlTnVtID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBlbXB0eSBwaWVjZXMuXHJcbiAgICAgICAgICAgIGxldCBjb3B5VG8gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWVjZXNfW2NvcHlUb10gPSB0aGlzLnBpZWNlc19baV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29weVRvKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfLmxlbmd0aCA9IGNvcHlUbztcclxuICAgICAgICAgICAgdGhpcy5waWVjZU51bV8gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IHBpZWNlTnVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCBwYXRoU3RyaW5nID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBpZWNlc19baV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICs9ICcvJyArIHRoaXMucGllY2VzX1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3RW1wdHlQYXRoKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXRoKCcnKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoR2V0RnJvbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoLnBpZWNlc19bcGF0aC5waWVjZU51bV9dO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aEdldExlbmd0aChwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfLmxlbmd0aCAtIHBhdGgucGllY2VOdW1fO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhQb3BGcm9udChwYXRoKSB7XHJcbiAgICBsZXQgcGllY2VOdW0gPSBwYXRoLnBpZWNlTnVtXztcclxuICAgIGlmIChwaWVjZU51bSA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICBwaWVjZU51bSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBhdGgucGllY2VzXywgcGllY2VOdW0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhHZXRCYWNrKHBhdGgpIHtcclxuICAgIGlmIChwYXRoLnBpZWNlTnVtXyA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5waWVjZXNfW3BhdGgucGllY2VzXy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhUb1VybEVuY29kZWRTdHJpbmcocGF0aCkge1xyXG4gICAgbGV0IHBhdGhTdHJpbmcgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmcgKz0gJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhwYXRoLnBpZWNlc19baV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XHJcbn1cclxuLyoqXHJcbiAqIFNoYWxsb3cgY29weSBvZiB0aGUgcGFydHMgb2YgdGhlIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoU2xpY2UocGF0aCwgYmVnaW4gPSAwKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfLnNsaWNlKHBhdGgucGllY2VOdW1fICsgYmVnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhQYXJlbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHBpZWNlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fOyBpIDwgcGF0aC5waWVjZXNfLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIHBpZWNlcy5wdXNoKHBhdGgucGllY2VzX1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoQ2hpbGQocGF0aCwgY2hpbGRQYXRoT2JqKSB7XHJcbiAgICBjb25zdCBwaWVjZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBpZWNlcy5wdXNoKHBhdGgucGllY2VzX1tpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hpbGRQYXRoT2JqIGluc3RhbmNlb2YgUGF0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjaGlsZFBhdGhPYmoucGllY2VOdW1fOyBpIDwgY2hpbGRQYXRoT2JqLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQYXRoT2JqLnBpZWNlc19baV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGllY2VzID0gY2hpbGRQYXRoT2JqLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZFBpZWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRQaWVjZXNbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQaWVjZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBpZWNlcywgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlcmUgYXJlIG5vIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aElzRW1wdHkocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGg7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBwYXRoIGZyb20gb3V0ZXJQYXRoIHRvIGlubmVyUGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gbmV3UmVsYXRpdmVQYXRoKG91dGVyUGF0aCwgaW5uZXJQYXRoKSB7XHJcbiAgICBjb25zdCBvdXRlciA9IHBhdGhHZXRGcm9udChvdXRlclBhdGgpLCBpbm5lciA9IHBhdGhHZXRGcm9udChpbm5lclBhdGgpO1xyXG4gICAgaWYgKG91dGVyID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGlubmVyUGF0aDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG91dGVyID09PSBpbm5lcikge1xyXG4gICAgICAgIHJldHVybiBuZXdSZWxhdGl2ZVBhdGgocGF0aFBvcEZyb250KG91dGVyUGF0aCksIHBhdGhQb3BGcm9udChpbm5lclBhdGgpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoJyArXHJcbiAgICAgICAgICAgIGlubmVyUGF0aCArXHJcbiAgICAgICAgICAgICcpIGlzIG5vdCB3aXRoaW4gJyArXHJcbiAgICAgICAgICAgICdvdXRlclBhdGggKCcgK1xyXG4gICAgICAgICAgICBvdXRlclBhdGggK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyAtMSwgMCwgMSBpZiBsZWZ0IGlzIGxlc3MsIGVxdWFsLCBvciBncmVhdGVyIHRoYW4gdGhlIHJpZ2h0LlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aENvbXBhcmUobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGxlZnRLZXlzID0gcGF0aFNsaWNlKGxlZnQsIDApO1xyXG4gICAgY29uc3QgcmlnaHRLZXlzID0gcGF0aFNsaWNlKHJpZ2h0LCAwKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjbXAgPSBuYW1lQ29tcGFyZShsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcclxuICAgICAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnRLZXlzLmxlbmd0aCA9PT0gcmlnaHRLZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnRLZXlzLmxlbmd0aCA8IHJpZ2h0S2V5cy5sZW5ndGggPyAtMSA6IDE7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgcGF0aHMgYXJlIHRoZSBzYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aEVxdWFscyhwYXRoLCBvdGhlcikge1xyXG4gICAgaWYgKHBhdGhHZXRMZW5ndGgocGF0aCkgIT09IHBhdGhHZXRMZW5ndGgob3RoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fLCBqID0gb3RoZXIucGllY2VOdW1fOyBpIDw9IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKywgaisrKSB7XHJcbiAgICAgICAgaWYgKHBhdGgucGllY2VzX1tpXSAhPT0gb3RoZXIucGllY2VzX1tqXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBwYXRoIGlzIGEgcGFyZW50IG9mIChvciB0aGUgc2FtZSBhcykgb3RoZXJcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhDb250YWlucyhwYXRoLCBvdGhlcikge1xyXG4gICAgbGV0IGkgPSBwYXRoLnBpZWNlTnVtXztcclxuICAgIGxldCBqID0gb3RoZXIucGllY2VOdW1fO1xyXG4gICAgaWYgKHBhdGhHZXRMZW5ndGgocGF0aCkgPiBwYXRoR2V0TGVuZ3RoKG90aGVyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHdoaWxlIChpIDwgcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09IG90aGVyLnBpZWNlc19bal0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICArK2k7XHJcbiAgICAgICAgKytqO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIER5bmFtaWMgKG11dGFibGUpIHBhdGggdXNlZCB0byBjb3VudCBwYXRoIGxlbmd0aHMuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBlZmZpY2llbnRseSBjaGVjayBwYXRocyBmb3IgdmFsaWRcclxuICogbGVuZ3RoIChpbiBVVEY4IGJ5dGVzKSBhbmQgZGVwdGggKHVzZWQgaW4gcGF0aCB2YWxpZGF0aW9uKS5cclxuICpcclxuICogVGhyb3dzIEVycm9yIGV4Y2VwdGlvbiBpZiBwYXRoIGlzIGV2ZXIgaW52YWxpZC5cclxuICpcclxuICogVGhlIGRlZmluaXRpb24gb2YgYSBwYXRoIGFsd2F5cyBiZWdpbnMgd2l0aCAnLycuXHJcbiAqL1xyXG5jbGFzcyBWYWxpZGF0aW9uUGF0aCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gSW5pdGlhbCBQYXRoLlxyXG4gICAgICogQHBhcmFtIGVycm9yUHJlZml4XyAtIFByZWZpeCBmb3IgYW55IGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBlcnJvclByZWZpeF8pIHtcclxuICAgICAgICB0aGlzLmVycm9yUHJlZml4XyA9IGVycm9yUHJlZml4XztcclxuICAgICAgICB0aGlzLnBhcnRzXyA9IHBhdGhTbGljZShwYXRoLCAwKTtcclxuICAgICAgICAvKiogSW5pdGlhbGl6ZSB0byBudW1iZXIgb2YgJy8nIGNoYXJzIG5lZWRlZCBpbiBwYXRoLiAqL1xyXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gPSBNYXRoLm1heCgxLCB0aGlzLnBhcnRzXy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgodGhpcy5wYXJ0c19baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhQdXNoKHZhbGlkYXRpb25QYXRoLCBjaGlsZCkge1xyXG4gICAgLy8gQ291bnQgdGhlIG5lZWRlZCAnLydcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfICs9IDE7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5wYXJ0c18ucHVzaChjaGlsZCk7XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgoY2hpbGQpO1xyXG4gICAgdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHZhbGlkYXRpb25QYXRoKTtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aFBvcCh2YWxpZGF0aW9uUGF0aCkge1xyXG4gICAgY29uc3QgbGFzdCA9IHZhbGlkYXRpb25QYXRoLnBhcnRzXy5wb3AoKTtcclxuICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfIC09IHN0cmluZ0xlbmd0aChsYXN0KTtcclxuICAgIC8vIFVuLWNvdW50IHRoZSBwcmV2aW91cyAnLydcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfIC09IDE7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gPiBNQVhfUEFUSF9MRU5HVEhfQllURVMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvblBhdGguZXJyb3JQcmVmaXhfICtcclxuICAgICAgICAgICAgJ2hhcyBhIGtleSBwYXRoIGxvbmdlciB0aGFuICcgK1xyXG4gICAgICAgICAgICBNQVhfUEFUSF9MRU5HVEhfQllURVMgK1xyXG4gICAgICAgICAgICAnIGJ5dGVzICgnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gK1xyXG4gICAgICAgICAgICAnKS4nKTtcclxuICAgIH1cclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gTUFYX1BBVEhfREVQVEgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvblBhdGguZXJyb3JQcmVmaXhfICtcclxuICAgICAgICAgICAgJ3BhdGggc3BlY2lmaWVkIGV4Y2VlZHMgdGhlIG1heGltdW0gZGVwdGggdGhhdCBjYW4gYmUgd3JpdHRlbiAoJyArXHJcbiAgICAgICAgICAgIE1BWF9QQVRIX0RFUFRIICtcclxuICAgICAgICAgICAgJykgb3Igb2JqZWN0IGNvbnRhaW5zIGEgY3ljbGUgJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyh2YWxpZGF0aW9uUGF0aCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdHJpbmcgZm9yIHVzZSBpbiBlcnJvciBtZXNzYWdlcyAtIHVzZXMgJy4nIG5vdGF0aW9uIGZvciBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGgucGFydHNfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBcImluIHByb3BlcnR5ICdcIiArIHZhbGlkYXRpb25QYXRoLnBhcnRzXy5qb2luKCcuJykgKyBcIidcIjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBWaXNpYmlsaXR5TW9uaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihbJ3Zpc2libGUnXSk7XHJcbiAgICAgICAgbGV0IGhpZGRlbjtcclxuICAgICAgICBsZXQgdmlzaWJpbGl0eUNoYW5nZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFsnaGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMi4xMCBhbmQgRmlyZWZveCAxOCBhbmQgbGF0ZXIgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnbW96SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21vekhpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtc0hpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21zSGlkZGVuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ3dlYmtpdEhpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluaXRpYWxseSwgd2UgYWx3YXlzIGFzc3VtZSB3ZSBhcmUgdmlzaWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgaW4gYnJvd3NlcnNcclxuICAgICAgICAvLyB3aXRob3V0IHBhZ2UgdmlzaWJpbGl0eSBzdXBwb3J0IG9yIGluIGNhc2VzIHdoZXJlIHdlIGFyZSBuZXZlciB2aXNpYmxlXHJcbiAgICAgICAgLy8gKGUuZy4gY2hyb21lIGV4dGVuc2lvbiksIHdlIGFjdCBhcyBpZiB3ZSBhcmUgdmlzaWJsZSwgaS5lLiBkb24ndCBkZWxheVxyXG4gICAgICAgIC8vIHJlY29ubmVjdHNcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodmlzaWJpbGl0eUNoYW5nZSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHZpc2liaWxpdHlDaGFuZ2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSAhZG9jdW1lbnRbaGlkZGVuXTtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlICE9PSB0aGlzLnZpc2libGVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlXyA9IHZpc2libGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd2aXNpYmxlJywgdmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaXNpYmlsaXR5TW9uaXRvcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydChldmVudFR5cGUgPT09ICd2aXNpYmxlJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnZpc2libGVfXTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBSRUNPTk5FQ1RfTUlOX0RFTEFZID0gMTAwMDtcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUID0gNjAgKiA1ICogMTAwMDsgLy8gNSBtaW51dGVzIGluIG1pbGxpc2Vjb25kcyAoQ2FzZTogMTg1OClcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TID0gMzAgKiAxMDAwOyAvLyAzMCBzZWNvbmRzIGZvciBhZG1pbiBjbGllbnRzIChsaWtlbHkgdG8gYmUgYSBiYWNrZW5kIHNlcnZlcilcclxuY29uc3QgUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIgPSAxLjM7XHJcbmNvbnN0IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUID0gMzAwMDA7IC8vIFJlc2V0IGRlbGF5IGJhY2sgdG8gTUlOX0RFTEFZIGFmdGVyIGJlaW5nIGNvbm5lY3RlZCBmb3IgMzBzZWMuXHJcbmNvbnN0IFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04gPSAnc2VydmVyX2tpbGwnO1xyXG4vLyBJZiBhdXRoIGZhaWxzIHJlcGVhdGVkbHksIHdlJ2xsIGFzc3VtZSBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxvZyBhIHdhcm5pbmcgLyBiYWNrIG9mZi5cclxuY29uc3QgSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQgPSAzO1xyXG4vKipcclxuICogRmlyZWJhc2UgY29ubmVjdGlvbi4gIEFic3RyYWN0cyB3aXJlIHByb3RvY29sIGFuZCBoYW5kbGVzIHJlY29ubmVjdGluZy5cclxuICpcclxuICogTk9URTogQWxsIEpTT04gb2JqZWN0cyBzZW50IHRvIHRoZSByZWFsdGltZSBjb25uZWN0aW9uIG11c3QgaGF2ZSBwcm9wZXJ0eSBuYW1lcyBlbmNsb3NlZFxyXG4gKiBpbiBxdW90ZXMgdG8gbWFrZSBzdXJlIHRoZSBjbG9zdXJlIGNvbXBpbGVyIGRvZXMgbm90IG1pbmlmeSB0aGVtLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVudENvbm5lY3Rpb24gZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gb25EYXRhVXBkYXRlXyAtIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mb18sIGFwcGxpY2F0aW9uSWRfLCBvbkRhdGFVcGRhdGVfLCBvbkNvbm5lY3RTdGF0dXNfLCBvblNlcnZlckluZm9VcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8sIGF1dGhPdmVycmlkZV8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZF8gPSBhcHBsaWNhdGlvbklkXztcclxuICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xyXG4gICAgICAgIHRoaXMub25Db25uZWN0U3RhdHVzXyA9IG9uQ29ubmVjdFN0YXR1c187XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfID0gb25TZXJ2ZXJJbmZvVXBkYXRlXztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8gPSBhcHBDaGVja1Rva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXV0aE92ZXJyaWRlXyA9IGF1dGhPdmVycmlkZV87XHJcbiAgICAgICAgLy8gVXNlZCBmb3IgZGlhZ25vc3RpYyBsb2dnaW5nLlxyXG4gICAgICAgIHRoaXMuaWQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdwOicgKyB0aGlzLmlkICsgJzonKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcclxuICAgICAgICB0aGlzLm1heFJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVDtcclxuICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQmVmb3JlIHdlIGdldCBjb25uZWN0ZWQsIHdlIGtlZXAgYSBxdWV1ZSBvZiBwZW5kaW5nIG1lc3NhZ2VzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE51bWJlcl8gPSAwO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcclxuICAgICAgICBpZiAoYXV0aE92ZXJyaWRlXyAmJiAhaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoIG92ZXJyaWRlIHNwZWNpZmllZCBpbiBvcHRpb25zLCBidXQgbm90IHN1cHBvcnRlZCBvbiBub24gTm9kZS5qcyBwbGF0Zm9ybXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgVmlzaWJpbGl0eU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5vbigndmlzaWJsZScsIHRoaXMub25WaXNpYmxlXywgdGhpcyk7XHJcbiAgICAgICAgaWYgKHJlcG9JbmZvXy5ob3N0LmluZGV4T2YoJ2ZibG9jYWwnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCdvbmxpbmUnLCB0aGlzLm9uT25saW5lXywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFJlcXVlc3QoYWN0aW9uLCBib2R5LCBvblJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgY3VyUmVxTnVtID0gKyt0aGlzLnJlcXVlc3ROdW1iZXJfO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IHsgcjogY3VyUmVxTnVtLCBhOiBhY3Rpb24sIGI6IGJvZHkgfTtcclxuICAgICAgICB0aGlzLmxvZ18oc3RyaW5naWZ5KG1zZykpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmNvbm5lY3RlZF8sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfLnNlbmRSZXF1ZXN0KG1zZyk7XHJcbiAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tjdXJSZXFOdW1dID0gb25SZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgcDogcXVlcnkuX3BhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgcTogcXVlcnkuX3F1ZXJ5T2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvdXRzdGFuZGluZ0dldCA9IHtcclxuICAgICAgICAgICAgYWN0aW9uOiAnZycsXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbWVzc2FnZVsnZCddO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VbJ3MnXSA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXy5wdXNoKG91dHN0YW5kaW5nR2V0KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZEdldF8oaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGxpc3RlbihxdWVyeSwgY3VycmVudEhhc2hGbiwgdGFnLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnMuaGFzKHBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVucy5zZXQocGF0aFN0cmluZywgbmV3IE1hcCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KHF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSB8fCAhcXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpLCAnbGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnknKTtcclxuICAgICAgICBhc3NlcnQoIXRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuaGFzKHF1ZXJ5SWQpLCBgbGlzdGVuKCkgY2FsbGVkIHR3aWNlIGZvciBzYW1lIHBhdGgvcXVlcnlJZC5gKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW5TcGVjID0ge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlLFxyXG4gICAgICAgICAgICBoYXNoRm46IGN1cnJlbnRIYXNoRm4sXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICB0YWdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuc2V0KHF1ZXJ5SWQsIGxpc3RlblNwZWMpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTGlzdGVuXyhsaXN0ZW5TcGVjKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kR2V0XyhpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGdldCA9IHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpbmRleF07XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgnZycsIGdldC5yZXF1ZXN0LCAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ0dldHNfW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldENvdW50Xy0tO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ0dldENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldHNfID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdldC5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBnZXQub25Db21wbGV0ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VuZExpc3Rlbl8obGlzdGVuU3BlYykge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbGlzdGVuU3BlYy5xdWVyeTtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBjb25zdCByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSAncSc7XHJcbiAgICAgICAgLy8gT25seSBib3RoZXIgdG8gc2VuZCBxdWVyeSBpZiBpdCdzIG5vbi1kZWZhdWx0LlxyXG4gICAgICAgIGlmIChsaXN0ZW5TcGVjLnRhZykge1xyXG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5Ll9xdWVyeU9iamVjdDtcclxuICAgICAgICAgICAgcmVxWyd0J10gPSBsaXN0ZW5TcGVjLnRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxWyAvKmhhc2gqLydoJ10gPSBsaXN0ZW5TcGVjLmhhc2hGbigpO1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXEsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlWyAvKmRhdGEqLydkJ107XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IG1lc3NhZ2VbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAvLyBwcmludCB3YXJuaW5ncyBpbiBhbnkgY2FzZS4uLlxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi53YXJuT25MaXN0ZW5XYXJuaW5nc18ocGF5bG9hZCwgcXVlcnkpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGlzdGVuU3BlYyA9IHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAvLyBvbmx5IHRyaWdnZXIgYWN0aW9ucyBpZiB0aGUgbGlzdGVuIGhhc24ndCBiZWVuIHJlbW92ZWQgYW5kIHJlYWRkZWRcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5TcGVjID09PSBsaXN0ZW5TcGVjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2xpc3RlbiByZXNwb25zZScsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5TcGVjLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5TcGVjLm9uQ29tcGxldGUoc3RhdHVzLCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHdhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSkge1xyXG4gICAgICAgIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBjb250YWlucyhwYXlsb2FkLCAndycpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdzID0gc2FmZUdldChwYXlsb2FkLCAndycpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3YXJuaW5ncykgJiYgfndhcm5pbmdzLmluZGV4T2YoJ25vX2luZGV4JykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3BlYyA9ICdcIi5pbmRleE9uXCI6IFwiJyArIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpLnRvU3RyaW5nKCkgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhQYXRoID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFVzaW5nIGFuIHVuc3BlY2lmaWVkIGluZGV4LiBZb3VyIGRhdGEgd2lsbCBiZSBkb3dubG9hZGVkIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZmlsdGVyZWQgb24gdGhlIGNsaWVudC4gQ29uc2lkZXIgYWRkaW5nICR7aW5kZXhTcGVjfSBhdCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJHtpbmRleFBhdGh9IHRvIHlvdXIgc2VjdXJpdHkgcnVsZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZnJlc2hBdXRoVG9rZW4odG9rZW4pIHtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLmxvZ18oJ0F1dGggdG9rZW4gcmVmcmVzaGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuXykge1xyXG4gICAgICAgICAgICB0aGlzLnRyeUF1dGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy4gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgc2ltcGx5IGRlbGV0ZVxyXG4gICAgICAgICAgICAvL3RoZSBjcmVkZW50aWFsIHNvIHdlIGRvbnQgYmVjb21lIGF1dGhlbnRpY2F0ZWQgbmV4dCB0aW1lIHdlIGNvbm5lY3QuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXV0aCcsIHt9LCAoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8odG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8oY3JlZGVudGlhbCkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXNuJ3QgaW50ZW5kZWQgdG8gYmUgYnVsbGV0cHJvb2YgKGEgbWFsaWNpb3VzIGRldmVsb3BlciBjYW4gYWx3YXlzIGp1c3QgbW9kaWZ5IHRoZSBjbGllbnQpLlxyXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSwgd2UgZG9uJ3QgYm90aGVyIHJlc2V0dGluZyB0aGUgbWF4IGRlbGF5IGJhY2sgdG8gdGhlIGRlZmF1bHQgaWYgYXV0aCBmYWlscyAvIGV4cGlyZXMuXHJcbiAgICAgICAgY29uc3QgaXNGaXJlYmFzZVNlY3JldCA9IGNyZWRlbnRpYWwgJiYgY3JlZGVudGlhbC5sZW5ndGggPT09IDQwO1xyXG4gICAgICAgIGlmIChpc0ZpcmViYXNlU2VjcmV0IHx8IGlzQWRtaW4oY3JlZGVudGlhbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdBZG1pbiBhdXRoIGNyZWRlbnRpYWwgZGV0ZWN0ZWQuICBSZWR1Y2luZyBtYXggcmVjb25uZWN0IHRpbWUuJyk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZnJlc2hBcHBDaGVja1Rva2VuKHRva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMubG9nXygnQXBwIGNoZWNrIHRva2VuIHJlZnJlc2hlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5QXBwQ2hlY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy5cclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBzaW1wbHkgZGVsZXRlIHRoZSBjcmVkZW50aWFsIHNvIHdlIGRvbnQgYmVjb21lXHJcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0ZWQgbmV4dCB0aW1lIHdlIGNvbm5lY3QuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXBwZWNrJywge30sICgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2VcclxuICAgICAqIGEgYXV0aCByZXZva2VkICh0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQpLlxyXG4gICAgICovXHJcbiAgICB0cnlBdXRoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hdXRoVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5hdXRoVG9rZW5fO1xyXG4gICAgICAgICAgICBjb25zdCBhdXRoTWV0aG9kID0gaXNWYWxpZEZvcm1hdCh0b2tlbikgPyAnYXV0aCcgOiAnZ2F1dGgnO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHsgY3JlZDogdG9rZW4gfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXV0aE92ZXJyaWRlXyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ25vYXV0aCddID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5hdXRoT3ZlcnJpZGVfID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ2F1dGh2YXInXSA9IHRoaXMuYXV0aE92ZXJyaWRlXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGF1dGhNZXRob2QsIHJlcXVlc3REYXRhLCAocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc1sgLypkYXRhKi8nZCddIHx8ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5fID09PSB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJzIHJlY29ubmVjdCBhbmQgZm9yY2UgcmVmcmVzaCBmb3IgYXV0aCB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiB0b2tlbi4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiBhdHRlbXB0IGZhaWxzLCBpdCdzIHRyaWdnZXJlZCBsaWtlIHRoZSB0b2tlbiB3YXMgcmV2b2tlZCAodGhlIGNvbm5lY3Rpb24gaXNcclxuICAgICAqIGNsb3NlZCkuXHJcbiAgICAgKi9cclxuICAgIHRyeUFwcENoZWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hcHBDaGVja1Rva2VuXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCdhcHBjaGVjaycsIHsgJ3Rva2VuJzogdGhpcy5hcHBDaGVja1Rva2VuXyB9LCAocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc1sgLypkYXRhKi8nZCddIHx8ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XyA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQXBwQ2hlY2tSZXZva2VkXyhzdGF0dXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0RG9jXHJcbiAgICAgKi9cclxuICAgIHVubGlzdGVuKHF1ZXJ5LCB0YWcpIHtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpIHx8ICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCksICd1bmxpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5Jyk7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW4gJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFVubGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkLCBxdWVyeS5fcXVlcnlPYmplY3QsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFVubGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkLCBxdWVyeU9iaiwgdGFnKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdVbmxpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBjb25zdCByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSAnbic7XHJcbiAgICAgICAgLy8gT25seSBib3RoZXIgc2VuZGluZyBxdWVyeUlkIGlmIGl0J3Mgbm9uLWRlZmF1bHQuXHJcbiAgICAgICAgaWYgKHRhZykge1xyXG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5T2JqO1xyXG4gICAgICAgICAgICByZXFbJ3QnXSA9IHRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcSk7XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RQdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbycsXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RNZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ29tJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnb20nLFxyXG4gICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EaXNjb25uZWN0Q2FuY2VsKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb2MnLCBwYXRoU3RyaW5nLCBudWxsLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvYycsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kT25EaXNjb25uZWN0XyhhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLCAvKmRhdGEqLyBkOiBkYXRhIH07XHJcbiAgICAgICAgdGhpcy5sb2dfKCdvbkRpc2Nvbm5lY3QgJyArIGFjdGlvbiwgcmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShyZXNwb25zZVsgLypzdGF0dXMqLydzJ10sIHJlc3BvbnNlWyAvKiBkYXRhICovJ2QnXSk7XHJcbiAgICAgICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdwJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBtZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgdGhpcy5wdXRJbnRlcm5hbCgnbScsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpO1xyXG4gICAgfVxyXG4gICAgcHV0SW50ZXJuYWwoYWN0aW9uLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAvKmRhdGEqLyBkOiBkYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RbIC8qaGFzaCovJ2gnXSA9IGhhc2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IE9ubHkga2VlcCB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgcHV0IGZvciBhIGdpdmVuIHBhdGg/XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLnB1c2goe1xyXG4gICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCdWZmZXJpbmcgcHV0OiAnICsgcGF0aFN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFB1dF8oaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLmFjdGlvbjtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5yZXF1ZXN0O1xyXG4gICAgICAgIGNvbnN0IG9uQ29tcGxldGUgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLm9uQ29tcGxldGU7XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5xdWV1ZWQgPSB0aGlzLmNvbm5lY3RlZF87XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXyhhY3Rpb24gKyAnIHJlc3BvbnNlJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG1lc3NhZ2VbIC8qc3RhdHVzKi8ncyddLCBtZXNzYWdlWyAvKiBkYXRhICovJ2QnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7XHJcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgd2UganVzdCBkcm9wIHRoZSBzdGF0cy5cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IC8qY291bnRlcnMqLyBjOiBzdGF0cyB9O1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3JlcG9ydFN0YXRzJywgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoLypzdGF0cyovICdzJywgcmVxdWVzdCwgcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3VsdFsgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSByZXN1bHRbIC8qIGRhdGEgKi8nZCddO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCAnRXJyb3Igc2VuZGluZyBzdGF0czogJyArIGVycm9yUmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EYXRhTWVzc2FnZV8obWVzc2FnZSkge1xyXG4gICAgICAgIGlmICgncicgaW4gbWVzc2FnZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgcmVzcG9uc2VcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdmcm9tIHNlcnZlcjogJyArIHN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcU51bSA9IG1lc3NhZ2VbJ3InXTtcclxuICAgICAgICAgICAgY29uc3Qgb25SZXNwb25zZSA9IHRoaXMucmVxdWVzdENCSGFzaF9bcmVxTnVtXTtcclxuICAgICAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XHJcbiAgICAgICAgICAgICAgICBvblJlc3BvbnNlKG1lc3NhZ2VbIC8qYm9keSovJ2InXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2Vycm9yJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdBIHNlcnZlci1zaWRlIGVycm9yIGhhcyBvY2N1cnJlZDogJyArIG1lc3NhZ2VbJ2Vycm9yJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdhJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIGEgYW5kIGIgYXJlIGFjdGlvbiBhbmQgYm9keSwgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhUHVzaF8obWVzc2FnZVsnYSddLCBtZXNzYWdlWydiJ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGF0YVB1c2hfKGFjdGlvbiwgYm9keSkge1xyXG4gICAgICAgIHRoaXMubG9nXygnaGFuZGxlU2VydmVyTWVzc2FnZScsIGFjdGlvbiwgYm9keSk7XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WyAvKnBhdGgqLydwJ10sIGJvZHlbIC8qZGF0YSovJ2QnXSwgXHJcbiAgICAgICAgICAgIC8qaXNNZXJnZSovIGZhbHNlLCBib2R5Wyd0J10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdtJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8oYm9keVsgLypwYXRoKi8ncCddLCBib2R5WyAvKmRhdGEqLydkJ10sIFxyXG4gICAgICAgICAgICAvKmlzTWVyZ2U9Ki8gdHJ1ZSwgYm9keVsndCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYycpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkxpc3RlblJldm9rZWRfKGJvZHlbIC8qcGF0aCovJ3AnXSwgYm9keVsgLypxdWVyeSovJ3EnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKGJvZHlbIC8qc3RhdHVzIGNvZGUqLydzJ10sIGJvZHlbIC8qIGV4cGxhbmF0aW9uICovJ2QnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FwYycpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkFwcENoZWNrUmV2b2tlZF8oYm9keVsgLypzdGF0dXMgY29kZSovJ3MnXSwgYm9keVsgLyogZXhwbGFuYXRpb24gKi8nZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICtcclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShhY3Rpb24pICtcclxuICAgICAgICAgICAgICAgICdcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50PycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVhZHlfKHRpbWVzdGFtcCwgc2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdjb25uZWN0aW9uIHJlYWR5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVGltZXN0YW1wXyh0aW1lc3RhbXApO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IHNlc3Npb25JZDtcclxuICAgICAgICBpZiAodGhpcy5maXJzdENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbm5lY3RTdGF0c18oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGVfKCk7XHJcbiAgICAgICAgdGhpcy5maXJzdENvbm5lY3Rpb25fID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfKHRydWUpO1xyXG4gICAgfVxyXG4gICAgc2NoZWR1bGVDb25uZWN0Xyh0aW1lb3V0KSB7XHJcbiAgICAgICAgYXNzZXJ0KCF0aGlzLnJlYWx0aW1lXywgXCJTY2hlZHVsaW5nIGEgY29ubmVjdCB3aGVuIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkL2luZz9cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTk9URTogRXZlbiB3aGVuIHRpbWVvdXQgaXMgMCwgaXQncyBpbXBvcnRhbnQgdG8gZG8gYSBzZXRUaW1lb3V0IHRvIHdvcmsgYXJvdW5kIGFuIGluZnVyaWF0aW5nIFwiU2VjdXJpdHkgRXJyb3JcIiBpblxyXG4gICAgICAgIC8vIEZpcmVmb3ggd2hlbiB0cnlpbmcgdG8gd3JpdGUgdG8gb3VyIGxvbmctcG9sbGluZyBpZnJhbWUgaW4gc29tZSBzY2VuYXJpb3MgKGUuZy4gRm9yZ2Ugb3Igb3VyIHVuaXQgdGVzdHMpLlxyXG4gICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XHJcbiAgICB9XHJcbiAgICBpbml0Q29ubmVjdGlvbl8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXyAmJiB0aGlzLmZpcnN0Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uVmlzaWJsZV8odmlzaWJsZSkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRhYmJpbmcgYXdheSBhbmQgYmFjayB0byBhIHdpbmRvdyB3aWxsIGRlZmVhdCBvdXIgcmVjb25uZWN0IGJhY2tvZmYsIGJ1dCBJIHRoaW5rIHRoYXQncyBmaW5lLlxyXG4gICAgICAgIGlmICh2aXNpYmxlICYmXHJcbiAgICAgICAgICAgICF0aGlzLnZpc2libGVfICYmXHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID09PSB0aGlzLm1heFJlY29ubmVjdERlbGF5Xykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dpbmRvdyBiZWNhbWUgdmlzaWJsZS4gIFJlZHVjaW5nIGRlbGF5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpc2libGVfID0gdmlzaWJsZTtcclxuICAgIH1cclxuICAgIG9uT25saW5lXyhvbmxpbmUpIHtcclxuICAgICAgICBpZiAob25saW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9ubGluZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVhbHRpbWVEaXNjb25uZWN0XygpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ2RhdGEgY2xpZW50IGRpc2Nvbm5lY3RlZCcpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrbm93IGlmIG91ciBzZW50IHRyYW5zYWN0aW9ucyBzdWNjZWVkZWQgb3Igbm90LCB3ZSBuZWVkIHRvIGNhbmNlbCB0aGVtLlxyXG4gICAgICAgIHRoaXMuY2FuY2VsU2VudFRyYW5zYWN0aW9uc18oKTtcclxuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHBlbmRpbmcgcmVxdWVzdHMuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdF8oKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmlzaWJsZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gdGhpcy5tYXhSZWNvbm5lY3REZWxheV87XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8pIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGJlZW4gY29ubmVjdGVkIGxvbmcgZW5vdWdoLCByZXNldCByZWNvbm5lY3QgZGVsYXkgdG8gbWluaW11bS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0Q29ubmVjdFN1Y2NlZWRlZCA+IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXztcclxuICAgICAgICAgICAgbGV0IHJlY29ubmVjdERlbGF5ID0gTWF0aC5tYXgoMCwgdGhpcy5yZWNvbm5lY3REZWxheV8gLSB0aW1lU2luY2VMYXN0Q29ubmVjdEF0dGVtcHQpO1xyXG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IE1hdGgucmFuZG9tKCkgKiByZWNvbm5lY3REZWxheTtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdUcnlpbmcgdG8gcmVjb25uZWN0IGluICcgKyByZWNvbm5lY3REZWxheSArICdtcycpO1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8ocmVjb25uZWN0RGVsYXkpO1xyXG4gICAgICAgICAgICAvLyBBZGp1c3QgcmVjb25uZWN0IGRlbGF5IGZvciBuZXh0IHRpbWUuXHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gTWF0aC5taW4odGhpcy5tYXhSZWNvbm5lY3REZWxheV8sIHRoaXMucmVjb25uZWN0RGVsYXlfICogUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18oZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZXN0YWJsaXNoQ29ubmVjdGlvbl8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0XygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBvbkRhdGFNZXNzYWdlID0gdGhpcy5vbkRhdGFNZXNzYWdlXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvblJlYWR5ID0gdGhpcy5vblJlYWR5Xy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uUmVhbHRpbWVEaXNjb25uZWN0Xy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBjb25uSWQgPSB0aGlzLmlkICsgJzonICsgUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICAgICAgY29uc3QgbGFzdFNlc3Npb25JZCA9IHRoaXMubGFzdFNlc3Npb25JZDtcclxuICAgICAgICAgICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBzZW5kUmVxdWVzdEZuID0gZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNvbm5lY3Rpb24sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kUmVxdWVzdChtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXyA9IHtcclxuICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZUZuLFxyXG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3Q6IHNlbmRSZXF1ZXN0Rm5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVRva2VuUmVmcmVzaF87XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBmZXRjaCBhdXRoIGFuZCBhcHAgY2hlY2sgdG9rZW4sIGFuZCBlc3RhYmxpc2ggY29ubmVjdGlvbiBhZnRlclxyXG4gICAgICAgICAgICAgICAgLy8gZmV0Y2hpbmcgdGhlIHRva2VuIHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkLiBDcmVhdGluZyBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4uYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IGFwcENoZWNrVG9rZW4gJiYgYXBwQ2hlY2tUb2tlbi50b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oY29ubklkLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5hcHBsaWNhdGlvbklkXywgdGhpcy5hcHBDaGVja1Rva2VuXywgdGhpcy5hdXRoVG9rZW5fLCBvbkRhdGFNZXNzYWdlLCBvblJlYWR5LCBvbkRpc2Nvbm5lY3QsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIG9uS2lsbD0gKi8gcmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihyZWFzb24gKyAnICgnICsgdGhpcy5yZXBvSW5mb18udG9TdHJpbmcoKSArICcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJydXB0KFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGxhc3RTZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdnZXRUb2tlbigpIGNvbXBsZXRlZCBidXQgd2FzIGNhbmNlbGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0ZhaWxlZCB0byBnZXQgdG9rZW46ICcgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLm5vZGVBZG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBhIGNyaXRpY2FsIGVycm9yIGZvciB0aGUgQWRtaW4gTm9kZS5qcyBTREssIHNvIGxvZyBhIHdhcm5pbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBnZXRUb2tlbigpIG1heSBhbHNvIGp1c3QgaGF2ZSB0ZW1wb3JhcmlseSBmYWlsZWQsIHNvIHdlIHN0aWxsIHdhbnQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgcmV0cnlpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9zZUZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnRlcnJ1cHQocmVhc29uKSB7XHJcbiAgICAgICAgbG9nKCdJbnRlcnJ1cHRpbmcgY29ubmVjdGlvbiBmb3IgcmVhc29uOiAnICsgcmVhc29uKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl0gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bWUocmVhc29uKSB7XHJcbiAgICAgICAgbG9nKCdSZXN1bWluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl07XHJcbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5pbnRlcnJ1cHRSZWFzb25zXykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCkge1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGltZXN0YW1wIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfKHsgc2VydmVyVGltZU9mZnNldDogZGVsdGEgfSk7XHJcbiAgICB9XHJcbiAgICBjYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwdXQgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XHJcbiAgICAgICAgICAgIGlmIChwdXQgJiYgLypoYXNoKi8gJ2gnIGluIHB1dC5yZXF1ZXN0ICYmIHB1dC5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwdXQub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1dC5vbkNvbXBsZXRlKCdkaXNjb25uZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50Xy0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cclxuICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkxpc3RlblJldm9rZWRfKHBhdGhTdHJpbmcsIHF1ZXJ5KSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW4gYW5kIG1hbnVmYWN0dXJlIGEgXCJwZXJtaXNzaW9uX2RlbmllZFwiIGVycm9yIGZvciB0aGUgZmFpbGVkIGxpc3Rlbi5cclxuICAgICAgICBsZXQgcXVlcnlJZDtcclxuICAgICAgICBpZiAoIXF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSAnZGVmYXVsdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeUlkID0gcXVlcnkubWFwKHEgPT4gT2JqZWN0VG9VbmlxdWVLZXkocSkpLmpvaW4oJyQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW4gJiYgbGlzdGVuLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgbGlzdGVuLm9uQ29tcGxldGUoJ3Blcm1pc3Npb25fZGVuaWVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFBhdGhTdHJpbmcgPSBuZXcgUGF0aChwYXRoU3RyaW5nKS50b1N0cmluZygpOyAvLyBub3JtYWxpemUgcGF0aC5cclxuICAgICAgICBsZXQgbGlzdGVuO1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnMuaGFzKG5vcm1hbGl6ZWRQYXRoU3RyaW5nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLmxpc3RlbnMuZ2V0KG5vcm1hbGl6ZWRQYXRoU3RyaW5nKTtcclxuICAgICAgICAgICAgbGlzdGVuID0gbWFwLmdldChxdWVyeUlkKTtcclxuICAgICAgICAgICAgbWFwLmRlbGV0ZShxdWVyeUlkKTtcclxuICAgICAgICAgICAgaWYgKG1hcC5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbnMuZGVsZXRlKG5vcm1hbGl6ZWRQYXRoU3RyaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYWxsIGxpc3RlbnMgZm9yIHRoaXMgcGF0aCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWRcclxuICAgICAgICAgICAgbGlzdGVuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGlzdGVuO1xyXG4gICAgfVxyXG4gICAgb25BdXRoUmV2b2tlZF8oc3RhdHVzQ29kZSwgZXhwbGFuYXRpb24pIHtcclxuICAgICAgICBsb2coJ0F1dGggdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcclxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICAgICAgLy8gV2UnbGwgd2FpdCBhIGNvdXBsZSB0aW1lcyBiZWZvcmUgbG9nZ2luZyB0aGUgd2FybmluZyAvIGluY3JlYXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEF1dGhUb2tlbkNvdW50XysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID49IElOVkFMSURfVE9LRU5fVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgYSBsb25nIHJlY29ubmVjdCBkZWxheSBiZWNhdXNlIHJlY292ZXJ5IGlzIHVubGlrZWx5XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfRk9SX0FETUlOUztcclxuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSB0aGUgYXV0aCB0b2tlbiBwcm92aWRlciB0aGF0IHRoZSB0b2tlbiBpcyBpbnZhbGlkLCB3aGljaCB3aWxsIGxvZ1xyXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQXBwQ2hlY2tSZXZva2VkXyhzdGF0dXNDb2RlLCBleHBsYW5hdGlvbikge1xyXG4gICAgICAgIGxvZygnQXBwIGNoZWNrIHRva2VuIHJldm9rZWQ6ICcgKyBzdGF0dXNDb2RlICsgJy8nICsgZXhwbGFuYXRpb24pO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcclxuICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9zZSB0aGUgY29ubmVjdGlvbiBhcyB0aGUgZGV2ZWxvcGVyIG1heSBub3QgaGF2ZVxyXG4gICAgICAgIC8vIGVuZm9yY2VtZW50IGVuYWJsZWQuIFRoZSBiYWNrZW5kIGNsb3NlcyBjb25uZWN0aW9ucyB3aXRoIGVuZm9yY2VtZW50cy5cclxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICAgICAgLy8gV2UnbGwgd2FpdCBhIGNvdXBsZSB0aW1lcyBiZWZvcmUgbG9nZ2luZyB0aGUgd2FybmluZyAvIGluY3JlYXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8rKztcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2VjdXJpdHlEZWJ1Z1BhY2tldF8oYm9keSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCdtc2cnIGluIGJvZHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGSVJFQkFTRTogJyArIGJvZHlbJ21zZyddLnJlcGxhY2UoJ1xcbicsICdcXG5GSVJFQkFTRTogJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdG9yZVN0YXRlXygpIHtcclxuICAgICAgICAvL1JlLWF1dGhlbnRpY2F0ZSBvdXJzZWx2ZXMgaWYgd2UgaGF2ZSBhIGNyZWRlbnRpYWwgc3RvcmVkLlxyXG4gICAgICAgIHRoaXMudHJ5QXV0aCgpO1xyXG4gICAgICAgIHRoaXMudHJ5QXBwQ2hlY2soKTtcclxuICAgICAgICAvLyBQdXRzIGRlcGVuZCBvbiBoYXZpbmcgcmVjZWl2ZWQgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSB1cGRhdGUgZnJvbSB0aGUgc2VydmVyIGJlZm9yZSB0aGV5IGNvbXBsZXRlLCBzbyB3ZSBtdXN0XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHNlbmQgbGlzdGVucyBiZWZvcmUgcHV0cy5cclxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJpZXMgb2YgdGhpcy5saXN0ZW5zLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuU3BlYyBvZiBxdWVyaWVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0c19baV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKHJlcXVlc3QuYWN0aW9uLCByZXF1ZXN0LnBhdGhTdHJpbmcsIHJlcXVlc3QuZGF0YSwgcmVxdWVzdC5vbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kR2V0XyhpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgY2xpZW50IHN0YXRzIGZvciBmaXJzdCBjb25uZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHNlbmRDb25uZWN0U3RhdHNfKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0ge307XHJcbiAgICAgICAgbGV0IGNsaWVudE5hbWUgPSAnanMnO1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnROYW1lID0gJ2FkbWluX25vZGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50TmFtZSA9ICdub2RlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0c1snc2RrLicgKyBjbGllbnROYW1lICsgJy4nICsgU0RLX1ZFUlNJT04ucmVwbGFjZSgvXFwuL2csICctJyldID0gMTtcclxuICAgICAgICBpZiAoaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcclxuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5jb3Jkb3ZhJ10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5yZWFjdG5hdGl2ZSddID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXBvcnRTdGF0cyhzdGF0cyk7XHJcbiAgICB9XHJcbiAgICBzaG91bGRSZWNvbm5lY3RfKCkge1xyXG4gICAgICAgIGNvbnN0IG9ubGluZSA9IE9ubGluZU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5jdXJyZW50bHlPbmxpbmUoKTtcclxuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSAmJiBvbmxpbmU7XHJcbiAgICB9XHJcbn1cclxuUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dFBlcnNpc3RlbnRDb25uZWN0aW9uSWRfID0gMDtcclxuLyoqXHJcbiAqIENvdW50ZXIgZm9yIG51bWJlciBvZiBjb25uZWN0aW9ucyBjcmVhdGVkLiBNYWlubHkgdXNlZCBmb3IgdGFnZ2luZyBpbiB0aGUgbG9nc1xyXG4gKi9cclxuUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8gPSAwO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBOYW1lZE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgbm9kZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBXcmFwKG5hbWUsIG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBJbmRleCB7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEEgc3RhbmRhbG9uZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvclxyXG4gICAgICogdGhpcyBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRDb21wYXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBiZWZvcmUgYW5kIGFmdGVyIHZhbHVlIGZvciBhIG5vZGUsIGRldGVybWluZSBpZiB0aGUgaW5kZXhlZCB2YWx1ZSBoYXMgY2hhbmdlZC4gRXZlbiBpZiB0aGV5IGFyZSBkaWZmZXJlbnQsXHJcbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNoYW5nZXMgYXJlIGlzb2xhdGVkIHRvIHBhcnRzIG9mIHRoZSBzbmFwc2hvdCB0aGF0IGFyZSBub3QgaW5kZXhlZC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcG9ydGlvbiBvZiB0aGUgc25hcHNob3QgYmVpbmcgaW5kZXhlZCBjaGFuZ2VkIGJldHdlZW4gb2xkTm9kZSBhbmQgbmV3Tm9kZVxyXG4gICAgICovXHJcbiAgICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICBjb25zdCBvbGRXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgb2xkTm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV3V3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIG5ld05vZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob2xkV3JhcHBlZCwgbmV3V3JhcHBlZCkgIT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGEgbm9kZSB3cmFwcGVyIHRoYXQgd2lsbCBzb3J0IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogYW55IG90aGVyIG5vZGUgd3JhcHBlciwgdXNpbmcgdGhpcyBpbmRleFxyXG4gICAgICovXHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IF9fRU1QVFlfTk9ERTtcclxuY2xhc3MgS2V5SW5kZXggZXh0ZW5kcyBJbmRleCB7XHJcbiAgICBzdGF0aWMgZ2V0IF9fRU1QVFlfTk9ERSgpIHtcclxuICAgICAgICByZXR1cm4gX19FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBfX0VNUFRZX05PREUodmFsKSB7XHJcbiAgICAgICAgX19FTVBUWV9OT0RFID0gdmFsO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICAvLyBXZSBjb3VsZCBwcm9iYWJseSByZXR1cm4gdHJ1ZSBoZXJlIChzaW5jZSBldmVyeSBub2RlIGhhcyBhIGtleSksIGJ1dCBpdCdzIG5ldmVyIGNhbGxlZFxyXG4gICAgICAgIC8vIHNvIGp1c3QgbGVhdmluZyB1bmltcGxlbWVudGVkIGZvciBub3cuXHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0tleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuJyk7XHJcbiAgICB9XHJcbiAgICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSBrZXkgZm9yIGEgbm9kZSBuZXZlciBjaGFuZ2VzLlxyXG4gICAgfVxyXG4gICAgbWluUG9zdCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUlOO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZWFsbHkgYmUgY3JlYXRlZCBvbmNlIGFuZCBjYWNoZWQgaW4gYSBzdGF0aWMgcHJvcGVydHksIGJ1dFxyXG4gICAgICAgIC8vIE5hbWVkTm9kZSBpc24ndCBkZWZpbmVkIHlldCwgc28gSSBjYW4ndCB1c2UgaXQgaW4gYSBzdGF0aWMuICBCbGVoLlxyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBfX0VNUFRZX05PREUpO1xyXG4gICAgfVxyXG4gICAgbWFrZVBvc3QoaW5kZXhWYWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGFzc2VydCh0eXBlb2YgaW5kZXhWYWx1ZSA9PT0gJ3N0cmluZycsICdLZXlJbmRleCBpbmRleFZhbHVlIG11c3QgYWx3YXlzIGJlIGEgc3RyaW5nLicpO1xyXG4gICAgICAgIC8vIFdlIGp1c3QgdXNlIGVtcHR5IG5vZGUsIGJ1dCBpdCdsbCBuZXZlciBiZSBjb21wYXJlZCwgc2luY2Ugb3VyIGNvbXBhcmF0b3Igb25seSBsb29rcyBhdCBuYW1lLlxyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKGluZGV4VmFsdWUsIF9fRU1QVFlfTk9ERSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJy5rZXknO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IEtFWV9JTkRFWCA9IG5ldyBLZXlJbmRleCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaXRlcmF0b3Igb3ZlciBhbiBMTFJCTm9kZS5cclxuICovXHJcbmNsYXNzIFNvcnRlZE1hcEl0ZXJhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGl0ZXJhdGUuXHJcbiAgICAgKiBAcGFyYW0gaXNSZXZlcnNlXyAtIFdoZXRoZXIgb3Igbm90IHRvIGl0ZXJhdGUgaW4gcmV2ZXJzZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlXywgcmVzdWx0R2VuZXJhdG9yXyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmlzUmV2ZXJzZV8gPSBpc1JldmVyc2VfO1xyXG4gICAgICAgIHRoaXMucmVzdWx0R2VuZXJhdG9yXyA9IHJlc3VsdEdlbmVyYXRvcl87XHJcbiAgICAgICAgdGhpcy5ub2RlU3RhY2tfID0gW107XHJcbiAgICAgICAgbGV0IGNtcCA9IDE7XHJcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xyXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBjb21wYXJpc29uIGlmIHdlJ3JlIGdvaW5nIGluIHJldmVyc2VcclxuICAgICAgICAgICAgaWYgKGlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZXhhY3RseSBlcXVhbCB0byBvdXIgc3RhcnQga2V5LiBQdXNoIGl0IG9uIHRoZSBzdGFjaywgYnV0IHN0b3AgaXRlcmF0aW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZSB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE5leHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2tfLnBvcCgpO1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgcGVlaygpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrX1t0aGlzLm5vZGVTdGFja18ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRHZW5lcmF0b3JfKG5vZGUua2V5LCBub2RlLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbm9kZSBpbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2sgdHJlZS5cclxuICovXHJcbmNsYXNzIExMUkJOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cclxuICAgICAqIEBwYXJhbSBjb2xvciAtIFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cclxuICAgICAqIEBwYXJhbSBsZWZ0IC0gTGVmdCBjaGlsZC5cclxuICAgICAqIEBwYXJhbSByaWdodCAtIFJpZ2h0IGNoaWxkLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcclxuICAgICAgICB0aGlzLmxlZnQgPVxyXG4gICAgICAgICAgICBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9XHJcbiAgICAgICAgICAgIHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IHJlcGxhY2luZyBwaWVjZXMgb2YgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIE5ldyBrZXkgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gTmV3IHZhbHVlIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSBjb2xvciAtIE5ldyBjb2xvciBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gbGVmdCAtIE5ldyBsZWZ0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSByaWdodCAtIE5ldyByaWdodCBjaGlsZCBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbm9kZSBjb3B5LlxyXG4gICAgICovXHJcbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5ICE9IG51bGwgPyBrZXkgOiB0aGlzLmtleSwgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy52YWx1ZSwgY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogdGhpcy5jb2xvciwgbGVmdCAhPSBudWxsID8gbGVmdCA6IHRoaXMubGVmdCwgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogdGhpcy5yaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY291bnQoKSArIDEgKyB0aGlzLnJpZ2h0LmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2ggbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAgICAgKiAgIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxyXG4gICAgICogICB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb25cclxuICAgICAqL1xyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgISFhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2ggbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAgICAgKiBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgbWluXygpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluXygpLmtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBpbnNlcnQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBpbnNlcnQuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBjb25zdCBjbXAgPSBjb21wYXJhdG9yKGtleSwgbi5rZXkpO1xyXG4gICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIHZhbHVlLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIHdpdGggdGhlIG1pbmltdW0ga2V5IHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU1pbl8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW5fKCksIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGl0ZW0gcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBuLCBzbWFsbGVzdDtcclxuICAgICAgICBuID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkXygpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRSaWdodF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4ucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3QgPSBuLnJpZ2h0Lm1pbl8oKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluXygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlKGtleSwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGlzIGlzIGEgUkVEIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGlzUmVkXygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgZml4VXBfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAobi5yaWdodC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5yaWdodC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZExlZnQuXHJcbiAgICAgKi9cclxuICAgIG1vdmVSZWRMZWZ0XygpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJvdGF0ZVJpZ2h0XygpKTtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIG1vdmVSZWRSaWdodC5cclxuICAgICAqL1xyXG4gICAgbW92ZVJlZFJpZ2h0XygpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xyXG4gICAgICAgIGlmIChuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZUxlZnQuXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZUxlZnRfKCkge1xyXG4gICAgICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZVJpZ2h0LlxyXG4gICAgICovXHJcbiAgICByb3RhdGVSaWdodF8oKSB7XHJcbiAgICAgICAgY29uc3QgbnIgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCB0aGlzLmxlZnQucmlnaHQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBudWxsLCBucik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5ld3QgcmVlLCBhZnRlciBjb2xvckZsaXAuXHJcbiAgICAgKi9cclxuICAgIGNvbG9yRmxpcF8oKSB7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsICF0aGlzLmxlZnQuY29sb3IsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsICF0aGlzLnJpZ2h0LmNvbG9yLCBudWxsLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIG51bGwsICF0aGlzLmNvbG9yLCBsZWZ0LCByaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciB0ZXN0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGlzIHdlbGwuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrTWF4RGVwdGhfKCkge1xyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrXygpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLjAsIGJsYWNrRGVwdGgpIDw9IHRoaXMuY291bnQoKSArIDE7XHJcbiAgICB9XHJcbiAgICBjaGVja18oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZWRfKCkgJiYgdGhpcy5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkIG5vZGUgaGFzIHJlZCBjaGlsZCgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSaWdodCBjaGlsZCBvZiAoJyArIHRoaXMua2V5ICsgJywnICsgdGhpcy52YWx1ZSArICcpIGlzIHJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBibGFja0RlcHRoID0gdGhpcy5sZWZ0LmNoZWNrXygpO1xyXG4gICAgICAgIGlmIChibGFja0RlcHRoICE9PSB0aGlzLnJpZ2h0LmNoZWNrXygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmxhY2sgZGVwdGhzIGRpZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsYWNrRGVwdGggKyAodGhpcy5pc1JlZF8oKSA/IDAgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuTExSQk5vZGUuUkVEID0gdHJ1ZTtcclxuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cclxuICovXHJcbmNsYXNzIExMUkJFbXB0eU5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBub2RlIGNvcHkuXHJcbiAgICAgKi9cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIGl0ZW0gYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIHZhbHVlLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCBpdGVtIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXksIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWluS2V5KCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgbWF4S2V5KCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY2hlY2tfKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgbm9kZSBpcyByZWQuXHJcbiAgICAgKi9cclxuICAgIGlzUmVkXygpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcclxuICogdHJlZS5cclxuICovXHJcbmNsYXNzIFNvcnRlZE1hcCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yXyAtIEtleSBjb21wYXJhdG9yLlxyXG4gICAgICogQHBhcmFtIHJvb3RfIC0gT3B0aW9uYWwgcm9vdCBub2RlIGZvciB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yXywgcm9vdF8gPSBTb3J0ZWRNYXAuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgIHRoaXMuY29tcGFyYXRvcl8gPSBjb21wYXJhdG9yXztcclxuICAgICAgICB0aGlzLnJvb3RfID0gcm9vdF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQgb3IgcmVwbGFjZWQuXHJcbiAgICAgKiAoVE9ETzogV2Ugc2hvdWxkIHBlcmhhcHMgcmVuYW1lIHRoaXMgbWV0aG9kIHRvICdwdXQnKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIE5ldyBtYXAsIHdpdGggaXRlbSBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXHJcbiAgICAgICAgICAgIC5pbnNlcnQoa2V5LCB2YWx1ZSwgdGhpcy5jb21wYXJhdG9yXylcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHJlbW92ZS5cclxuICAgICAqIEByZXR1cm5zIE5ldyBtYXAsIHdpdGggaXRlbSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yXywgdGhpcy5yb290X1xyXG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yXylcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsIGlmIHRoZVxyXG4gICAgICoga2V5IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290XztcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbSAqYmVmb3JlKiB0aGUgc3BlY2lmaWVkIGtleSwgb3IgbnVsbCBpZiBrZXkgaXMgdGhlIGZpcnN0IGl0ZW0uXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBmaW5kIHRoZSBwcmVkZWNlc3NvciBvZlxyXG4gICAgICogQHJldHVybnMgVGhlIHByZWRlY2Vzc29yIGtleS5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JLZXkoa2V5KSB7XHJcbiAgICAgICAgbGV0IGNtcCwgbm9kZSA9IHRoaXMucm9vdF8sIHJpZ2h0UGFyZW50ID0gbnVsbDtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLnJpZ2h0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRQYXJlbnQua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGZpcnN0IGl0ZW0uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodFBhcmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBmaW5kIHByZWRlY2Vzc29yIGtleSBmb3IgYSBub25leGlzdGVudCBrZXkuICBXaGF0IGdpdmVzPycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtYXAgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBtaW5pbXVtIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWluS2V5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWF4S2V5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxyXG4gICAgICovXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlcmF0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldEl0ZXJhdG9yKHJlc3VsdEdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290XywgbnVsbCwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvckZyb20oa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGtleSwgcmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBrZXksIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IocmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCB0cnVlLCByZXN1bHRHZW5lcmF0b3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbHdheXMgdXNlIHRoZSBzYW1lIGVtcHR5IG5vZGUsIHRvIHJlZHVjZSBtZW1vcnkuXHJcbiAqL1xyXG5Tb3J0ZWRNYXAuRU1QVFlfTk9ERSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIE5BTUVfT05MWV9DT01QQVJBVE9SKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gbmFtZUNvbXBhcmUobGVmdC5uYW1lLCByaWdodC5uYW1lKTtcclxufVxyXG5mdW5jdGlvbiBOQU1FX0NPTVBBUkFUT1IobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBuYW1lQ29tcGFyZShsZWZ0LCByaWdodCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IE1BWF9OT0RFJDI7XHJcbmZ1bmN0aW9uIHNldE1heE5vZGUkMSh2YWwpIHtcclxuICAgIE1BWF9OT0RFJDIgPSB2YWw7XHJcbn1cclxuY29uc3QgcHJpb3JpdHlIYXNoVGV4dCA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gJ251bWJlcjonICsgZG91YmxlVG9JRUVFNzU0U3RyaW5nKHByaW9yaXR5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnc3RyaW5nOicgKyBwcmlvcml0eTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGEgcHJpb3JpdHkgc25hcHNob3QgTm9kZSBpcyB2YWxpZC5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlUHJpb3JpdHlOb2RlID0gZnVuY3Rpb24gKHByaW9yaXR5Tm9kZSkge1xyXG4gICAgaWYgKHByaW9yaXR5Tm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSBwcmlvcml0eU5vZGUudmFsKCk7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBjb250YWlucyh2YWwsICcuc3YnKSksICdQcmlvcml0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFJDIgfHwgcHJpb3JpdHlOb2RlLmlzRW1wdHkoKSwgJ3ByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS4nKTtcclxuICAgIH1cclxuICAgIC8vIERvbid0IGNhbGwgZ2V0UHJpb3JpdHkoKSBvbiBNQVhfTk9ERSB0byBhdm9pZCBoaXR0aW5nIGFzc2VydGlvbi5cclxuICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFJDIgfHwgcHJpb3JpdHlOb2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpLCBcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcjtcclxuLyoqXHJcbiAqIExlYWZOb2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgbGVhZiBub2RlcyBpbiBhIERhdGFTbmFwc2hvdC4gIEl0XHJcbiAqIGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSAoYSBzdHJpbmcsXHJcbiAqIG51bWJlciwgb3IgYm9vbGVhbikgYWNjZXNzaWJsZSB2aWEgZ2V0VmFsdWUoKS5cclxuICovXHJcbmNsYXNzIExlYWZOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXyAtIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGlzIGxlYWYgbm9kZS4gVGhlIG9iamVjdCB0eXBlIGlzXHJcbiAgICAgKiBwb3NzaWJsZSBpbiB0aGUgZXZlbnQgb2YgYSBkZWZlcnJlZCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5Tm9kZV8gLSBUaGUgcHJpb3JpdHkgb2YgdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZV8sIHByaW9yaXR5Tm9kZV8gPSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlXyA9IHZhbHVlXztcclxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcclxuICAgICAgICBhc3NlcnQodGhpcy52YWx1ZV8gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlXyAhPT0gbnVsbCwgXCJMZWFmTm9kZSBzaG91bGRuJ3QgYmUgY3JlYXRlZCB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlLlwiKTtcclxuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgICAgIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzTGVhZk5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodGhpcy52YWx1ZV8sIG5ld1ByaW9yaXR5Tm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIC8vIEhhY2sgdG8gdHJlYXQgcHJpb3JpdHkgYXMgYSByZWd1bGFyIGNoaWxkXHJcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0NoaWxkKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpIHtcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpICYmIGNoaWxkTmFtZSAhPT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKS51cGRhdGVQcmlvcml0eSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlQ2hpbGQocGF0aCwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkgJiYgZnJvbnQgIT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KGZyb250ICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoR2V0TGVuZ3RoKHBhdGgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGZyb250LCBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUudXBkYXRlQ2hpbGQocGF0aFBvcEZyb250KHBhdGgpLCBuZXdDaGlsZE5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBudW1DaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZm9yRWFjaENoaWxkKGluZGV4LCBhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YWwoZXhwb3J0Rm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJy52YWx1ZSc6IHRoaXMuZ2V0VmFsdWUoKSxcclxuICAgICAgICAgICAgICAgICcucHJpb3JpdHknOiB0aGlzLmdldFByaW9yaXR5KCkudmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBoYXNoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhenlIYXNoXyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgdG9IYXNoID0gJyc7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmlvcml0eU5vZGVfLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdG9IYXNoICs9XHJcbiAgICAgICAgICAgICAgICAgICAgJ3ByaW9yaXR5OicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eUhhc2hUZXh0KHRoaXMucHJpb3JpdHlOb2RlXy52YWwoKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcclxuICAgICAgICAgICAgdG9IYXNoICs9IHR5cGUgKyAnOic7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdG9IYXNoICs9IGRvdWJsZVRvSUVFRTc1NFN0cmluZyh0aGlzLnZhbHVlXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gdGhpcy52YWx1ZV87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBzaGExKHRvSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGxlYWYgbm9kZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgbm9kZS5cclxuICAgICAqL1xyXG4gICAgZ2V0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyIGluc3RhbmNlb2YgTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQob3RoZXIuaXNMZWFmTm9kZSgpLCAnVW5rbm93biBub2RlIHR5cGUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvTGVhZk5vZGVfKG90aGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmlzb24gc3BlY2lmaWNhbGx5IGZvciB0d28gbGVhZiBub2Rlc1xyXG4gICAgICovXHJcbiAgICBjb21wYXJlVG9MZWFmTm9kZV8ob3RoZXJMZWFmKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJMZWFmVHlwZSA9IHR5cGVvZiBvdGhlckxlYWYudmFsdWVfO1xyXG4gICAgICAgIGNvbnN0IHRoaXNMZWFmVHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcclxuICAgICAgICBjb25zdCBvdGhlckluZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKG90aGVyTGVhZlR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNJbmRleCA9IExlYWZOb2RlLlZBTFVFX1RZUEVfT1JERVIuaW5kZXhPZih0aGlzTGVhZlR5cGUpO1xyXG4gICAgICAgIGFzc2VydChvdGhlckluZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIG90aGVyTGVhZlR5cGUpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzSW5kZXggPj0gMCwgJ1Vua25vd24gbGVhZiB0eXBlOiAnICsgdGhpc0xlYWZUeXBlKTtcclxuICAgICAgICBpZiAob3RoZXJJbmRleCA9PT0gdGhpc0luZGV4KSB7XHJcbiAgICAgICAgICAgIC8vIFNhbWUgdHlwZSwgY29tcGFyZSB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXNMZWFmVHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkIHZhbHVlIG5vZGVzIGFyZSBhbGwgZXF1YWwsIGJ1dCB3ZSBzaG91bGQgYWxzbyBuZXZlciBnZXQgdG8gdGhpcyBwb2ludC4uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3b3JrcyBiZWNhdXNlIHRydWUgPiBmYWxzZSwgYWxsIG90aGVycyBhcmUgbnVtYmVyIG9yIHN0cmluZyBjb21wYXJpc29uc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVfIDwgb3RoZXJMZWFmLnZhbHVlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVfID09PSBvdGhlckxlYWYudmFsdWVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNJbmRleCAtIG90aGVySW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2l0aEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNJbmRleGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJMZWFmID0gb3RoZXI7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZV8gPT09IG90aGVyTGVhZi52YWx1ZV8gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXy5lcXVhbHMob3RoZXJMZWFmLnByaW9yaXR5Tm9kZV8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBzb3J0IG9yZGVyIGZvciBjb21wYXJpbmcgbGVhZiBub2RlcyBvZiBkaWZmZXJlbnQgdHlwZXMuIElmIHR3byBsZWFmIG5vZGVzIGhhdmVcclxuICogdGhlIHNhbWUgdHlwZSwgdGhlIGNvbXBhcmlzb24gZmFsbHMgYmFjayB0byB0aGVpciB2YWx1ZVxyXG4gKi9cclxuTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUiA9IFsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgbm9kZUZyb21KU09OJDE7XHJcbmxldCBNQVhfTk9ERSQxO1xyXG5mdW5jdGlvbiBzZXROb2RlRnJvbUpTT04odmFsKSB7XHJcbiAgICBub2RlRnJvbUpTT04kMSA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzZXRNYXhOb2RlKHZhbCkge1xyXG4gICAgTUFYX05PREUkMSA9IHZhbDtcclxufVxyXG5jbGFzcyBQcmlvcml0eUluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYVByaW9yaXR5ID0gYS5ub2RlLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgY29uc3QgYlByaW9yaXR5ID0gYi5ub2RlLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhUHJpb3JpdHkuY29tcGFyZVRvKGJQcmlvcml0eSk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhbm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5nZXRQcmlvcml0eSgpLmVxdWFscyhuZXdOb2RlLmdldFByaW9yaXR5KCkpO1xyXG4gICAgfVxyXG4gICAgbWluUG9zdCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUlOO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShNQVhfTkFNRSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBNQVhfTk9ERSQxKSk7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcHJpb3JpdHlOb2RlID0gbm9kZUZyb21KU09OJDEoaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBwcmlvcml0eU5vZGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLnByaW9yaXR5JztcclxuICAgIH1cclxufVxyXG5jb25zdCBQUklPUklUWV9JTkRFWCA9IG5ldyBQcmlvcml0eUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR18yID0gTWF0aC5sb2coMik7XHJcbmNsYXNzIEJhc2UxMk51bSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBsb2dCYXNlMiA9IChudW0pID0+IFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcGFyc2VJbnQoKE1hdGgubG9nKG51bSkgLyBMT0dfMiksIDEwKTtcclxuICAgICAgICBjb25zdCBiaXRNYXNrID0gKGJpdHMpID0+IHBhcnNlSW50KEFycmF5KGJpdHMgKyAxKS5qb2luKCcxJyksIDIpO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBsb2dCYXNlMihsZW5ndGggKyAxKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRfID0gdGhpcy5jb3VudCAtIDE7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IGJpdE1hc2sodGhpcy5jb3VudCk7XHJcbiAgICAgICAgdGhpcy5iaXRzXyA9IChsZW5ndGggKyAxKSAmIG1hc2s7XHJcbiAgICB9XHJcbiAgICBuZXh0Qml0SXNPbmUoKSB7XHJcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNCaXR3aXNlT3BlcmF0b3JVc2FnZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICEodGhpcy5iaXRzXyAmICgweDEgPDwgdGhpcy5jdXJyZW50XykpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudF8tLTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhIGxpc3Qgb2YgY2hpbGQgbm9kZXMgYW5kIGNvbnN0cnVjdHMgYSBTb3J0ZWRTZXQgdXNpbmcgdGhlIGdpdmVuIGNvbXBhcmlzb25cclxuICogZnVuY3Rpb25cclxuICpcclxuICogVXNlcyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiB0aGUgcGFwZXIgbGlua2VkIGhlcmU6XHJcbiAqIGh0dHA6Ly9jaXRlc2VlcnguaXN0LnBzdS5lZHUvdmlld2RvYy9zdW1tYXJ5P2RvaT0xMC4xLjEuNDYuMTQ1OFxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGRMaXN0IC0gVW5zb3J0ZWQgbGlzdCBvZiBjaGlsZHJlblxyXG4gKiBAcGFyYW0gY21wIC0gVGhlIGNvbXBhcmlzb24gbWV0aG9kIHRvIGJlIHVzZWRcclxuICogQHBhcmFtIGtleUZuIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXh0cmFjdCBLIGZyb20gYSBub2RlIHdyYXBwZXIsIGlmIEsnc1xyXG4gKiB0eXBlIGlzIG5vdCBOYW1lZE5vZGVcclxuICogQHBhcmFtIG1hcFNvcnRGbiAtIEFuIG9wdGlvbmFsIG92ZXJyaWRlIGZvciBjb21wYXJhdG9yIHVzZWQgYnkgdGhlIGdlbmVyYXRlZCBzb3J0ZWQgbWFwXHJcbiAqL1xyXG5jb25zdCBidWlsZENoaWxkU2V0ID0gZnVuY3Rpb24gKGNoaWxkTGlzdCwgY21wLCBrZXlGbiwgbWFwU29ydEZuKSB7XHJcbiAgICBjaGlsZExpc3Quc29ydChjbXApO1xyXG4gICAgY29uc3QgYnVpbGRCYWxhbmNlZFRyZWUgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaGlnaCAtIGxvdztcclxuICAgICAgICBsZXQgbmFtZWROb2RlO1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFtsb3ddO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gcGFyc2VJbnQoKGxlbmd0aCAvIDIpLCAxMCkgKyBsb3c7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBidWlsZEJhbGFuY2VkVHJlZShsb3csIG1pZGRsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gYnVpbGRCYWxhbmNlZFRyZWUobWlkZGxlICsgMSwgaGlnaCk7XHJcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFttaWRkbGVdO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgYnVpbGRGcm9tMTJBcnJheSA9IGZ1bmN0aW9uIChiYXNlMTIpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHJvb3QgPSBudWxsO1xyXG4gICAgICAgIGxldCBpbmRleCA9IGNoaWxkTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYnVpbGRQZW5uYW50ID0gZnVuY3Rpb24gKGNodW5rU2l6ZSwgY29sb3IpIHtcclxuICAgICAgICAgICAgY29uc3QgbG93ID0gaW5kZXggLSBjaHVua1NpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBpbmRleDtcclxuICAgICAgICAgICAgaW5kZXggLT0gY2h1bmtTaXplO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSBidWlsZEJhbGFuY2VkVHJlZShsb3cgKyAxLCBoaWdoKTtcclxuICAgICAgICAgICAgY29uc3QgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgYXR0YWNoUGVubmFudChuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgY29sb3IsIG51bGwsIGNoaWxkVHJlZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXR0YWNoUGVubmFudCA9IGZ1bmN0aW9uIChwZW5uYW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb290ID0gcGVubmFudDtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2UxMi5jb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzT25lID0gYmFzZTEyLm5leHRCaXRJc09uZSgpO1xyXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG5vZGVzIHRha2VuIGluIGVhY2ggc2xpY2UgaXMgMl4oYXJyLmxlbmd0aCAtIChpICsgMSkpXHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgucG93KDIsIGJhc2UxMi5jb3VudCAtIChpICsgMSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNPbmUpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkUGVubmFudChjaHVua1NpemUsIExMUkJOb2RlLkJMQUNLKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgPT0gMlxyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuQkxBQ0spO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuUkVEKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH07XHJcbiAgICBjb25zdCBiYXNlMTIgPSBuZXcgQmFzZTEyTnVtKGNoaWxkTGlzdC5sZW5ndGgpO1xyXG4gICAgY29uc3Qgcm9vdCA9IGJ1aWxkRnJvbTEyQXJyYXkoYmFzZTEyKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChtYXBTb3J0Rm4gfHwgY21wLCByb290KTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IF9kZWZhdWx0SW5kZXhNYXA7XHJcbmNvbnN0IGZhbGxiYWNrT2JqZWN0ID0ge307XHJcbmNsYXNzIEluZGV4TWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4ZXNfLCBpbmRleFNldF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4ZXNfID0gaW5kZXhlc187XHJcbiAgICAgICAgdGhpcy5pbmRleFNldF8gPSBpbmRleFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IEluZGV4TWFwIGZvciBub2RlcyB3aXRob3V0IGEgcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICAgIGFzc2VydChmYWxsYmFja09iamVjdCAmJiBQUklPUklUWV9JTkRFWCwgJ0NoaWxkcmVuTm9kZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XHJcbiAgICAgICAgX2RlZmF1bHRJbmRleE1hcCA9XHJcbiAgICAgICAgICAgIF9kZWZhdWx0SW5kZXhNYXAgfHxcclxuICAgICAgICAgICAgICAgIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBmYWxsYmFja09iamVjdCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KTtcclxuICAgICAgICByZXR1cm4gX2RlZmF1bHRJbmRleE1hcDtcclxuICAgIH1cclxuICAgIGdldChpbmRleEtleSkge1xyXG4gICAgICAgIGNvbnN0IHNvcnRlZE1hcCA9IHNhZmVHZXQodGhpcy5pbmRleGVzXywgaW5kZXhLZXkpO1xyXG4gICAgICAgIGlmICghc29ydGVkTWFwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5kZXggZGVmaW5lZCBmb3IgJyArIGluZGV4S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvcnRlZE1hcCBpbnN0YW5jZW9mIFNvcnRlZE1hcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29ydGVkTWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGluZGV4IGV4aXN0cywgYnV0IGl0IGZhbGxzIGJhY2sgdG8ganVzdCBuYW1lIGNvbXBhcmlzb24uIFJldHVybiBudWxsIHNvIHRoYXQgdGhlIGNhbGxpbmcgY29kZSB1c2VzIHRoZVxyXG4gICAgICAgICAgICAvLyByZWd1bGFyIGNoaWxkIG1hcFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNJbmRleChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gY29udGFpbnModGhpcy5pbmRleFNldF8sIGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGFkZEluZGV4KGluZGV4RGVmaW5pdGlvbiwgZXhpc3RpbmdDaGlsZHJlbikge1xyXG4gICAgICAgIGFzc2VydChpbmRleERlZmluaXRpb24gIT09IEtFWV9JTkRFWCwgXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCIpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCBzYXdJbmRleGVkVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBpdGVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXRJdGVyYXRvcihOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgICAgICBzYXdJbmRleGVkVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgc2F3SW5kZXhlZFZhbHVlIHx8IGluZGV4RGVmaW5pdGlvbi5pc0RlZmluZWRPbihuZXh0Lm5vZGUpO1xyXG4gICAgICAgICAgICBjaGlsZExpc3QucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3SW5kZXg7XHJcbiAgICAgICAgaWYgKHNhd0luZGV4ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICBuZXdJbmRleCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleERlZmluaXRpb24uZ2V0Q29tcGFyZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4ID0gZmFsbGJhY2tPYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZGV4TmFtZSA9IGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IG5ld0luZGV4U2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRleFNldF8pO1xyXG4gICAgICAgIG5ld0luZGV4U2V0W2luZGV4TmFtZV0gPSBpbmRleERlZmluaXRpb247XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW5kZXhlc18pO1xyXG4gICAgICAgIG5ld0luZGV4ZXNbaW5kZXhOYW1lXSA9IG5ld0luZGV4O1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgbmV3SW5kZXhTZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGlzIG5vZGUgaXMgcHJvcGVybHkgdHJhY2tlZCBpbiBhbnkgaW5kZXhlcyB0aGF0IHdlJ3JlIG1haW50YWluaW5nXHJcbiAgICAgKi9cclxuICAgIGFkZFRvSW5kZXhlcyhuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbWFwKHRoaXMuaW5kZXhlc18sIChpbmRleGVkQ2hpbGRyZW4sIGluZGV4TmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHNhZmVHZXQodGhpcy5pbmRleFNldF8sIGluZGV4TmFtZSk7XHJcbiAgICAgICAgICAgIGFzc2VydChpbmRleCwgJ01pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yICcgKyBpbmRleE5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhlZENoaWxkcmVuID09PSBmYWxsYmFja09iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gaW5kZXggZXZlcnl0aGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4LmlzRGVmaW5lZE9uKG5hbWVkTm9kZS5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYnVpbGQgdGhpcyBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Lm5hbWUgIT09IG5hbWVkTm9kZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3QucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5hbWVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleC5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCB0aGlzIHJlbWFpbnMgYSBmYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFja09iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU25hcCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5hbWVkTm9kZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbiA9IGluZGV4ZWRDaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1NuYXApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IG5ld0NoaWxkcmVuLnJlbW92ZShuZXcgTmFtZWROb2RlKG5hbWVkTm9kZS5uYW1lLCBleGlzdGluZ1NuYXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZHJlbi5pbnNlcnQobmFtZWROb2RlLCBuYW1lZE5vZGUubm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IEluZGV4TWFwIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRnJvbUluZGV4ZXMobmFtZWROb2RlLCBleGlzdGluZ0NoaWxkcmVuKSB7XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IG1hcCh0aGlzLmluZGV4ZXNfLCAoaW5kZXhlZENoaWxkcmVuKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmYWxsYmFjay4gSnVzdCByZXR1cm4gaXQsIG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW4ucmVtb3ZlKG5ldyBOYW1lZE5vZGUobmFtZWROb2RlLm5hbWUsIGV4aXN0aW5nU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkIG9mIHRoaXMgY2hpbGRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCB0aGlzLmluZGV4U2V0Xyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVE9ETzogRm9yIG1lbW9yeSBzYXZpbmdzLCBkb24ndCBzdG9yZSBwcmlvcml0eU5vZGVfIGlmIGl0J3MgZW1wdHkuXHJcbmxldCBFTVBUWV9OT0RFO1xyXG4vKipcclxuICogQ2hpbGRyZW5Ob2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgaW50ZXJuYWwgbm9kZXMgaW4gYSBEYXRhU25hcHNob3RcclxuICogKGkuZS4gbm9kZXMgd2l0aCBjaGlsZHJlbikuICBJdCBpbXBsZW1lbnRzIE5vZGUgYW5kIHN0b3JlcyB0aGVcclxuICogbGlzdCBvZiBjaGlsZHJlbiBpbiB0aGUgY2hpbGRyZW4gcHJvcGVydHksIHNvcnRlZCBieSBjaGlsZCBuYW1lLlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRyZW5Ob2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXyAtIExpc3Qgb2YgY2hpbGRyZW4gb2YgdGhpcyBub2RlLi5cclxuICAgICAqIEBwYXJhbSBwcmlvcml0eU5vZGVfIC0gVGhlIHByaW9yaXR5IG9mIHRoaXMgbm9kZSAoYXMgYSBzbmFwc2hvdCBub2RlKS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW5fLCBwcmlvcml0eU5vZGVfLCBpbmRleE1hcF8pIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IGNoaWxkcmVuXztcclxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYXBfID0gaW5kZXhNYXBfO1xyXG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3RlOiBUaGUgb25seSByZWFzb24gd2UgYWxsb3cgbnVsbCBwcmlvcml0eSBpcyBmb3IgRU1QVFlfTk9ERSwgc2luY2Ugd2UgY2FuJ3QgdXNlXHJcbiAgICAgICAgICogRU1QVFlfTk9ERSBhcyB0aGUgcHJpb3JpdHkgb2YgRU1QVFlfTk9ERS4gIFdlIG1pZ2h0IHdhbnQgdG8gY29uc2lkZXIgbWFraW5nIEVNUFRZX05PREUgaXRzIG93blxyXG4gICAgICAgICAqIGNsYXNzIGluc3RlYWQgb2YgYW4gZW1wdHkgQ2hpbGRyZW5Ob2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLnByaW9yaXR5Tm9kZV8pIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVQcmlvcml0eU5vZGUodGhpcy5wcmlvcml0eU5vZGVfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBhc3NlcnQoIXRoaXMucHJpb3JpdHlOb2RlXyB8fCB0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpLCAnQW4gZW1wdHkgbm9kZSBjYW5ub3QgaGF2ZSBhIHByaW9yaXR5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBFTVBUWV9OT0RFKCkge1xyXG4gICAgICAgIHJldHVybiAoRU1QVFlfTk9ERSB8fFxyXG4gICAgICAgICAgICAoRU1QVFlfTk9ERSA9IG5ldyBDaGlsZHJlbk5vZGUobmV3IFNvcnRlZE1hcChOQU1FX0NPTVBBUkFUT1IpLCBudWxsLCBJbmRleE1hcC5EZWZhdWx0KSkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBpc0xlYWZOb2RlKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXyB8fCBFTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVQcmlvcml0eShuZXdQcmlvcml0eU5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGFsbG93IHByaW9yaXRpZXMgb24gZW1wdHkgbm9kZXNcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgbmV3UHJpb3JpdHlOb2RlLCB0aGlzLmluZGV4TWFwXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICAvLyBIYWNrIHRvIHRyZWF0IHByaW9yaXR5IGFzIGEgcmVndWxhciBjaGlsZFxyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IG51bGwgPyBFTVBUWV9OT0RFIDogY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkuZ2V0Q2hpbGQocGF0aFBvcEZyb250KHBhdGgpKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaGFzQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGFzc2VydChuZXdDaGlsZE5vZGUsICdXZSBzaG91bGQgYWx3YXlzIGJlIHBhc3Npbmcgc25hcHNob3Qgbm9kZXMnKTtcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbiwgbmV3SW5kZXhNYXA7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5fLnJlbW92ZShjaGlsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5yZW1vdmVGcm9tSW5kZXhlcyhuYW1lZE5vZGUsIHRoaXMuY2hpbGRyZW5fKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8uaW5zZXJ0KGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkVG9JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ByaW9yaXR5ID0gbmV3Q2hpbGRyZW4uaXNFbXB0eSgpXHJcbiAgICAgICAgICAgICAgICA/IEVNUFRZX05PREVcclxuICAgICAgICAgICAgICAgIDogdGhpcy5wcmlvcml0eU5vZGVfO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShuZXdDaGlsZHJlbiwgbmV3UHJpb3JpdHksIG5ld0luZGV4TWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZUNoaWxkKHBhdGgsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgIGlmIChmcm9udCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRGcm9udChwYXRoKSAhPT0gJy5wcmlvcml0eScgfHwgcGF0aEdldExlbmd0aChwYXRoKSA9PT0gMSwgJy5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aCcpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJbW1lZGlhdGVDaGlsZCA9IHRoaXMuZ2V0SW1tZWRpYXRlQ2hpbGQoZnJvbnQpLnVwZGF0ZUNoaWxkKHBhdGhQb3BGcm9udChwYXRoKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIG5ld0ltbWVkaWF0ZUNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgbnVtQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHZhbChleHBvcnRGb3JtYXQpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgICAgIGxldCBudW1LZXlzID0gMCwgbWF4S2V5ID0gMCwgYWxsSW50ZWdlcktleXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgb2JqW2tleV0gPSBjaGlsZE5vZGUudmFsKGV4cG9ydEZvcm1hdCk7XHJcbiAgICAgICAgICAgIG51bUtleXMrKztcclxuICAgICAgICAgICAgaWYgKGFsbEludGVnZXJLZXlzICYmIENoaWxkcmVuTm9kZS5JTlRFR0VSX1JFR0VYUF8udGVzdChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBNYXRoLm1heChtYXhLZXksIE51bWJlcihrZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsbEludGVnZXJLZXlzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWV4cG9ydEZvcm1hdCAmJiBhbGxJbnRlZ2VyS2V5cyAmJiBtYXhLZXkgPCAyICogbnVtS2V5cykge1xyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIGFycmF5LlxyXG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChleHBvcnRGb3JtYXQgJiYgIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG9ialsnLnByaW9yaXR5J10gPSB0aGlzLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGhhc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF6eUhhc2hfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0b0hhc2ggPSAnJztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz1cclxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5SGFzaFRleHQodGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEhhc2ggPSBjaGlsZE5vZGUuaGFzaCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSGFzaCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0hhc2ggKz0gJzonICsga2V5ICsgJzonICsgY2hpbGRIYXNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSB0b0hhc2ggPT09ICcnID8gJycgOiBzaGExKHRvSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hpbGROYW1lLCBjaGlsZE5vZGUsIGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4KTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZWRlY2Vzc29yID0gaWR4LmdldFByZWRlY2Vzc29yS2V5KG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZWRlY2Vzc29yID8gcHJlZGVjZXNzb3IubmFtZSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0UHJlZGVjZXNzb3JLZXkoY2hpbGROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbktleSA9IGlkeC5taW5LZXkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1pbktleSAmJiBtaW5LZXkubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5taW5LZXkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdENoaWxkKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG1pbktleSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAobWluS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG1pbktleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1pbktleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBpbmRleCwgcmV0dXJuIHRoZSBrZXkgbmFtZSBvZiB0aGUgbGFyZ2VzdCB2YWx1ZSB3ZSBoYXZlLCBhY2NvcmRpbmcgdG8gdGhhdCBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRMYXN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF4S2V5ID0gaWR4Lm1heEtleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF4S2V5ICYmIG1heEtleS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldExhc3RDaGlsZChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBtYXhLZXkgPSB0aGlzLmdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAobWF4S2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG1heEtleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1heEtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yRWFjaENoaWxkKGluZGV4LCBhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5pbm9yZGVyVHJhdmVyc2FsKHdyYXBwZWROb2RlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24od3JhcHBlZE5vZGUubmFtZSwgd3JhcHBlZE5vZGUubm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvcihpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVyYXRvckZyb20oaW5kZXhEZWZpbml0aW9uLm1pblBvc3QoKSwgaW5kZXhEZWZpbml0aW9uKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBrZXkgPT4ga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIHN0YXJ0UG9zdCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWF4UG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZHguZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuY2hpbGRyZW5fLmdldFJldmVyc2VJdGVyYXRvckZyb20oZW5kUG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIGVuZFBvc3QpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSB8fCBvdGhlci5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyID09PSBNQVhfTk9ERSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNdXN0IGJlIGFub3RoZXIgbm9kZSB3aXRoIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aXRoSW5kZXgoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS0VZX0lOREVYIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBfLmhhc0luZGV4KGluZGV4RGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLmFkZEluZGV4KGluZGV4RGVmaW5pdGlvbiwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgdGhpcy5wcmlvcml0eU5vZGVfLCBuZXdJbmRleE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNJbmRleGVkKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSBLRVlfSU5ERVggfHwgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJDaGlsZHJlbk5vZGUgPSBvdGhlcjtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuZXF1YWxzKG90aGVyQ2hpbGRyZW5Ob2RlLmdldFByaW9yaXR5KCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHJlbl8uY291bnQoKSA9PT0gb3RoZXJDaGlsZHJlbk5vZGUuY2hpbGRyZW5fLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNJdGVyID0gdGhpcy5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckl0ZXIgPSBvdGhlckNoaWxkcmVuTm9kZS5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzQ3VycmVudCAmJiBvdGhlckN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0N1cnJlbnQubmFtZSAhPT0gb3RoZXJDdXJyZW50Lm5hbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXNDdXJyZW50Lm5vZGUuZXF1YWxzKG90aGVyQ3VycmVudC5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNDdXJyZW50ID0gdGhpc0l0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyQ3VycmVudCA9IG90aGVySXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0N1cnJlbnQgPT09IG51bGwgJiYgb3RoZXJDdXJyZW50ID09PSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgU29ydGVkTWFwIG9yZGVyZWQgYnkgaW5kZXgsIG9yIG51bGwgaWYgdGhlIGRlZmF1bHQgKGJ5LWtleSkgb3JkZXJpbmcgY2FuIGJlIHVzZWRcclxuICAgICAqIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICByZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGlmIChpbmRleERlZmluaXRpb24gPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFwXy5nZXQoaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5DaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfID0gL14oMHxbMS05XVxcZCopJC87XHJcbmNsYXNzIE1heE5vZGUgZXh0ZW5kcyBDaGlsZHJlbk5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIobmV3IFNvcnRlZE1hcChOQU1FX0NPTVBBUkFUT1IpLCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgSW5kZXhNYXAuRGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICAvLyBOb3QgdGhhdCB3ZSBldmVyeSBjb21wYXJlIGl0LCBidXQgTUFYX05PREUgaXMgb25seSBldmVyIGVxdWFsIHRvIGl0c2VsZlxyXG4gICAgICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcclxuICAgIH1cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hcmtlciB0aGF0IHdpbGwgc29ydCBoaWdoZXIgdGhhbiBhbnkgb3RoZXIgc25hcHNob3QuXHJcbiAqL1xyXG5jb25zdCBNQVhfTk9ERSA9IG5ldyBNYXhOb2RlKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE5hbWVkTm9kZSwge1xyXG4gICAgTUlOOiB7XHJcbiAgICAgICAgdmFsdWU6IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKVxyXG4gICAgfSxcclxuICAgIE1BWDoge1xyXG4gICAgICAgIHZhbHVlOiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBNQVhfTk9ERSlcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG4gKiBSZWZlcmVuY2UgRXh0ZW5zaW9uc1xyXG4gKi9cclxuS2V5SW5kZXguX19FTVBUWV9OT0RFID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbkxlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSBDaGlsZHJlbk5vZGU7XHJcbnNldE1heE5vZGUkMShNQVhfTk9ERSk7XHJcbnNldE1heE5vZGUoTUFYX05PREUpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBVU0VfSElOWkUgPSB0cnVlO1xyXG4vKipcclxuICogQ29uc3RydWN0cyBhIHNuYXBzaG90IG5vZGUgcmVwcmVzZW50aW5nIHRoZSBwYXNzZWQgSlNPTiBhbmQgcmV0dXJucyBpdC5cclxuICogQHBhcmFtIGpzb24gLSBKU09OIHRvIGNyZWF0ZSBhIG5vZGUgZm9yLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBPcHRpb25hbCBwcmlvcml0eSB0byB1c2UuICBUaGlzIHdpbGwgYmUgaWdub3JlZCBpZiB0aGVcclxuICogcGFzc2VkIEpTT04gY29udGFpbnMgYSAucHJpb3JpdHkgcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlRnJvbUpTT04oanNvbiwgcHJpb3JpdHkgPSBudWxsKSB7XHJcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy5wcmlvcml0eScgaW4ganNvbikge1xyXG4gICAgICAgIHByaW9yaXR5ID0ganNvblsnLnByaW9yaXR5J107XHJcbiAgICB9XHJcbiAgICBhc3NlcnQocHJpb3JpdHkgPT09IG51bGwgfHxcclxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICh0eXBlb2YgcHJpb3JpdHkgPT09ICdvYmplY3QnICYmICcuc3YnIGluIHByaW9yaXR5KSwgJ0ludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogJyArIHR5cGVvZiBwcmlvcml0eSk7XHJcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcudmFsdWUnIGluIGpzb24gJiYganNvblsnLnZhbHVlJ10gIT09IG51bGwpIHtcclxuICAgICAgICBqc29uID0ganNvblsnLnZhbHVlJ107XHJcbiAgICB9XHJcbiAgICAvLyBWYWxpZCBsZWFmIG5vZGVzIGluY2x1ZGUgbm9uLW9iamVjdHMgb3Igc2VydmVyLXZhbHVlIHdyYXBwZXIgb2JqZWN0c1xyXG4gICAgaWYgKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0JyB8fCAnLnN2JyBpbiBqc29uKSB7XHJcbiAgICAgICAgY29uc3QganNvbkxlYWYgPSBqc29uO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUoanNvbkxlYWYsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoanNvbiBpbnN0YW5jZW9mIEFycmF5KSAmJiBVU0VfSElOWkUpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbkhhdmVQcmlvcml0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGhpbnplSnNvbk9iaiA9IGpzb247XHJcbiAgICAgICAgZWFjaChoaW56ZUpzb25PYmosIChrZXksIGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDEpICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBtZXRhZGF0YSBub2Rlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuSGF2ZVByaW9yaXR5ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgfHwgIWNoaWxkTm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoa2V5LCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZFNldCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRyZW4sIE5BTUVfT05MWV9DT01QQVJBVE9SLCBuYW1lZE5vZGUgPT4gbmFtZWROb2RlLm5hbWUsIE5BTUVfQ09NUEFSQVRPUik7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuSGF2ZVByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZENoaWxkU2V0ID0gYnVpbGRDaGlsZFNldChjaGlsZHJlbiwgUFJJT1JJVFlfSU5ERVguZ2V0Q29tcGFyZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGUoY2hpbGRTZXQsIG5vZGVGcm9tSlNPTihwcmlvcml0eSksIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBzb3J0ZWRDaGlsZFNldCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShjaGlsZFNldCwgbm9kZUZyb21KU09OKHByaW9yaXR5KSwgSW5kZXhNYXAuRGVmYXVsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICBlYWNoKGpzb24sIChrZXksIGNoaWxkRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbnMoanNvbiwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtZXRhZGF0YSBub2Rlcy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlzTGVhZk5vZGUoKSB8fCAhY2hpbGROb2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlUHJpb3JpdHkobm9kZUZyb21KU09OKHByaW9yaXR5KSk7XHJcbiAgICB9XHJcbn1cclxuc2V0Tm9kZUZyb21KU09OKG5vZGVGcm9tSlNPTik7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBhdGhJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4UGF0aF8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhQYXRoXyA9IGluZGV4UGF0aF87XHJcbiAgICAgICAgYXNzZXJ0KCFwYXRoSXNFbXB0eShpbmRleFBhdGhfKSAmJiBwYXRoR2V0RnJvbnQoaW5kZXhQYXRoXykgIT09ICcucHJpb3JpdHknLCBcIkNhbid0IGNyZWF0ZSBQYXRoSW5kZXggd2l0aCBlbXB0eSBwYXRoIG9yIC5wcmlvcml0eSBrZXlcIik7XHJcbiAgICB9XHJcbiAgICBleHRyYWN0Q2hpbGQoc25hcCkge1xyXG4gICAgICAgIHJldHVybiBzbmFwLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXyk7XHJcbiAgICB9XHJcbiAgICBpc0RlZmluZWRPbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXykuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYUNoaWxkID0gdGhpcy5leHRyYWN0Q2hpbGQoYS5ub2RlKTtcclxuICAgICAgICBjb25zdCBiQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChiLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4Q21wID0gYUNoaWxkLmNvbXBhcmVUbyhiQ2hpbGQpO1xyXG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgdmFsdWVOb2RlKTtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcclxuICAgIH1cclxuICAgIG1heFBvc3QoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgTUFYX05PREUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBub2RlKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoU2xpY2UodGhpcy5pbmRleFBhdGhfLCAwKS5qb2luKCcvJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgVmFsdWVJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIGNvbXBhcmUoYSwgYikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4Q21wID0gYS5ub2RlLmNvbXBhcmVUbyhiLm5vZGUpO1xyXG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5lcXVhbHMobmV3Tm9kZSk7XHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NQVg7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIHZhbHVlTm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJy52YWx1ZSc7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgVkFMVUVfSU5ERVggPSBuZXcgVmFsdWVJbmRleCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGFuZ2VWYWx1ZShzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwidmFsdWVcIiAvKiBDaGFuZ2VUeXBlLlZBTFVFICovLCBzbmFwc2hvdE5vZGUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZEFkZGVkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUsIG9sZFNuYXApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovLFxyXG4gICAgICAgIHNuYXBzaG90Tm9kZSxcclxuICAgICAgICBjaGlsZE5hbWUsXHJcbiAgICAgICAgb2xkU25hcFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZE1vdmVkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImNoaWxkX21vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9NT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG9lc24ndCByZWFsbHkgZmlsdGVyIG5vZGVzIGJ1dCBhcHBsaWVzIGFuIGluZGV4IHRvIHRoZSBub2RlIGFuZCBrZWVwcyB0cmFjayBvZiBhbnkgY2hhbmdlc1xyXG4gKi9cclxuY2xhc3MgSW5kZXhlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4XyA9IGluZGV4XztcclxuICAgIH1cclxuICAgIHVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGFzc2VydChzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksICdBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkJyk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55dGhpbmcgYWN0dWFsbHkgY2hhbmdlZC5cclxuICAgICAgICBpZiAob2xkQ2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKS5lcXVhbHMobmV3Q2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKSkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjYW4gZW50ZXIgb3IgbGVhdmUgdGhlIHZpZXcgYmVjYXVzZSBhZmZlY3RlZFBhdGggd2FzIHNldCB0byBudWxsLlxyXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFmZmVjdGVkUGF0aCB3aWxsIGFwcGVhciBudWxsIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHNuYXBzaG90cy4gIFNvIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgdGhlc2UgY2FzZXMgYXMgXCJub3RoaW5nIGNoYW5nZWQuXCJcclxuICAgICAgICAgICAgaWYgKG9sZENoaWxkLmlzRW1wdHkoKSA9PT0gbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXHJcbiAgICAgICAgICAgICAgICAvL2Fzc2VydChvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpLCAnT2xkIGFuZCBuZXcgc25hcHNob3RzIHNob3VsZCBiZSBlcXVhbC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbmFwLmhhc0NoaWxkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIG9sZENoaWxkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc25hcC5pc0xlYWZOb2RlKCksICdBIGNoaWxkIHJlbW92ZSB3aXRob3V0IGFuIG9sZCBjaGlsZCBvbmx5IG1ha2VzIHNlbnNlIG9uIGEgbGVhZiBub2RlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoa2V5LCBuZXdDaGlsZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoa2V5LCBuZXdDaGlsZCwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5pc0xlYWZOb2RlKCkgJiYgbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBub2RlIGlzIGluZGV4ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBuZXdDaGlsZCkud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICghb2xkU25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFNuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1NuYXAuaGFzQ2hpbGQoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU25hcC5oYXNDaGlsZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkU25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZENoaWxkLmVxdWFscyhjaGlsZE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChrZXksIGNoaWxkTm9kZSwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZEFkZGVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByaW9yaXR5KG9sZFNuYXAsIG5ld1ByaW9yaXR5KSB7XHJcbiAgICAgICAgaWYgKG9sZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmlsdGVycyBub2RlcyBieSByYW5nZSBhbmQgdXNlcyBhbiBJbmRleEZpbHRlciB0byB0cmFjayBhbnkgY2hhbmdlcyBhZnRlciBmaWx0ZXJpbmcgdGhlIG5vZGVcclxuICovXHJcbmNsYXNzIFJhbmdlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmluZGV4ZWRGaWx0ZXJfID0gbmV3IEluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5zdGFydFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldFN0YXJ0UG9zdF8ocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmVuZFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldEVuZFBvc3RfKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5zdGFydElzSW5jbHVzaXZlXyA9ICFwYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICAgICAgdGhpcy5lbmRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb3N0XztcclxuICAgIH1cclxuICAgIGdldEVuZFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kUG9zdF87XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBpc1dpdGhpblN0YXJ0ID0gdGhpcy5zdGFydElzSW5jbHVzaXZlX1xyXG4gICAgICAgICAgICA/IHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPD0gMFxyXG4gICAgICAgICAgICA6IHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPCAwO1xyXG4gICAgICAgIGNvbnN0IGlzV2l0aGluRW5kID0gdGhpcy5lbmRJc0luY2x1c2l2ZV9cclxuICAgICAgICAgICAgPyB0aGlzLmluZGV4Xy5jb21wYXJlKG5vZGUsIHRoaXMuZ2V0RW5kUG9zdCgpKSA8PSAwXHJcbiAgICAgICAgICAgIDogdGhpcy5pbmRleF8uY29tcGFyZShub2RlLCB0aGlzLmdldEVuZFBvc3QoKSkgPCAwO1xyXG4gICAgICAgIHJldHVybiBpc1dpdGhpblN0YXJ0ICYmIGlzV2l0aGluRW5kO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXMobmV3IE5hbWVkTm9kZShrZXksIG5ld0NoaWxkKSkpIHtcclxuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl8udXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKG5ld1NuYXAuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2hpbGRyZW4gbm9kZSB3aXRoIHRoZSBjb3JyZWN0IGluZGV4LCBub3QgYSBsZWFmIG5vZGU7XHJcbiAgICAgICAgICAgIG5ld1NuYXAgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXHJcbiAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgbmV3U25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgY2hpbGROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRTdGFydFBvc3RfKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKSwgc3RhcnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5taW5Qb3N0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEVuZFBvc3RfKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5kTmFtZSA9IHBhcmFtcy5nZXRJbmRleEVuZE5hbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCksIGVuZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1heFBvc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBsaW1pdCBhbmQgYSByYW5nZSB0byBhIG5vZGUgYW5kIHVzZXMgUmFuZ2VkRmlsdGVyIHRvIGRvIHRoZSBoZWF2eSBsaWZ0aW5nIHdoZXJlIHBvc3NpYmxlXHJcbiAqL1xyXG5jbGFzcyBMaW1pdGVkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydCA9IChub2RlKSA9PiB0aGlzLnJldmVyc2VfID8gdGhpcy53aXRoaW5FbmRQb3N0KG5vZGUpIDogdGhpcy53aXRoaW5TdGFydFBvc3Qobm9kZSk7XHJcbiAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZCA9IChub2RlKSA9PiB0aGlzLnJldmVyc2VfID8gdGhpcy53aXRoaW5TdGFydFBvc3Qobm9kZSkgOiB0aGlzLndpdGhpbkVuZFBvc3Qobm9kZSk7XHJcbiAgICAgICAgdGhpcy53aXRoaW5TdGFydFBvc3QgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wYXJlUmVzID0gdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydElzSW5jbHVzaXZlXyA/IGNvbXBhcmVSZXMgPD0gMCA6IGNvbXBhcmVSZXMgPCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53aXRoaW5FbmRQb3N0ID0gKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGFyZVJlcyA9IHRoaXMuaW5kZXhfLmNvbXBhcmUobm9kZSwgdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZElzSW5jbHVzaXZlXyA/IGNvbXBhcmVSZXMgPD0gMCA6IGNvbXBhcmVSZXMgPCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yYW5nZWRGaWx0ZXJfID0gbmV3IFJhbmdlZEZpbHRlcihwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5saW1pdF8gPSBwYXJhbXMuZ2V0TGltaXQoKTtcclxuICAgICAgICB0aGlzLnJldmVyc2VfID0gIXBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfO1xyXG4gICAgICAgIHRoaXMuZW5kSXNJbmNsdXNpdmVfID0gIXBhcmFtcy5lbmRCZWZvcmVTZXRfO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xyXG4gICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpLmVxdWFscyhuZXdDaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlXHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbmFwLm51bUNoaWxkcmVuKCkgPCB0aGlzLmxpbWl0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBrZXksIG5ld0NoaWxkLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZDtcclxuICAgICAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkgfHwgbmV3U25hcC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjaGlsZHJlbiBub2RlIHdpdGggdGhlIGNvcnJlY3QgaW5kZXgsIG5vdCBhIGxlYWYgbm9kZTtcclxuICAgICAgICAgICAgZmlsdGVyZWQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRfICogMiA8IG5ld1NuYXAubnVtQ2hpbGRyZW4oKSAmJlxyXG4gICAgICAgICAgICAgICAgbmV3U25hcC5pc0luZGV4ZWQodGhpcy5pbmRleF8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFYXNpZXIgdG8gYnVpbGQgdXAgYSBzbmFwc2hvdCwgc2luY2Ugd2hhdCB3ZSdyZSBnaXZlbiBoYXMgbW9yZSB0aGFuIHR3aWNlIHRoZSBlbGVtZW50cyB3ZSB3YW50XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgdG8gdGhlIHN0YXJ0UG9zdCwgZW5kUG9zdCwgb3IgbGFzdCBlbGVtZW50IGFzIGFwcHJvcHJpYXRlXHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCksIHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCB0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSAmJiBjb3VudCA8IHRoaXMubGltaXRfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIHRoZSBzdGFydCwgc2tpcCB0byB0aGUgbmV4dCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCwgc3RvcCBhZGRpbmcgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgbmV4dC5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc25hcCBjb250YWlucyBsZXNzIHRoYW4gdHdpY2UgdGhlIGxpbWl0LiBGYXN0ZXIgdG8gZGVsZXRlIGZyb20gdGhlIHNuYXAgdGhhbiBidWlsZCB1cCBhIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldFJldmVyc2VJdGVyYXRvcih0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldEl0ZXJhdG9yKHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpblJhbmdlID0gY291bnQgPCB0aGlzLmxpbWl0XyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkRpcmVjdGlvbmFsU3RhcnQobmV4dCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VkRmlsdGVyX1xyXG4gICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgIC51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEluZGV4ZWRGaWx0ZXIoKTtcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIGZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBjaGlsZEtleSwgY2hpbGRTbmFwLCBzb3VyY2UsIGNoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgLy8gVE9ETzogcmVuYW1lIGFsbCBjYWNoZSBzdHVmZiBldGMgdG8gZ2VuZXJhbCBzbmFwIHRlcm1pbm9sb2d5XHJcbiAgICAgICAgbGV0IGNtcDtcclxuICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleENtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcclxuICAgICAgICAgICAgY21wID0gKGEsIGIpID0+IGluZGV4Q21wKGIsIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvbGRFdmVudENhY2hlID0gc25hcDtcclxuICAgICAgICBhc3NlcnQob2xkRXZlbnRDYWNoZS5udW1DaGlsZHJlbigpID09PSB0aGlzLmxpbWl0XywgJycpO1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkTmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICBjb25zdCB3aW5kb3dCb3VuZGFyeSA9IHRoaXMucmV2ZXJzZV9cclxuICAgICAgICAgICAgPyBvbGRFdmVudENhY2hlLmdldEZpcnN0Q2hpbGQodGhpcy5pbmRleF8pXHJcbiAgICAgICAgICAgIDogb2xkRXZlbnRDYWNoZS5nZXRMYXN0Q2hpbGQodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIGNvbnN0IGluUmFuZ2UgPSB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXdDaGlsZE5hbWVkTm9kZSk7XHJcbiAgICAgICAgaWYgKG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkU25hcCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dENoaWxkID0gc291cmNlLmdldENoaWxkQWZ0ZXJDaGlsZCh0aGlzLmluZGV4Xywgd2luZG93Qm91bmRhcnksIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dENoaWxkICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIChuZXh0Q2hpbGQubmFtZSA9PT0gY2hpbGRLZXkgfHwgb2xkRXZlbnRDYWNoZS5oYXNDaGlsZChuZXh0Q2hpbGQubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIHdlaXJkIGVkZ2UgY2FzZSB3aGVyZSBhIG5vZGUgaXMgdXBkYXRlZCBhcyBwYXJ0IG9mIGEgbWVyZ2UgaW4gdGhlIHdyaXRlIHRyZWUsIGJ1dCBoYXNuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGJlZW4gYXBwbGllZCB0byB0aGUgbGltaXRlZCBmaWx0ZXIgeWV0LiBJZ25vcmUgdGhpcyBuZXh0IGNoaWxkIHdoaWNoIHdpbGwgYmUgdXBkYXRlZCBsYXRlciBpblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpbWl0ZWQgZmlsdGVyLi4uXHJcbiAgICAgICAgICAgICAgICBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKHRoaXMuaW5kZXhfLCBuZXh0Q2hpbGQsIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVOZXh0ID0gbmV4dENoaWxkID09IG51bGwgPyAxIDogY21wKG5leHRDaGlsZCwgbmV3Q2hpbGROYW1lZE5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1haW5zSW5XaW5kb3cgPSBpblJhbmdlICYmICFjaGlsZFNuYXAuaXNFbXB0eSgpICYmIGNvbXBhcmVOZXh0ID49IDA7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5zSW5XaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGRLZXksIGNoaWxkU25hcCwgb2xkQ2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGRLZXksIG9sZENoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZEluUmFuZ2UgPSBuZXh0Q2hpbGQgIT0gbnVsbCAmJiB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXh0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZEluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHRDaGlsZC5uYW1lLCBuZXh0Q2hpbGQubm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIHdlJ3JlIGRlbGV0aW5nIGEgbm9kZSwgYnV0IGl0IHdhcyBub3QgaW4gdGhlIHdpbmRvdywgc28gaWdub3JlIGl0XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChjbXAod2luZG93Qm91bmRhcnksIG5ld0NoaWxkTmFtZWROb2RlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKHdpbmRvd0JvdW5kYXJ5Lm5hbWUsIHdpbmRvd0JvdW5kYXJ5Lm5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoY2hpbGRLZXksIGNoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcClcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQod2luZG93Qm91bmRhcnkubmFtZSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyBhbiBpbW11dGFibGUtZnJvbS10aGUtcHVibGljLWFwaSBzdHJ1Y3QgY29udGFpbmluZyBhIHNldCBvZiBxdWVyeSBwYXJhbWV0ZXJzIGRlZmluaW5nIGFcclxuICogcmFuZ2UgdG8gYmUgcmV0dXJuZWQgZm9yIGEgcGFydGljdWxhciBsb2NhdGlvbi4gSXQgaXMgYXNzdW1lZCB0aGF0IHZhbGlkYXRpb24gb2YgcGFyYW1ldGVycyBpcyBkb25lIGF0IHRoZVxyXG4gKiB1c2VyLWZhY2luZyBBUEkgbGV2ZWwsIHNvIGl0IGlzIG5vdCBkb25lIGhlcmUuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUXVlcnlQYXJhbXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdFNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0YXJ0U2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRBZnRlclNldF8gPSBmYWxzZTsgLy8gY2FuIG9ubHkgYmUgdHJ1ZSBpZiBzdGFydFNldF8gaXMgdHJ1ZVxyXG4gICAgICAgIHRoaXMuZW5kU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZEJlZm9yZVNldF8gPSBmYWxzZTsgLy8gY2FuIG9ubHkgYmUgdHJ1ZSBpZiBlbmRTZXRfIGlzIHRydWVcclxuICAgICAgICB0aGlzLmxpbWl0XyA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3RnJvbV8gPSAnJztcclxuICAgICAgICB0aGlzLmluZGV4U3RhcnRWYWx1ZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhTdGFydE5hbWVfID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleEVuZFZhbHVlXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEVuZE5hbWVfID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBQUklPUklUWV9JTkRFWDtcclxuICAgIH1cclxuICAgIGhhc1N0YXJ0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBpdCB3b3VsZCByZXR1cm4gZnJvbSBsZWZ0LlxyXG4gICAgICovXHJcbiAgICBpc1ZpZXdGcm9tTGVmdCgpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3RnJvbV8gPT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIGxpbWl0KCksIHJhdGhlciB0aGFuIGxpbWl0VG9GaXJzdCBvciBsaW1pdFRvTGFzdCB3YXMgY2FsbGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgb25seSBvbmUgb2Ygc3RhcnRTZXRfIGFuZCBlbmRTZXRfIGlzIHRydWUuIFVzZSB0aGVtXHJcbiAgICAgICAgICAgIC8vIHRvIGNhbGN1bGF0ZSB3aGljaCBzaWRlIG9mIHRoZSB2aWV3IHRvIGFuY2hvciB0by4gSWYgbmVpdGhlciBpcyBzZXQsXHJcbiAgICAgICAgICAgIC8vIGFuY2hvciB0byB0aGUgZW5kLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3RnJvbV8gPT09IFwibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc1N0YXJ0KCkgcmV0dXJucyB0cnVlXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4U3RhcnRWYWx1ZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5zdGFydFNldF8sICdPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4U3RhcnROYW1lKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnN0YXJ0U2V0XywgJ09ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTUlOX05BTUU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzRW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4RW5kVmFsdWUoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzRW5kKCkgcmV0dXJucyB0cnVlLlxyXG4gICAgICogUmV0dXJucyB0aGUgZW5kIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4RW5kTmFtZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kTmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhFbmROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfTkFNRTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYSBsaW1pdCBoYXMgYmVlbiBzZXQgYW5kIGl0IGhhcyBiZWVuIGV4cGxpY2l0bHkgYW5jaG9yZWRcclxuICAgICAqL1xyXG4gICAgaGFzQW5jaG9yZWRMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF8gJiYgdGhpcy52aWV3RnJvbV8gIT09ICcnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzTGltaXQoKSByZXR1cm5zIHRydWVcclxuICAgICAqL1xyXG4gICAgZ2V0TGltaXQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMubGltaXRTZXRfLCAnT25seSB2YWxpZCBpZiBsaW1pdCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdF87XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XHJcbiAgICB9XHJcbiAgICBsb2Fkc0FsbERhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuICEodGhpcy5zdGFydFNldF8gfHwgdGhpcy5lbmRTZXRfIHx8IHRoaXMubGltaXRTZXRfKTtcclxuICAgIH1cclxuICAgIGlzRGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2Fkc0FsbERhdGEoKSAmJiB0aGlzLmluZGV4XyA9PT0gUFJJT1JJVFlfSU5ERVg7XHJcbiAgICB9XHJcbiAgICBjb3B5KCkge1xyXG4gICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgUXVlcnlQYXJhbXMoKTtcclxuICAgICAgICBjb3B5LmxpbWl0U2V0XyA9IHRoaXMubGltaXRTZXRfO1xyXG4gICAgICAgIGNvcHkubGltaXRfID0gdGhpcy5saW1pdF87XHJcbiAgICAgICAgY29weS5zdGFydFNldF8gPSB0aGlzLnN0YXJ0U2V0XztcclxuICAgICAgICBjb3B5LnN0YXJ0QWZ0ZXJTZXRfID0gdGhpcy5zdGFydEFmdGVyU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4U3RhcnRWYWx1ZV8gPSB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICAgICAgY29weS5zdGFydE5hbWVTZXRfID0gdGhpcy5zdGFydE5hbWVTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhTdGFydE5hbWVfID0gdGhpcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgY29weS5lbmRTZXRfID0gdGhpcy5lbmRTZXRfO1xyXG4gICAgICAgIGNvcHkuZW5kQmVmb3JlU2V0XyA9IHRoaXMuZW5kQmVmb3JlU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kVmFsdWVfID0gdGhpcy5pbmRleEVuZFZhbHVlXztcclxuICAgICAgICBjb3B5LmVuZE5hbWVTZXRfID0gdGhpcy5lbmROYW1lU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kTmFtZV8gPSB0aGlzLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgY29weS5pbmRleF8gPSB0aGlzLmluZGV4XztcclxuICAgICAgICBjb3B5LnZpZXdGcm9tXyA9IHRoaXMudmlld0Zyb21fO1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zR2V0Tm9kZUZpbHRlcihxdWVyeVBhcmFtcykge1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRmlsdGVyKHF1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocXVlcnlQYXJhbXMuaGFzTGltaXQoKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGltaXRlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QocXVlcnlQYXJhbXMsIG5ld0xpbWl0KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcclxuICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcclxuICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBcImxcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvTGFzdChxdWVyeVBhcmFtcywgbmV3TGltaXQpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xyXG4gICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9IFwiclwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9SSUdIVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEF0KHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5zdGFydFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV8gPSBpbmRleFZhbHVlO1xyXG4gICAgaWYgKGtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgbmV3UGFyYW1zLnN0YXJ0TmFtZVNldF8gPSB0cnVlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEFmdGVyKHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGxldCBwYXJhbXM7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVggfHwgISFrZXkpIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIE1BWF9OQU1FKTtcclxuICAgIH1cclxuICAgIHBhcmFtcy5zdGFydEFmdGVyU2V0XyA9IHRydWU7XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmVuZFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4RW5kVmFsdWVfID0gaW5kZXhWYWx1ZTtcclxuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IHRydWU7XHJcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4RW5kTmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcclxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9ICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0VuZEJlZm9yZShxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KSB7XHJcbiAgICBsZXQgcGFyYW1zO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gS0VZX0lOREVYIHx8ICEha2V5KSB7XHJcbiAgICAgICAgcGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIE1JTl9OQU1FKTtcclxuICAgIH1cclxuICAgIHBhcmFtcy5lbmRCZWZvcmVTZXRfID0gdHJ1ZTtcclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5UGFyYW1zLCBpbmRleCkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmluZGV4XyA9IGluZGV4O1xyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHNldCBvZiBSRVNUIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzIHJlcHJlc2VudGluZyB0aGlzIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNUb1Jlc3RRdWVyeVN0cmluZ1BhcmFtZXRlcnMocXVlcnlQYXJhbXMpIHtcclxuICAgIGNvbnN0IHFzID0ge307XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaXNEZWZhdWx0KCkpIHtcclxuICAgICAgICByZXR1cm4gcXM7XHJcbiAgICB9XHJcbiAgICBsZXQgb3JkZXJCeTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJHByaW9yaXR5XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuUFJJT1JJVFlfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IFZBTFVFX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJHZhbHVlXCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuVkFMVUVfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgIG9yZGVyQnkgPSBcIiRrZXlcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5LRVlfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQocXVlcnlQYXJhbXMuaW5kZXhfIGluc3RhbmNlb2YgUGF0aEluZGV4LCAnVW5yZWNvZ25pemVkIGluZGV4IHR5cGUhJyk7XHJcbiAgICAgICAgb3JkZXJCeSA9IHF1ZXJ5UGFyYW1zLmluZGV4Xy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcXNbXCJvcmRlckJ5XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuT1JERVJfQlkgKi9dID0gc3RyaW5naWZ5KG9yZGVyQnkpO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0U2V0Xykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UGFyYW0gPSBxdWVyeVBhcmFtcy5zdGFydEFmdGVyU2V0X1xyXG4gICAgICAgICAgICA/IFwic3RhcnRBZnRlclwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLlNUQVJUX0FGVEVSICovXHJcbiAgICAgICAgICAgIDogXCJzdGFydEF0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuU1RBUlRfQVQgKi87XHJcbiAgICAgICAgcXNbc3RhcnRQYXJhbV0gPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhTdGFydFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcXNbc3RhcnRQYXJhbV0gKz0gJywnICsgc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnROYW1lXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZFNldF8pIHtcclxuICAgICAgICBjb25zdCBlbmRQYXJhbSA9IHF1ZXJ5UGFyYW1zLmVuZEJlZm9yZVNldF9cclxuICAgICAgICAgICAgPyBcImVuZEJlZm9yZVwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLkVORF9CRUZPUkUgKi9cclxuICAgICAgICAgICAgOiBcImVuZEF0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuRU5EX0FUICovO1xyXG4gICAgICAgIHFzW2VuZFBhcmFtXSA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleEVuZFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIHFzW2VuZFBhcmFtXSArPSAnLCcgKyBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhFbmROYW1lXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxpbWl0U2V0Xykge1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XHJcbiAgICAgICAgICAgIHFzW1wibGltaXRUb0ZpcnN0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuTElNSVRfVE9fRklSU1QgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXNbXCJsaW1pdFRvTGFzdFwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLkxJTUlUX1RPX0xBU1QgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBxcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5zdGFydFNldF8pIHtcclxuICAgICAgICBvYmpbXCJzcFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX1ZBTFVFICovXSA9XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgb2JqW1wic25cIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9OQU1FICovXSA9XHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcInNpblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX0lTX0lOQ0xVU0lWRSAqL10gPVxyXG4gICAgICAgICAgICAhcXVlcnlQYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuZW5kU2V0Xykge1xyXG4gICAgICAgIG9ialtcImVwXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX1ZBTFVFICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5lbmROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBvYmpbXCJlblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9OQU1FICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcImVpblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9JU19JTkNMVVNJVkUgKi9dID1cclxuICAgICAgICAgICAgIXF1ZXJ5UGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubGltaXRTZXRfKSB7XHJcbiAgICAgICAgb2JqW1wibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLkxJTUlUICovXSA9IHF1ZXJ5UGFyYW1zLmxpbWl0XztcclxuICAgICAgICBsZXQgdmlld0Zyb20gPSBxdWVyeVBhcmFtcy52aWV3RnJvbV87XHJcbiAgICAgICAgaWYgKHZpZXdGcm9tID09PSAnJykge1xyXG4gICAgICAgICAgICBpZiAocXVlcnlQYXJhbXMuaXNWaWV3RnJvbUxlZnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBcImxcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gXCJyXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX1JJR0hUICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcInZmXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NICovXSA9IHZpZXdGcm9tO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIG5vdywgcHJpb3JpdHkgaW5kZXggaXMgdGhlIGRlZmF1bHQsIHNvIHdlIG9ubHkgc3BlY2lmeSBpZiBpdCdzIHNvbWUgb3RoZXIgaW5kZXhcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gIT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgb2JqW1wiaVwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4Xy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgU2VydmVyQWN0aW9ucyB0aGF0IGNvbW11bmljYXRlcyB3aXRoIHRoZSBzZXJ2ZXIgdmlhIFJFU1QgcmVxdWVzdHMuXHJcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGNyYXdsZXJzLCB3aGVyZSB3ZSBkb24ndCB3YW50IHRvIHNwaW4gdXAgYSBmdWxsXHJcbiAqIHBlcnNpc3RlbnQgY29ubmVjdGlvbiAodXNpbmcgV2ViU29ja2V0cyBvciBsb25nLXBvbGxpbmcpXHJcbiAqL1xyXG5jbGFzcyBSZWFkb25seVJlc3RDbGllbnQgZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIG9uRGF0YVVwZGF0ZV8gLSBBIGNhbGxiYWNrIGZvciBuZXcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVwb0luZm9fLCBvbkRhdGFVcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyA9IG9uRGF0YVVwZGF0ZV87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfID0gYXBwQ2hlY2tUb2tlblByb3ZpZGVyXztcclxuICAgICAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKC4uLlsqXSl9ICovXHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcigncDpyZXN0OicpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdG8gdHJhY2sgbGlzdGVucywgZXhjZXB0IHRvIHByZXZlbnQgdXMgY2FsbGluZyBhbiBvbkNvbXBsZXRlIGZvciBhIGxpc3RlblxyXG4gICAgICAgICAqIHRoYXQncyBiZWVuIHJlbW92ZWQuIDotL1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGlzdGVuc18gPSB7fTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldExpc3RlbklkXyhxdWVyeSwgdGFnKSB7XHJcbiAgICAgICAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndGFnJCcgKyB0YWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpLCBcInNob3VsZCBoYXZlIGEgdGFnIGlmIGl0J3Mgbm90IGEgZGVmYXVsdCBxdWVyeS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgbGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcik7XHJcbiAgICAgICAgLy8gTWFyayB0aGlzIGxpc3RlbmVyIHNvIHdlIGNhbiB0ZWxsIGlmIGl0J3MgcmVtb3ZlZC5cclxuICAgICAgICBjb25zdCBsaXN0ZW5JZCA9IFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8ocXVlcnksIHRhZyk7XHJcbiAgICAgICAgY29uc3QgdGhpc0xpc3RlbiA9IHt9O1xyXG4gICAgICAgIHRoaXMubGlzdGVuc19bbGlzdGVuSWRdID0gdGhpc0xpc3RlbjtcclxuICAgICAgICBjb25zdCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeS5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMucmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcgKyAnLmpzb24nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8ocGF0aFN0cmluZywgZGF0YSwgLyppc01lcmdlPSovIGZhbHNlLCB0YWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzYWZlR2V0KHRoaXMubGlzdGVuc18sIGxpc3RlbklkKSA9PT0gdGhpc0xpc3Rlbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAnb2snO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT09IDQwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdwZXJtaXNzaW9uX2RlbmllZCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAncmVzdF9lcnJvcjonICsgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHN0YXR1cywgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdW5saXN0ZW4ocXVlcnksIHRhZykge1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF07XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeS5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy5yZXN0UmVxdWVzdF8ocGF0aFN0cmluZyArICcuanNvbicsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhwYXRoU3RyaW5nLCBkYXRhLCBcclxuICAgICAgICAgICAgICAgIC8qaXNNZXJnZT0qLyBmYWxzZSwgXHJcbiAgICAgICAgICAgICAgICAvKnRhZz0qLyBudWxsKTtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICByZWZyZXNoQXV0aFRva2VuKHRva2VuKSB7XHJcbiAgICAgICAgLy8gbm8tb3Agc2luY2Ugd2UganVzdCBhbHdheXMgY2FsbCBnZXRUb2tlbi5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBSRVNUIHJlcXVlc3QgdG8gdGhlIGdpdmVuIHBhdGgsIHdpdGggdGhlIHByb3ZpZGVkIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLFxyXG4gICAgICogYW5kIGFueSBhdXRoIGNyZWRlbnRpYWxzIHdlIGhhdmUuXHJcbiAgICAgKi9cclxuICAgIHJlc3RSZXF1ZXN0XyhwYXRoU3RyaW5nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSB7fSwgY2FsbGJhY2spIHtcclxuICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2Zvcm1hdCddID0gJ2V4cG9ydCc7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8uZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8uZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpXHJcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4uYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYXV0aCddID0gYXV0aFRva2VuLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcHBDaGVja1Rva2VuICYmIGFwcENoZWNrVG9rZW4udG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYWMnXSA9IGFwcENoZWNrVG9rZW4udG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdXJsID0gKHRoaXMucmVwb0luZm9fLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmhvc3QgK1xyXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAnPycgK1xyXG4gICAgICAgICAgICAgICAgJ25zPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18ubmFtZXNwYWNlICtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nKHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2VuZGluZyBSRVNUIHJlcXVlc3QgZm9yICcgKyB1cmwpO1xyXG4gICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnUkVTVCBSZXNwb25zZSBmb3IgJyArIHVybCArICcgcmVjZWl2ZWQuIHN0YXR1czonLCB4aHIuc3RhdHVzLCAncmVzcG9uc2U6JywgeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGpzb25FdmFsKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSBmb3IgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDAxIGFuZCA0MDQgYXJlIGV4cGVjdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gNDAxICYmIHhoci5zdGF0dXMgIT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybignR290IHVuc3VjY2Vzc2Z1bCBSRVNUIHJlc3BvbnNlIGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgU3RhdHVzOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCAvKmFzeW5jaHJvbm91cz0qLyB0cnVlKTtcclxuICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTXV0YWJsZSBvYmplY3Qgd2hpY2ggYmFzaWNhbGx5IGp1c3Qgc3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBcImxhdGVzdFwiIGltbXV0YWJsZSBzbmFwc2hvdC5cclxuICovXHJcbmNsYXNzIFNuYXBzaG90SG9sZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucm9vdE5vZGVfID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBnZXROb2RlKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZV8uZ2V0Q2hpbGQocGF0aCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdTbmFwc2hvdE5vZGUpIHtcclxuICAgICAgICB0aGlzLnJvb3ROb2RlXyA9IHRoaXMucm9vdE5vZGVfLnVwZGF0ZUNoaWxkKHBhdGgsIG5ld1NuYXBzaG90Tm9kZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3U3BhcnNlU25hcHNob3RUcmVlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICBjaGlsZHJlbjogbmV3IE1hcCgpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBTdG9yZXMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZVxyXG4gKiBhdCBhIHNoYWxsb3dlciBwYXRoLCBpdCBtZXJnZXMgdGhlIG5ldyBkYXRhIGludG8gdGhhdCBzbmFwc2hvdCBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXHJcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG5ldyBkYXRhLCBvciBudWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoc3BhcnNlU25hcHNob3RUcmVlLCBwYXRoLCBkYXRhKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBkYXRhO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlLnVwZGF0ZUNoaWxkKHBhdGgsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKCFzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uaGFzKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2V0KGNoaWxkS2V5LCBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmdldChjaGlsZEtleSk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihjaGlsZCwgcGF0aCwgZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFB1cmdlIHRoZSBkYXRhIGF0IHBhdGggZnJvbSB0aGUgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIG5vZGUgc2hvdWxkIG5vdyBiZSByZW1vdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHNwYXJzZVNuYXBzaG90VHJlZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gbnVsbDtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uY2xlYXIoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHRyeWluZyB0byBmb3JnZXQgYSBub2RlIHRoYXQgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCB0cmVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoc3BhcnNlU25hcHNob3RUcmVlLCBuZXcgUGF0aChrZXkpLCB0cmVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChzcGFyc2VTbmFwc2hvdFRyZWUsIHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5zaXplID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5oYXMoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzYWZlVG9SZW1vdmUgPSBzcGFyc2VTbmFwc2hvdFRyZWVGb3JnZXQoc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmdldChjaGlsZEtleSksIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhZmVUb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5kZWxldGUoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2l6ZSA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgb2YgdGhlIHN0b3JlZCB0cmVlIGFuZCBjYWxscyB0aGVcclxuICogY2FsbGJhY2sgb24gZWFjaCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwcmVmaXhQYXRoIC0gUGF0aCB0byBsb29rIHVwIG5vZGUgZm9yLlxyXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlKHNwYXJzZVNuYXBzaG90VHJlZSwgcHJlZml4UGF0aCwgZnVuYykge1xyXG4gICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZ1bmMocHJlZml4UGF0aCwgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hDaGlsZChzcGFyc2VTbmFwc2hvdFRyZWUsIChrZXksIHRyZWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKHByZWZpeFBhdGgudG9TdHJpbmcoKSArICcvJyArIGtleSk7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlKHRyZWUsIHBhdGgsIGZ1bmMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggaW1tZWRpYXRlIGNoaWxkIGFuZCB0cmlnZ2VycyB0aGUgY2FsbGJhY2suXHJcbiAqIE9ubHkgc2VlbXMgdG8gYmUgdXNlZCBpbiB0ZXN0cy5cclxuICpcclxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaENoaWxkKHNwYXJzZVNuYXBzaG90VHJlZSwgZnVuYykge1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmZvckVhY2goKHRyZWUsIGtleSkgPT4ge1xyXG4gICAgICAgIGZ1bmMoa2V5LCB0cmVlKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkZWx0YSBmcm9tIHRoZSBwcmV2aW91cyBjYWxsIHRvIGdldCBzdGF0cy5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb25fIC0gVGhlIGNvbGxlY3Rpb24gdG8gXCJsaXN0ZW5cIiB0by5cclxuICovXHJcbmNsYXNzIFN0YXRzTGlzdGVuZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbl8pIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25fID0gY29sbGVjdGlvbl87XHJcbiAgICAgICAgdGhpcy5sYXN0XyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U3RhdHMgPSB0aGlzLmNvbGxlY3Rpb25fLmdldCgpO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gT2JqZWN0LmFzc2lnbih7fSwgbmV3U3RhdHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RfKSB7XHJcbiAgICAgICAgICAgIGVhY2godGhpcy5sYXN0XywgKHN0YXQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVtzdGF0XSA9IGRlbHRhW3N0YXRdIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RfID0gbmV3U3RhdHM7XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEFzc3VtaW5nIHNvbWUgYXBwcyBtYXkgaGF2ZSBhIHNob3J0IGFtb3VudCBvZiB0aW1lIG9uIHBhZ2UsIGFuZCBhIGJ1bGsgb2YgZmlyZWJhc2Ugb3BlcmF0aW9ucyBwcm9iYWJseVxyXG4vLyBoYXBwZW4gb24gcGFnZSBsb2FkLCB3ZSB0cnkgdG8gcmVwb3J0IG91ciBmaXJzdCBzZXQgb2Ygc3RhdHMgcHJldHR5IHF1aWNrbHksIGJ1dCB3ZSB3YWl0IGF0IGxlYXN0IDEwXHJcbi8vIHNlY29uZHMgdG8gdHJ5IHRvIGVuc3VyZSB0aGUgRmlyZWJhc2UgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCAvIHNldHRsZWQuXHJcbmNvbnN0IEZJUlNUX1NUQVRTX01JTl9USU1FID0gMTAgKiAxMDAwO1xyXG5jb25zdCBGSVJTVF9TVEFUU19NQVhfVElNRSA9IDMwICogMTAwMDtcclxuLy8gV2UnbGwgY29udGludWUgdG8gcmVwb3J0IHN0YXRzIG9uIGF2ZXJhZ2UgZXZlcnkgNSBtaW51dGVzLlxyXG5jb25zdCBSRVBPUlRfU1RBVFNfSU5URVJWQUwgPSA1ICogNjAgKiAxMDAwO1xyXG5jbGFzcyBTdGF0c1JlcG9ydGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIHNlcnZlcl8pIHtcclxuICAgICAgICB0aGlzLnNlcnZlcl8gPSBzZXJ2ZXJfO1xyXG4gICAgICAgIHRoaXMuc3RhdHNUb1JlcG9ydF8gPSB7fTtcclxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbmV3IFN0YXRzTGlzdGVuZXIoY29sbGVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IEZJUlNUX1NUQVRTX01JTl9USU1FICtcclxuICAgICAgICAgICAgKEZJUlNUX1NUQVRTX01BWF9USU1FIC0gRklSU1RfU1RBVFNfTUlOX1RJTUUpICogTWF0aC5yYW5kb20oKTtcclxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcodGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XHJcbiAgICB9XHJcbiAgICByZXBvcnRTdGF0c18oKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzTGlzdGVuZXJfLmdldCgpO1xyXG4gICAgICAgIGNvbnN0IHJlcG9ydGVkU3RhdHMgPSB7fTtcclxuICAgICAgICBsZXQgaGF2ZVN0YXRzVG9SZXBvcnQgPSBmYWxzZTtcclxuICAgICAgICBlYWNoKHN0YXRzLCAoc3RhdCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gMCAmJiBjb250YWlucyh0aGlzLnN0YXRzVG9SZXBvcnRfLCBzdGF0KSkge1xyXG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRTdGF0c1tzdGF0XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaGF2ZVN0YXRzVG9SZXBvcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGhhdmVTdGF0c1RvUmVwb3J0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyXy5yZXBvcnRTdGF0cyhyZXBvcnRlZFN0YXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcXVldWUgb3VyIG5leHQgcnVuLlxyXG4gICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyh0aGlzLnJlcG9ydFN0YXRzXy5iaW5kKHRoaXMpLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyICogUkVQT1JUX1NUQVRTX0lOVEVSVkFMKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqXHJcbiAqIEBlbnVtXHJcbiAqL1xyXG52YXIgT3BlcmF0aW9uVHlwZTtcclxuKGZ1bmN0aW9uIChPcGVyYXRpb25UeXBlKSB7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJPVkVSV1JJVEVcIl0gPSAwXSA9IFwiT1ZFUldSSVRFXCI7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJNRVJHRVwiXSA9IDFdID0gXCJNRVJHRVwiO1xyXG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiQUNLX1VTRVJfV1JJVEVcIl0gPSAyXSA9IFwiQUNLX1VTRVJfV1JJVEVcIjtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIkxJU1RFTl9DT01QTEVURVwiXSA9IDNdID0gXCJMSVNURU5fQ09NUExFVEVcIjtcclxufSkoT3BlcmF0aW9uVHlwZSB8fCAoT3BlcmF0aW9uVHlwZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIG5ld09wZXJhdGlvblNvdXJjZVVzZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiB0cnVlLFxyXG4gICAgICAgIGZyb21TZXJ2ZXI6IGZhbHNlLFxyXG4gICAgICAgIHF1ZXJ5SWQ6IG51bGwsXHJcbiAgICAgICAgdGFnZ2VkOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiBmYWxzZSxcclxuICAgICAgICBmcm9tU2VydmVyOiB0cnVlLFxyXG4gICAgICAgIHF1ZXJ5SWQ6IG51bGwsXHJcbiAgICAgICAgdGFnZ2VkOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiBmYWxzZSxcclxuICAgICAgICBmcm9tU2VydmVyOiB0cnVlLFxyXG4gICAgICAgIHF1ZXJ5SWQsXHJcbiAgICAgICAgdGFnZ2VkOiB0cnVlXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEFja1VzZXJXcml0ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhZmZlY3RlZFRyZWUgLSBBIHRyZWUgY29udGFpbmluZyB0cnVlIGZvciBlYWNoIGFmZmVjdGVkIHBhdGguIEFmZmVjdGVkIHBhdGhzIGNhbid0IG92ZXJsYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIHBhdGgsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIGFmZmVjdGVkVHJlZSwgXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gcmV2ZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZTtcclxuICAgICAgICB0aGlzLnJldmVydCA9IHJldmVydDtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gbmV3T3BlcmF0aW9uU291cmNlVXNlcigpO1xyXG4gICAgfVxyXG4gICAgb3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKCFwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGFzc2VydChwYXRoR2V0RnJvbnQodGhpcy5wYXRoKSA9PT0gY2hpbGROYW1lLCAnb3BlcmF0aW9uRm9yQ2hpbGQgY2FsbGVkIGZvciB1bnJlbGF0ZWQgY2hpbGQuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWNrVXNlcldyaXRlKHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpLCB0aGlzLmFmZmVjdGVkVHJlZSwgdGhpcy5yZXZlcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmFmZmVjdGVkVHJlZS5jaGlsZHJlbi5pc0VtcHR5KCksICdhZmZlY3RlZFRyZWUgc2hvdWxkIG5vdCBoYXZlIG92ZXJsYXBwaW5nIGFmZmVjdGVkIHBhdGhzLicpO1xyXG4gICAgICAgICAgICAvLyBBbGwgY2hpbGQgbG9jYXRpb25zIGFyZSBhZmZlY3RlZCBhcyB3ZWxsOyBqdXN0IHJldHVybiBzYW1lIG9wZXJhdGlvbi5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmFmZmVjdGVkVHJlZS5zdWJ0cmVlKG5ldyBQYXRoKGNoaWxkTmFtZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFja1VzZXJXcml0ZShuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlLCB0aGlzLnJldmVydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIExpc3RlbkNvbXBsZXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcGF0aCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEU7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE92ZXJ3cml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHBhdGgsIHNuYXApIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEU7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE92ZXJ3cml0ZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIHRoaXMuc25hcC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5zbmFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWVyZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gc291cmNlLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBwYXRoLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBjaGlsZHJlbikge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuTUVSR0U7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFBhdGgoY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIHVuYWZmZWN0ZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNuYXBzaG90IGZvciB0aGUgY2hpbGQgaW4gcXVlc3Rpb24uICBUaGlzIGJlY29tZXMgYW4gb3ZlcndyaXRlIG9mIHRoZSBjaGlsZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZSBhdCBhIGRlZXBlciBsZXZlbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIGNoaWxkVHJlZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChwYXRoR2V0RnJvbnQodGhpcy5wYXRoKSA9PT0gY2hpbGROYW1lLCBcIkNhbid0IGdldCBhIG1lcmdlIGZvciBhIGNoaWxkIG5vdCBvbiB0aGUgcGF0aCBvZiB0aGUgb3BlcmF0aW9uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgnT3BlcmF0aW9uKCcgK1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggK1xyXG4gICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcgbWVyZ2U6ICcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG5vZGUgb25seSBzdG9yZXMgY29tcGxldGUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSBpdCBob2xkcyBhIGZsYWcgd2hldGhlciB0aGUgbm9kZSBjYW4gYmUgY29uc2lkZXJlZCBmdWxseVxyXG4gKiBpbml0aWFsaXplZCBpbiB0aGUgc2Vuc2UgdGhhdCB3ZSBrbm93IGF0IG9uZSBwb2ludCBpbiB0aW1lIHRoaXMgcmVwcmVzZW50ZWQgYSB2YWxpZCBzdGF0ZSBvZiB0aGUgd29ybGQsIGUuZy5cclxuICogaW5pdGlhbGl6ZWQgd2l0aCBkYXRhIGZyb20gdGhlIHNlcnZlciwgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudC4gVGhlIGZpbHRlcmVkIGZsYWcgYWxzbyB0cmFja3NcclxuICogd2hldGhlciBhIG5vZGUgcG90ZW50aWFsbHkgaGFkIGNoaWxkcmVuIHJlbW92ZWQgZHVlIHRvIGEgZmlsdGVyLlxyXG4gKi9cclxuY2xhc3MgQ2FjaGVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGVfLCBmdWxseUluaXRpYWxpemVkXywgZmlsdGVyZWRfKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlXyA9IG5vZGVfO1xyXG4gICAgICAgIHRoaXMuZnVsbHlJbml0aWFsaXplZF8gPSBmdWxseUluaXRpYWxpemVkXztcclxuICAgICAgICB0aGlzLmZpbHRlcmVkXyA9IGZpbHRlcmVkXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSB3YXMgZnVsbHkgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgc2VydmVyIGRhdGEgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudFxyXG4gICAgICovXHJcbiAgICBpc0Z1bGx5SW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVsbHlJbml0aWFsaXplZF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgaXMgcG90ZW50aWFsbHkgbWlzc2luZyBjaGlsZHJlbiBkdWUgdG8gYSBmaWx0ZXIgYXBwbGllZCB0byB0aGUgbm9kZVxyXG4gICAgICovXHJcbiAgICBpc0ZpbHRlcmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkXztcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGVGb3JQYXRoKHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZUZvckNoaWxkKGtleSkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfKSB8fCB0aGlzLm5vZGVfLmhhc0NoaWxkKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gRXZlbnRHZW5lcmF0b3IgaXMgdXNlZCB0byBjb252ZXJ0IFwicmF3XCIgY2hhbmdlcyAoQ2hhbmdlKSBhcyBjb21wdXRlZCBieSB0aGVcclxuICogQ2FjaGVEaWZmZXIgaW50byBhY3R1YWwgZXZlbnRzIChFdmVudCkgdGhhdCBjYW4gYmUgcmFpc2VkLiAgU2VlIGdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcygpXHJcbiAqIGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRXZlbnRHZW5lcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocXVlcnlfKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeV8gPSBxdWVyeV87XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSB0aGlzLnF1ZXJ5Xy5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBzZXQgb2YgcmF3IGNoYW5nZXMgKG5vIG1vdmVkIGV2ZW50cyBhbmQgcHJldk5hbWUgbm90IHNwZWNpZmllZCB5ZXQpLCBhbmQgYSBzZXQgb2ZcclxuICogRXZlbnRSZWdpc3RyYXRpb25zIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHRoZXNlIGNoYW5nZXMsIGdlbmVyYXRlIHRoZSBhY3R1YWwgZXZlbnRzIHRvIGJlIHJhaXNlZC5cclxuICpcclxuICogTm90ZXM6XHJcbiAqICAtIGNoaWxkX21vdmVkIGV2ZW50cyB3aWxsIGJlIHN5bnRoZXNpemVkIGF0IHRoaXMgdGltZSBmb3IgYW55IGNoaWxkX2NoYW5nZWQgZXZlbnRzIHRoYXQgYWZmZWN0XHJcbiAqICAgIG91ciBpbmRleC5cclxuICogIC0gcHJldk5hbWUgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBpbmRleCBvcmRlcmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKGV2ZW50R2VuZXJhdG9yLCBjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbnMpIHtcclxuICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xyXG4gICAgY29uc3QgbW92ZXMgPSBbXTtcclxuICAgIGNoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xyXG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgIGV2ZW50R2VuZXJhdG9yLmluZGV4Xy5pbmRleGVkVmFsdWVDaGFuZ2VkKGNoYW5nZS5vbGRTbmFwLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSkge1xyXG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGNoYW5nZUNoaWxkTW92ZWQoY2hhbmdlLmNoaWxkTmFtZSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovLCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX21vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9NT1ZFRCAqLywgbW92ZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcInZhbHVlXCIgLyogQ2hhbmdlVHlwZS5WQUxVRSAqLywgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIHJldHVybiBldmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGNoYW5nZXMgb2YgYSBzaW5nbGUgY2hhbmdlIHR5cGUsIGdlbmVyYXRlIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIGV2ZW50VHlwZSwgY2hhbmdlcywgcmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSkge1xyXG4gICAgY29uc3QgZmlsdGVyZWRDaGFuZ2VzID0gY2hhbmdlcy5maWx0ZXIoY2hhbmdlID0+IGNoYW5nZS50eXBlID09PSBldmVudFR5cGUpO1xyXG4gICAgZmlsdGVyZWRDaGFuZ2VzLnNvcnQoKGEsIGIpID0+IGV2ZW50R2VuZXJhdG9yQ29tcGFyZUNoYW5nZXMoZXZlbnRHZW5lcmF0b3IsIGEsIGIpKTtcclxuICAgIGZpbHRlcmVkQ2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxpemVkQ2hhbmdlID0gZXZlbnRHZW5lcmF0b3JNYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZShldmVudEdlbmVyYXRvciwgY2hhbmdlLCBldmVudENhY2hlKTtcclxuICAgICAgICByZWdpc3RyYXRpb25zLmZvckVhY2gocmVnaXN0cmF0aW9uID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5yZXNwb25kc1RvKGNoYW5nZS50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2gocmVnaXN0cmF0aW9uLmNyZWF0ZUV2ZW50KG1hdGVyaWFsaXplZENoYW5nZSwgZXZlbnRHZW5lcmF0b3IucXVlcnlfKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yTWF0ZXJpYWxpemVTaW5nbGVDaGFuZ2UoZXZlbnRHZW5lcmF0b3IsIGNoYW5nZSwgZXZlbnRDYWNoZSkge1xyXG4gICAgaWYgKGNoYW5nZS50eXBlID09PSAndmFsdWUnIHx8IGNoYW5nZS50eXBlID09PSAnY2hpbGRfcmVtb3ZlZCcpIHtcclxuICAgICAgICByZXR1cm4gY2hhbmdlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hhbmdlLnByZXZOYW1lID0gZXZlbnRDYWNoZS5nZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBldmVudEdlbmVyYXRvci5pbmRleF8pO1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JDb21wYXJlQ2hhbmdlcyhldmVudEdlbmVyYXRvciwgYSwgYikge1xyXG4gICAgaWYgKGEuY2hpbGROYW1lID09IG51bGwgfHwgYi5jaGlsZE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdTaG91bGQgb25seSBjb21wYXJlIGNoaWxkXyBldmVudHMuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhV3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoYS5jaGlsZE5hbWUsIGEuc25hcHNob3ROb2RlKTtcclxuICAgIGNvbnN0IGJXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShiLmNoaWxkTmFtZSwgYi5zbmFwc2hvdE5vZGUpO1xyXG4gICAgcmV0dXJuIGV2ZW50R2VuZXJhdG9yLmluZGV4Xy5jb21wYXJlKGFXcmFwcGVkLCBiV3JhcHBlZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3Vmlld0NhY2hlKGV2ZW50Q2FjaGUsIHNlcnZlckNhY2hlKSB7XHJcbiAgICByZXR1cm4geyBldmVudENhY2hlLCBzZXJ2ZXJDYWNoZSB9O1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIGV2ZW50U25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSB7XHJcbiAgICByZXR1cm4gbmV3Vmlld0NhY2hlKG5ldyBDYWNoZU5vZGUoZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpLCB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAodmlld0NhY2hlLCBzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcclxuICAgIHJldHVybiBuZXdWaWV3Q2FjaGUodmlld0NhY2hlLmV2ZW50Q2FjaGUsIG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAodmlld0NhY2hlKSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLmV2ZW50Q2FjaGUuaXNGdWxseUluaXRpYWxpemVkKClcclxuICAgICAgICA/IHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKVxyXG4gICAgICAgIDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpXHJcbiAgICAgICAgPyB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpXHJcbiAgICAgICAgOiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBlbXB0eUNoaWxkcmVuU2luZ2xldG9uO1xyXG4vKipcclxuICogU2luZ2xldG9uIGVtcHR5IGNoaWxkcmVuIGNvbGxlY3Rpb24uXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBFbXB0eUNoaWxkcmVuID0gKCkgPT4ge1xyXG4gICAgaWYgKCFlbXB0eUNoaWxkcmVuU2luZ2xldG9uKSB7XHJcbiAgICAgICAgZW1wdHlDaGlsZHJlblNpbmdsZXRvbiA9IG5ldyBTb3J0ZWRNYXAoc3RyaW5nQ29tcGFyZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW1wdHlDaGlsZHJlblNpbmdsZXRvbjtcclxufTtcclxuLyoqXHJcbiAqIEEgdHJlZSB3aXRoIGltbXV0YWJsZSBlbGVtZW50cy5cclxuICovXHJcbmNsYXNzIEltbXV0YWJsZVRyZWUge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUsIGNoaWxkcmVuID0gRW1wdHlDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xyXG4gICAgICAgIGxldCB0cmVlID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgZWFjaChvYmosIChjaGlsZFBhdGgsIGNoaWxkU25hcCkgPT4ge1xyXG4gICAgICAgICAgICB0cmVlID0gdHJlZS5zZXQobmV3IFBhdGgoY2hpbGRQYXRoKSwgY2hpbGRTbmFwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZW1wdHkgYW5kIHRoZXJlIGFyZSBubyBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBudWxsICYmIHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHBhdGggYW5kIHByZWRpY2F0ZSwgcmV0dXJuIHRoZSBmaXJzdCBub2RlIGFuZCB0aGUgcGF0aCB0byB0aGF0IG5vZGVcclxuICAgICAqIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIFRPRE8gRG8gYSBwZXJmIHRlc3QgLS0gSWYgd2UncmUgY3JlYXRpbmcgYSBidW5jaCBvZiBge3BhdGg6IHZhbHVlOn1gXHJcbiAgICAgKiBvYmplY3RzIG9uIHRoZSB3YXkgYmFjayBvdXQsIGl0IG1heSBiZSBiZXR0ZXIgdG8gcGFzcyBkb3duIGEgcGF0aFNvRmFyIG9iai5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gVGhlIHJlbWFpbmRlciBvZiB0aGUgcGF0aFxyXG4gICAgICogQHBhcmFtIHByZWRpY2F0ZSAtIFRoZSBwcmVkaWNhdGUgdG8gc2F0aXNmeSB0byByZXR1cm4gYSBub2RlXHJcbiAgICAgKi9cclxuICAgIGZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlKHJlbGF0aXZlUGF0aCwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT0gbnVsbCAmJiBwcmVkaWNhdGUodGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogbmV3RW1wdHlQYXRoKCksIHZhbHVlOiB0aGlzLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlID0gY2hpbGQuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCksIHByZWRpY2F0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhDaGlsZChuZXcgUGF0aChmcm9udCksIGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGZ1bGxQYXRoLCB2YWx1ZTogY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS52YWx1ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQsIGlmIGl0IGV4aXN0cywgdGhlIHNob3J0ZXN0IHN1YnBhdGggb2YgdGhlIGdpdmVuIHBhdGggdGhhdCBwb2ludHMgYSBkZWZpbmVkXHJcbiAgICAgKiB2YWx1ZSBpbiB0aGUgdHJlZVxyXG4gICAgICovXHJcbiAgICBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLCAoKSA9PiB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHN1YnRyZWUgYXQgdGhlIGdpdmVuIHBhdGhcclxuICAgICAqL1xyXG4gICAgc3VidHJlZShyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVHJlZS5zdWJ0cmVlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byBzZXQgdmFsdWUgYXQuXHJcbiAgICAgKiBAcGFyYW0gdG9TZXQgLSBWYWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgc2V0KHJlbGF0aXZlUGF0aCwgdG9TZXQpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodG9TZXQsIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0KHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpLCB0b1NldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byB2YWx1ZSB0byByZW1vdmUuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwsIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkLnJlbW92ZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCAmJiBuZXdDaGlsZHJlbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0cmVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIGdldCB2YWx1ZSBmb3IuXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCBwYXRoLCBvciBudWxsLlxyXG4gICAgICovXHJcbiAgICBnZXQocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZ2V0KHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIHRoZSBzdWJ0cmVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIHRoZSBnaXZlbiBuZXcgdHJlZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byByZXBsYWNlIHN1YnRyZWUgZm9yLlxyXG4gICAgICogQHBhcmFtIG5ld1RyZWUgLSBOZXcgdHJlZS5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdGluZyB0cmVlLlxyXG4gICAgICovXHJcbiAgICBzZXRUcmVlKHJlbGF0aXZlUGF0aCwgbmV3VHJlZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdUcmVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0VHJlZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSwgbmV3VHJlZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgZGVwdGggZmlyc3QgZm9sZCBvbiB0aGlzIHRyZWUuIFRyYW5zZm9ybXMgYSB0cmVlIGludG8gYSBzaW5nbGVcclxuICAgICAqIHZhbHVlLCBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgb3BlcmF0ZXMgb24gdGhlIHBhdGggdG8gYSBub2RlLCBhbiBvcHRpb25hbFxyXG4gICAgICogY3VycmVudCB2YWx1ZSwgYW5kIGEgbWFwIG9mIGNoaWxkIG5hbWVzIHRvIGZvbGRlZCBzdWJ0cmVlc1xyXG4gICAgICovXHJcbiAgICBmb2xkKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZF8obmV3RW1wdHlQYXRoKCksIGZuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlIGhlbHBlciBmb3IgcHVibGljLWZhY2luZyBmb2xkKCkgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIGZvbGRfKHBhdGhTb0ZhciwgZm4pIHtcclxuICAgICAgICBjb25zdCBhY2N1bSA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bVtjaGlsZEtleV0gPSBjaGlsZFRyZWUuZm9sZF8ocGF0aENoaWxkKHBhdGhTb0ZhciwgY2hpbGRLZXkpLCBmbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZuKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSwgYWNjdW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyB2YWx1ZSBvbiB0aGUgZ2l2ZW4gcGF0aC4gUmV0dXJuIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgZiB0byBpdC5cclxuICAgICAqL1xyXG4gICAgZmluZE9uUGF0aChwYXRoLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZE9uUGF0aF8ocGF0aCwgbmV3RW1wdHlQYXRoKCksIGYpO1xyXG4gICAgfVxyXG4gICAgZmluZE9uUGF0aF8ocGF0aFRvRm9sbG93LCBwYXRoU29GYXIsIGYpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlID8gZihwYXRoU29GYXIsIHRoaXMudmFsdWUpIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGhUb0ZvbGxvdykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aFRvRm9sbG93KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENoaWxkLmZpbmRPblBhdGhfKHBhdGhQb3BGcm9udChwYXRoVG9Gb2xsb3cpLCBwYXRoQ2hpbGQocGF0aFNvRmFyLCBmcm9udCksIGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoT25QYXRoKHBhdGgsIGYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JlYWNoT25QYXRoXyhwYXRoLCBuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoT25QYXRoXyhwYXRoVG9Gb2xsb3csIGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aFRvRm9sbG93KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBmKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGhUb0ZvbGxvdyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaGlsZC5mb3JlYWNoT25QYXRoXyhwYXRoUG9wRnJvbnQocGF0aFRvRm9sbG93KSwgcGF0aENoaWxkKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGZyb250KSwgZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBub2RlIGluIHRoZSB0cmVlIHRoYXQgaGFzIGEgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGYgLSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUgdG9cclxuICAgICAqIGEgbm9kZSwgYW5kIHRoZSB2YWx1ZSBhdCB0aGF0IG5vZGUuIENhbGxlZCBpbiBkZXB0aC1maXJzdCBvcmRlci5cclxuICAgICAqL1xyXG4gICAgZm9yZWFjaChmKSB7XHJcbiAgICAgICAgdGhpcy5mb3JlYWNoXyhuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoXyhjdXJyZW50UmVsYXRpdmVQYXRoLCBmKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZE5hbWUsIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBjaGlsZFRyZWUuZm9yZWFjaF8ocGF0aENoaWxkKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGNoaWxkTmFtZSksIGYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGYoY3VycmVudFJlbGF0aXZlUGF0aCwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yZWFjaENoaWxkKGYpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGYoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIHdyaXRlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIG5vZGVzIGluIHVuaXNvbi4gSXQgYWJzdHJhY3RzIGF3YXkgdGhlIGxvZ2ljIHdpdGhcclxuICogZGVhbGluZyB3aXRoIHByaW9yaXR5IHdyaXRlcyBhbmQgbXVsdGlwbGUgbmVzdGVkIHdyaXRlcy4gQXQgYW55IGdpdmVuIHBhdGggdGhlcmUgaXMgb25seSBhbGxvd2VkIHRvIGJlIG9uZSB3cml0ZVxyXG4gKiBtb2RpZnlpbmcgdGhhdCBwYXRoLiBBbnkgd3JpdGUgdG8gYW4gZXhpc3RpbmcgcGF0aCBvciBzaGFkb3dpbmcgYW4gZXhpc3RpbmcgcGF0aCB3aWxsIG1vZGlmeSB0aGF0IGV4aXN0aW5nIHdyaXRlXHJcbiAqIHRvIHJlZmxlY3QgdGhlIHdyaXRlIGFkZGVkLlxyXG4gKi9cclxuY2xhc3MgQ29tcG91bmRXcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZVRyZWVfKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVRyZWVfID0gd3JpdGVUcmVlXztcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUobnVsbCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCBwYXRoLCBub2RlKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUobm9kZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgcm9vdG1vc3QgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHBhdGgpO1xyXG4gICAgICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvb3RNb3N0UGF0aCA9IHJvb3Rtb3N0LnBhdGg7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJvb3Rtb3N0LnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocm9vdE1vc3RQYXRoLCBwYXRoKTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUoY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnNldChyb290TW9zdFBhdGgsIHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJ0cmVlID0gbmV3IEltbXV0YWJsZVRyZWUobm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1dyaXRlVHJlZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zZXRUcmVlKHBhdGgsIHN1YnRyZWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3V3JpdGVUcmVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCBwYXRoLCB1cGRhdGVzKSB7XHJcbiAgICBsZXQgbmV3V3JpdGUgPSBjb21wb3VuZFdyaXRlO1xyXG4gICAgZWFjaCh1cGRhdGVzLCAoY2hpbGRLZXksIG5vZGUpID0+IHtcclxuICAgICAgICBuZXdXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShuZXdXcml0ZSwgcGF0aENoaWxkKHBhdGgsIGNoaWxkS2V5KSwgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdXcml0ZTtcclxufVxyXG4vKipcclxuICogV2lsbCByZW1vdmUgYSB3cml0ZSBhdCB0aGUgZ2l2ZW4gcGF0aCBhbmQgZGVlcGVyIHBhdGhzLiBUaGlzIHdpbGwgPGVtPm5vdDwvZW0+IG1vZGlmeSBhIHdyaXRlIGF0IGEgaGlnaGVyXHJcbiAqIGxvY2F0aW9uLCB3aGljaCBtdXN0IGJlIHJlbW92ZWQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIHRoYXQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byByZW1vdmUuXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYXQgd2hpY2ggYSB3cml0ZSBhbmQgYWxsIGRlZXBlciB3cml0ZXMgc2hvdWxkIGJlIHJlbW92ZWRcclxuICogQHJldHVybnMgVGhlIG5ldyBDb21wb3VuZFdyaXRlIHdpdGggdGhlIHJlbW92ZWQgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBDb21wb3VuZFdyaXRlLmVtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuZXdXcml0ZVRyZWUgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uc2V0VHJlZShwYXRoLCBuZXcgSW1tdXRhYmxlVHJlZShudWxsKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgd2lsbCBmdWxseSBvdmVyd3JpdGUgYSBub2RlIGF0IGEgZ2l2ZW4gbG9jYXRpb24gYW5kIGNhbiB0aGVyZWZvcmUgYmVcclxuICogY29uc2lkZXJlZCBcImNvbXBsZXRlXCIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY2hlY2sgZm9yXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlcmUgaXMgYSBjb21wbGV0ZSB3cml0ZSBhdCB0aGF0IHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIHJldHVybiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpICE9IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGZvciBhIHBhdGggaWYgYW5kIG9ubHkgaWYgdGhlIG5vZGUgaXMgYSBcImNvbXBsZXRlXCIgb3ZlcndyaXRlIGF0IHRoYXQgcGF0aC4gVGhpcyB3aWxsIG5vdCBhZ2dyZWdhdGVcclxuICogd3JpdGVzIGZyb20gZGVlcGVyIHBhdGhzLCBidXQgd2lsbCByZXR1cm4gY2hpbGQgbm9kZXMgZnJvbSBhIG1vcmUgc2hhbGxvdyBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG91bmRXcml0ZSAtIFRoZSBDb21wb3VuZFdyaXRlIHRvIGdldCB0aGUgbm9kZSBmcm9tLlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGdldCBhIGNvbXBsZXRlIHdyaXRlXHJcbiAqIEByZXR1cm5zIFRoZSBub2RlIGlmIGNvbXBsZXRlIGF0IHRoYXQgcGF0aCwgb3IgbnVsbCBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGNvbnN0IHJvb3Rtb3N0ID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcclxuICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlX1xyXG4gICAgICAgICAgICAuZ2V0KHJvb3Rtb3N0LnBhdGgpXHJcbiAgICAgICAgICAgIC5nZXRDaGlsZChuZXdSZWxhdGl2ZVBhdGgocm9vdG1vc3QucGF0aCwgcGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYWxsIGNoaWxkcmVuIHRoYXQgYXJlIGd1YXJhbnRlZWQgdG8gYmUgYSBjb21wbGV0ZSBvdmVyd3JpdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gZ2V0IGNoaWxkcmVuIGZyb20uXHJcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBhbGwgY29tcGxldGUgY2hpbGRyZW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihjb21wb3VuZFdyaXRlKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy52YWx1ZTtcclxuICAgIGlmIChub2RlICE9IG51bGwpIHtcclxuICAgICAgICAvLyBJZiBpdCdzIGEgbGVhZiBub2RlLCBpdCBoYXMgbm8gY2hpbGRyZW47IHNvIG5vdGhpbmcgdG8gZG8uXHJcbiAgICAgICAgaWYgKCFub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICBub2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGRUcmVlLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUoY29tcG91bmRXcml0ZSwgcGF0aCk7XHJcbiAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUoc2hhZG93aW5nTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zdWJ0cmVlKHBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIENvbXBvdW5kV3JpdGUgaXMgZW1wdHkgYW5kIHRoZXJlZm9yZSBkb2VzIG5vdCBtb2RpZnkgYW55IG5vZGVzLlxyXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgQ29tcG91bmRXcml0ZSBpcyBlbXB0eVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUlzRW1wdHkoY29tcG91bmRXcml0ZSkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5pc0VtcHR5KCk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhpcyBDb21wb3VuZFdyaXRlIHRvIGEgbm9kZS4gVGhlIG5vZGUgaXMgcmV0dXJuZWQgd2l0aCBhbGwgd3JpdGVzIGZyb20gdGhpcyBDb21wb3VuZFdyaXRlIGFwcGxpZWQgdG8gdGhlXHJcbiAqIG5vZGVcclxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBhcHBseSB0aGlzIENvbXBvdW5kV3JpdGUgdG9cclxuICogQHJldHVybnMgVGhlIG5vZGUgd2l0aCBhbGwgd3JpdGVzIGFwcGxpZWRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBcHBseShjb21wb3VuZFdyaXRlLCBub2RlKSB7XHJcbiAgICByZXR1cm4gYXBwbHlTdWJ0cmVlV3JpdGUobmV3RW1wdHlQYXRoKCksIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXywgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlTdWJ0cmVlV3JpdGUocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUsIG5vZGUpIHtcclxuICAgIGlmICh3cml0ZVRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGEgd3JpdGUgaXMgYWx3YXlzIGEgbGVhZiwgd2UncmUgZG9uZSBoZXJlXHJcbiAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHByaW9yaXR5V3JpdGUgPSBudWxsO1xyXG4gICAgICAgIHdyaXRlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHByaW9yaXRpZXMgYXQgdGhlIGVuZCBzbyB3ZSBkb24ndCB1cGRhdGUgcHJpb3JpdGllcyBmb3IgZWl0aGVyIGVtcHR5IG5vZGVzIG9yIGZvcmdldFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gYXBwbHkgcHJpb3JpdGllcyB0byBlbXB0eSBub2RlcyB0aGF0IGFyZSBsYXRlciBmaWxsZWRcclxuICAgICAgICAgICAgICAgIGFzc2VydChjaGlsZFRyZWUudmFsdWUgIT09IG51bGwsICdQcmlvcml0eSB3cml0ZXMgbXVzdCBhbHdheXMgYmUgbGVhZiBub2RlcycpO1xyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlXcml0ZSA9IGNoaWxkVHJlZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBhcHBseVN1YnRyZWVXcml0ZShwYXRoQ2hpbGQocmVsYXRpdmVQYXRoLCBjaGlsZEtleSksIGNoaWxkVHJlZSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmlvcml0eSB3cml0ZSwgd2Ugb25seSBhcHBseSBpdCBpZiB0aGUgbm9kZSBpcyBub3QgZW1wdHlcclxuICAgICAgICBpZiAoIW5vZGUuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKS5pc0VtcHR5KCkgJiYgcHJpb3JpdHlXcml0ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChwYXRoQ2hpbGQocmVsYXRpdmVQYXRoLCAnLnByaW9yaXR5JyksIHByaW9yaXR5V3JpdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFdyaXRlVHJlZVJlZiBmb3IgdGhlIGdpdmVuIHBhdGguIEZvciB1c2Ugd2l0aCBhIG5ldyBzeW5jIHBvaW50IGF0IHRoZSBnaXZlbiBwYXRoLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2hpbGRXcml0ZXMod3JpdGVUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3V3JpdGVUcmVlUmVmKHBhdGgsIHdyaXRlVHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY29yZCBhIG5ldyBvdmVyd3JpdGUgZnJvbSB1c2VyIGNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2aXNpYmxlIC0gVGhpcyBpcyBzZXQgdG8gZmFsc2UgYnkgc29tZSB0cmFuc2FjdGlvbnMuIEl0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIGV2ZW50IGNhY2hlc1xyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQWRkT3ZlcndyaXRlKHdyaXRlVHJlZSwgcGF0aCwgc25hcCwgd3JpdGVJZCwgdmlzaWJsZSkge1xyXG4gICAgYXNzZXJ0KHdyaXRlSWQgPiB3cml0ZVRyZWUubGFzdFdyaXRlSWQsICdTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lcycpO1xyXG4gICAgaWYgKHZpc2libGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcmVlLmFsbFdyaXRlcy5wdXNoKHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHNuYXAsXHJcbiAgICAgICAgd3JpdGVJZCxcclxuICAgICAgICB2aXNpYmxlXHJcbiAgICB9KTtcclxuICAgIGlmICh2aXNpYmxlKSB7XHJcbiAgICAgICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgsIHNuYXApO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcmVlLmxhc3RXcml0ZUlkID0gd3JpdGVJZDtcclxufVxyXG4vKipcclxuICogUmVjb3JkIGEgbmV3IG1lcmdlIGZyb20gdXNlciBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQWRkTWVyZ2Uod3JpdGVUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpIHtcclxuICAgIGFzc2VydCh3cml0ZUlkID4gd3JpdGVUcmVlLmxhc3RXcml0ZUlkLCAnU3RhY2tpbmcgYW4gb2xkZXIgbWVyZ2Ugb24gdG9wIG9mIG5ld2VyIG9uZXMnKTtcclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMucHVzaCh7XHJcbiAgICAgICAgcGF0aCxcclxuICAgICAgICBjaGlsZHJlbjogY2hhbmdlZENoaWxkcmVuLFxyXG4gICAgICAgIHdyaXRlSWQsXHJcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZXMod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPSB3cml0ZUlkO1xyXG59XHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUdldFdyaXRlKHdyaXRlVHJlZSwgd3JpdGVJZCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkID0gd3JpdGVUcmVlLmFsbFdyaXRlc1tpXTtcclxuICAgICAgICBpZiAocmVjb3JkLndyaXRlSWQgPT09IHdyaXRlSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGEgd3JpdGUgKGVpdGhlciBhbiBvdmVyd3JpdGUgb3IgbWVyZ2UpIHRoYXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGFja25vd2xlZGdlIGJ5IHRoZSBzZXJ2ZXIuIFJlY2FsY3VsYXRlc1xyXG4gKiB0aGUgdHJlZSBpZiBuZWNlc3NhcnkuICBXZSByZXR1cm4gdHJ1ZSBpZiBpdCBtYXkgaGF2ZSBiZWVuIHZpc2libGUsIG1lYW5pbmcgdmlld3MgbmVlZCB0byByZWV2YWx1YXRlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB3cml0ZSBtYXkgaGF2ZSBiZWVuIHZpc2libGUgKG1lYW5pbmcgd2UnbGwgbmVlZCB0byByZWV2YWx1YXRlIC8gcmFpc2VcclxuICogZXZlbnRzIGFzIGEgcmVzdWx0KS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlbW92ZVdyaXRlKHdyaXRlVHJlZSwgd3JpdGVJZCkge1xyXG4gICAgLy8gTm90ZTogZGlzYWJsaW5nIHRoaXMgY2hlY2suIEl0IGNvdWxkIGJlIGEgdHJhbnNhY3Rpb24gdGhhdCBwcmVlbXB0ZWQgYW5vdGhlciB0cmFuc2FjdGlvbiwgYW5kIHRodXMgd2FzIGFwcGxpZWRcclxuICAgIC8vIG91dCBvZiBvcmRlci5cclxuICAgIC8vY29uc3QgdmFsaWRDbGVhciA9IHJldmVydCB8fCB0aGlzLmFsbFdyaXRlc18ubGVuZ3RoID09PSAwIHx8IHdyaXRlSWQgPD0gdGhpcy5hbGxXcml0ZXNfWzBdLndyaXRlSWQ7XHJcbiAgICAvL2Fzc2VydCh2YWxpZENsZWFyLCBcIkVpdGhlciB3ZSBkb24ndCBoYXZlIHRoaXMgd3JpdGUsIG9yIGl0J3MgdGhlIGZpcnN0IG9uZSBpbiB0aGUgcXVldWVcIik7XHJcbiAgICBjb25zdCBpZHggPSB3cml0ZVRyZWUuYWxsV3JpdGVzLmZpbmRJbmRleChzID0+IHtcclxuICAgICAgICByZXR1cm4gcy53cml0ZUlkID09PSB3cml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBhc3NlcnQoaWR4ID49IDAsICdyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLicpO1xyXG4gICAgY29uc3Qgd3JpdGVUb1JlbW92ZSA9IHdyaXRlVHJlZS5hbGxXcml0ZXNbaWR4XTtcclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICBsZXQgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IHdyaXRlVG9SZW1vdmUudmlzaWJsZTtcclxuICAgIGxldCByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IGZhbHNlO1xyXG4gICAgbGV0IGkgPSB3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAocmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSAmJiBpID49IDApIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50V3JpdGUgPSB3cml0ZVRyZWUuYWxsV3JpdGVzW2ldO1xyXG4gICAgICAgIGlmIChjdXJyZW50V3JpdGUudmlzaWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSBpZHggJiZcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZVJlY29yZENvbnRhaW5zUGF0aF8oY3VycmVudFdyaXRlLCB3cml0ZVRvUmVtb3ZlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVtb3ZlZCB3cml0ZSB3YXMgY29tcGxldGVseSBzaGFkb3dlZCBieSBhIHN1YnNlcXVlbnQgd3JpdGUuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlVG9SZW1vdmUucGF0aCwgY3VycmVudFdyaXRlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgd2UncmUgY292ZXJpbmcgc29tZSB3cml0ZXMgb3IgdGhleSdyZSBjb3ZlcmluZyBwYXJ0IG9mIHVzIChkZXBlbmRpbmcgb24gd2hpY2ggY2FtZSBmaXJzdCkuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaS0tO1xyXG4gICAgfVxyXG4gICAgaWYgKCFyZW1vdmVkV3JpdGVXYXNWaXNpYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMpIHtcclxuICAgICAgICAvLyBUaGVyZSdzIHNvbWUgc2hhZG93aW5nIGdvaW5nIG9uLiBKdXN0IHJlYnVpbGQgdGhlIHZpc2libGUgd3JpdGVzIGZyb20gc2NyYXRjaC5cclxuICAgICAgICB3cml0ZVRyZWVSZXNldFRyZWVfKHdyaXRlVHJlZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGVyZSdzIG5vIHNoYWRvd2luZy4gIFdlIGNhbiBzYWZlbHkganVzdCByZW1vdmUgdGhlIHdyaXRlKHMpIGZyb20gdmlzaWJsZVdyaXRlcy5cclxuICAgICAgICBpZiAod3JpdGVUb1JlbW92ZS5zbmFwKSB7XHJcbiAgICAgICAgICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB3cml0ZVRvUmVtb3ZlLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB3cml0ZVRvUmVtb3ZlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBlYWNoKGNoaWxkcmVuLCAoY2hpbGROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVSZW1vdmVXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aENoaWxkKHdyaXRlVG9SZW1vdmUucGF0aCwgY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWNvcmRDb250YWluc1BhdGhfKHdyaXRlUmVjb3JkLCBwYXRoKSB7XHJcbiAgICBpZiAod3JpdGVSZWNvcmQuc25hcCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoQ29udGFpbnMod3JpdGVSZWNvcmQucGF0aCwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTmFtZSBpbiB3cml0ZVJlY29yZC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAod3JpdGVSZWNvcmQuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoY2hpbGROYW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgcGF0aENvbnRhaW5zKHBhdGhDaGlsZCh3cml0ZVJlY29yZC5wYXRoLCBjaGlsZE5hbWUpLCBwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZS1sYXllciB0aGUgd3JpdGVzIGFuZCBtZXJnZXMgaW50byBhIHRyZWUgc28gd2UgY2FuIGVmZmljaWVudGx5IGNhbGN1bGF0ZSBldmVudCBzbmFwc2hvdHNcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlc2V0VHJlZV8od3JpdGVUcmVlKSB7XHJcbiAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVUcmVlLmFsbFdyaXRlcywgd3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8sIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIGlmICh3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPVxyXG4gICAgICAgICAgICB3cml0ZVRyZWUuYWxsV3JpdGVzW3dyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoIC0gMV0ud3JpdGVJZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9IC0xO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBmaWx0ZXIgdXNlZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgdHJlZS4gS2VlcCBldmVyeXRoaW5nIHRoYXQncyB2aXNpYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8od3JpdGUpIHtcclxuICAgIHJldHVybiB3cml0ZS52aXNpYmxlO1xyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgbWV0aG9kLiBHaXZlbiBhbiBhcnJheSBvZiBXcml0ZVJlY29yZHMsIGEgZmlsdGVyIGZvciB3aGljaCBvbmVzIHRvIGluY2x1ZGUsIGFuZCBhIHBhdGgsIGNvbnN0cnVjdCB0aGUgdHJlZSBvZlxyXG4gKiBldmVudCBkYXRhIGF0IHRoYXQgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVzLCBmaWx0ZXIsIHRyZWVSb290KSB7XHJcbiAgICBsZXQgY29tcG91bmRXcml0ZSA9IENvbXBvdW5kV3JpdGUuZW1wdHkoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGUgPSB3cml0ZXNbaV07XHJcbiAgICAgICAgLy8gVGhlb3J5LCBhIGxhdGVyIHNldCB3aWxsIGVpdGhlcjpcclxuICAgICAgICAvLyBhKSBhYm9ydCBhIHJlbGV2YW50IHRyYW5zYWN0aW9uLCBzbyBubyBuZWVkIHRvIHdvcnJ5IGFib3V0IGV4Y2x1ZGluZyBpdCBmcm9tIGNhbGN1bGF0aW5nIHRoYXQgdHJhbnNhY3Rpb25cclxuICAgICAgICAvLyBiKSBub3QgYmUgcmVsZXZhbnQgdG8gYSB0cmFuc2FjdGlvbiAoc2VwYXJhdGUgYnJhbmNoKSwgc28gYWdhaW4gd2lsbCBub3QgYWZmZWN0IHRoZSBkYXRhIGZvciB0aGF0IHRyYW5zYWN0aW9uXHJcbiAgICAgICAgaWYgKGZpbHRlcih3cml0ZSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgd3JpdGVQYXRoID0gd3JpdGUucGF0aDtcclxuICAgICAgICAgICAgbGV0IHJlbGF0aXZlUGF0aDtcclxuICAgICAgICAgICAgaWYgKHdyaXRlLnNuYXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoQ29udGFpbnModHJlZVJvb3QsIHdyaXRlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgodHJlZVJvb3QsIHdyaXRlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCByZWxhdGl2ZVBhdGgsIHdyaXRlLnNuYXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlUGF0aCwgdHJlZVJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIHdyaXRlLnNuYXAuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3cml0ZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWlucyh0cmVlUm9vdCwgd3JpdGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh0cmVlUm9vdCwgd3JpdGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCByZWxhdGl2ZVBhdGgsIHdyaXRlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhDb250YWlucyh3cml0ZVBhdGgsIHRyZWVSb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh3cml0ZVBhdGgsIHRyZWVSb290KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCBuZXdFbXB0eVBhdGgoKSwgd3JpdGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBzYWZlR2V0KHdyaXRlLmNoaWxkcmVuLCBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgZXhpc3RzIGEgY2hpbGQgaW4gdGhpcyBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgcm9vdCBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWVwTm9kZSA9IGNoaWxkLmdldENoaWxkKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIGRlZXBOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1dyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGU7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhbmQgYW4gb3B0aW9uYWwgc2V0IG9mIGNvbnN0cmFpbnRzIChleGNsdWRlIHNvbWUgc2V0cywgaW5jbHVkZSBoaWRkZW5cclxuICogd3JpdGVzKSwgYXR0ZW1wdCB0byBjYWxjdWxhdGUgYSBjb21wbGV0ZSBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIHBhdGhcclxuICpcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQW4gb3B0aW9uYWwgc2V0IHRvIGJlIGV4Y2x1ZGVkXHJcbiAqIEBwYXJhbSBpbmNsdWRlSGlkZGVuV3JpdGVzIC0gRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgb3Igbm90IHRvIGxheWVyIG9uIHdyaXRlcyB3aXRoIHZpc2libGUgc2V0IHRvIGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICBpZiAoIXdyaXRlSWRzVG9FeGNsdWRlICYmICFpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFkb3dpbmdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViTWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wb3VuZFdyaXRlSXNFbXB0eShzdWJNZXJnZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVNlcnZlckNhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKHN1Yk1lcmdlLCBuZXdFbXB0eVBhdGgoKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHdvdWxkbid0IGhhdmUgYSBjb21wbGV0ZSBzbmFwc2hvdCwgc2luY2UgdGhlcmUncyBubyB1bmRlcmx5aW5nIGRhdGEgYW5kIG5vIGNvbXBsZXRlIHNoYWRvd1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcmVkQ2FjaGUgPSBjb21wbGV0ZVNlcnZlckNhY2hlIHx8IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShzdWJNZXJnZSwgbGF5ZXJlZENhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGlmICghaW5jbHVkZUhpZGRlbldyaXRlcyAmJiBjb21wb3VuZFdyaXRlSXNFbXB0eShtZXJnZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGNhY2hlIGlzIG51bGwsIGFuZCB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGUgY2FjaGUsIHdlIG5lZWQgdG8gcmV0dXJuIG51bGxcclxuICAgICAgICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuV3JpdGVzICYmXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVNlcnZlckNhY2hlID09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICFjb21wb3VuZFdyaXRlSGFzQ29tcGxldGVXcml0ZShtZXJnZSwgbmV3RW1wdHlQYXRoKCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGZ1bmN0aW9uICh3cml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHdyaXRlLnZpc2libGUgfHwgaW5jbHVkZUhpZGRlbldyaXRlcykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCF3cml0ZUlkc1RvRXhjbHVkZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIX53cml0ZUlkc1RvRXhjbHVkZS5pbmRleE9mKHdyaXRlLndyaXRlSWQpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocGF0aENvbnRhaW5zKHdyaXRlLnBhdGgsIHRyZWVQYXRoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENvbnRhaW5zKHRyZWVQYXRoLCB3cml0ZS5wYXRoKSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlQXRQYXRoID0gd3JpdGVUcmVlTGF5ZXJUcmVlXyh3cml0ZVRyZWUuYWxsV3JpdGVzLCBmaWx0ZXIsIHRyZWVQYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KG1lcmdlQXRQYXRoLCBsYXllcmVkQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXaXRoIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhdHRlbXB0IHRvIHJldHVybiBhIGNoaWxkcmVuIG5vZGUgb2YgY2hpbGRyZW4gdGhhdCB3ZSBoYXZlIGNvbXBsZXRlIGRhdGEgZm9yLlxyXG4gKiBVc2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZpZXdzLCB0byBwcmUtZmlsbCB0aGVpciBjb21wbGV0ZSBldmVudCBjaGlsZHJlbiBzbmFwc2hvdC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVUcmVlLCB0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xyXG4gICAgbGV0IGNvbXBsZXRlQ2hpbGRyZW4gPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIGNvbnN0IHRvcExldmVsU2V0ID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgaWYgKHRvcExldmVsU2V0KSB7XHJcbiAgICAgICAgaWYgKCF0b3BMZXZlbFNldC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgc2hhZG93aW5nIGV2ZXJ5dGhpbmcuIFJldHVybiB0aGUgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIHRvcExldmVsU2V0LmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGRTbmFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIGNoaWxkU25hcCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgICAgICAvLyBMYXllciBhbnkgY2hpbGRyZW4gd2UgaGF2ZSBvbiB0b3Agb2YgdGhpc1xyXG4gICAgICAgIC8vIFdlIGtub3cgd2UgZG9uJ3QgaGF2ZSBhIHRvcC1sZXZlbCBzZXQsIHNvIGp1c3QgZW51bWVyYXRlIGV4aXN0aW5nIGNoaWxkcmVuXHJcbiAgICAgICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbi5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gY29tcG91bmRXcml0ZUFwcGx5KGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUobWVyZ2UsIG5ldyBQYXRoKGNoaWxkTmFtZSkpLCBjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEFkZCBhbnkgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBmcm9tIHRoZSBzZXRcclxuICAgICAgICBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihtZXJnZSkuZm9yRWFjaChuYW1lZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBsYXllciBvbiB0b3Agb2YuIExheWVyIG9uIGFueSBjaGlsZHJlbiB3ZSBoYXZlXHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgc25hcCBpZiB3ZSBoYXZlIGEgZGVmaW5lZCBkZWxldGVcclxuICAgICAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihtZXJnZSkuZm9yRWFjaChuYW1lZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiB0aGF0IHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCwgaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlXHJcbiAqIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxyXG4gKlxyXG4gKiBQb3NzaWJpbGl0aWVzOlxyXG4gKlxyXG4gKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcclxuICpcclxuICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50c1xyXG4gKlxyXG4gKiBFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVUcmVlLCB0cmVlUGF0aCwgY2hpbGRQYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICBhc3NlcnQoZXhpc3RpbmdFdmVudFNuYXAgfHwgZXhpc3RpbmdTZXJ2ZXJTbmFwLCAnRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0Jyk7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENoaWxkKHRyZWVQYXRoLCBjaGlsZFBhdGgpO1xyXG4gICAgaWYgKGNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKSkge1xyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY2FuIHByb2JhYmx5IGd1YXJhbnRlZSB0aGF0IHdlJ3JlIGluIGNhc2UgMiwgbWVhbmluZyBubyBldmVudHNcclxuICAgICAgICAvLyBNYXkgbmVlZCB0byBjaGVjayB2aXNpYmlsaXR5IHdoaWxlIGRvaW5nIHRoZSBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGggY2FsbFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTm8gY29tcGxldGUgc2hhZG93aW5nLiBXZSdyZSBlaXRoZXIgcGFydGlhbGx5IHNoYWRvd2luZyBvciBub3Qgc2hhZG93aW5nIGF0IGFsbC5cclxuICAgICAgICBjb25zdCBjaGlsZE1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICAgICAgaWYgKGNvbXBvdW5kV3JpdGVJc0VtcHR5KGNoaWxkTWVyZ2UpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBzaGFkb3dpbmcgYXQgYWxsLiBDYXNlIDFcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VydmVyU25hcC5nZXRDaGlsZChjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIGVmZmljaWVudCBpZiB0aGUgc2VydmVyTm9kZSArIHVwZGF0ZXMgZG9lc24ndCBjaGFuZ2UgdGhlIGV2ZW50U25hcFxyXG4gICAgICAgICAgICAvLyBIb3dldmVyIHRoaXMgaXMgdHJpY2t5IHRvIGZpbmQgb3V0LCBzaW5jZSB1c2VyIHVwZGF0ZXMgZG9uJ3QgbmVjZXNzYXJ5IGNoYW5nZSB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIHNuYXAsIGUuZy4gcHJpb3JpdHkgdXBkYXRlcyBvbiBlbXB0eSBub2Rlcywgb3IgZGVlcCBkZWxldGVzLiBBbm90aGVyIHNwZWNpYWwgY2FzZSBpcyBpZiB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIGFkZHMgbm9kZXMsIGJ1dCBkb2Vzbid0IGNoYW5nZSBhbnkgZXhpc3Rpbmcgd3JpdGVzLiBJdCBpcyB0aGVyZWZvcmUgbm90IGVub3VnaCB0b1xyXG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIGlmIHRoZSB1cGRhdGVzIGNoYW5nZSB0aGUgc2VydmVyTm9kZS5cclxuICAgICAgICAgICAgLy8gTWF5YmUgY2hlY2sgaWYgdGhlIG1lcmdlIHRyZWUgY29udGFpbnMgdGhlc2Ugc3BlY2lhbCBjYXNlcyBhbmQgb25seSBkbyBhIGZ1bGwgb3ZlcndyaXRlIGluIHRoYXQgY2FzZT9cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShjaGlsZE1lcmdlLCBleGlzdGluZ1NlcnZlclNuYXAuZ2V0Q2hpbGQoY2hpbGRQYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cclxuICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENoaWxkKHRyZWVQYXRoLCBjaGlsZEtleSk7XHJcbiAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRvd2luZ05vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZXhpc3RpbmdTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRNZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KGNoaWxkTWVyZ2UsIGV4aXN0aW5nU2VydmVyU25hcC5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgaWYgdGhlcmUgaXMgYSBjb21wbGV0ZSBvdmVyd3JpdGUgZm9yIHRoaXMgcGF0aC4gTW9yZSBzcGVjaWZpY2FsbHksIGlmIHRoZXJlIGlzIGEgd3JpdGUgYXRcclxuICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cclxuICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHdyaXRlIGF0IHRoaXMgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVNoYWRvd2luZ1dyaXRlKHdyaXRlVHJlZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxyXG4gKiB0aGUgd2luZG93LCBidXQgbWF5IG5vdyBiZSBpbiB0aGUgd2luZG93LlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XHJcbiAgICBsZXQgdG9JdGVyYXRlO1xyXG4gICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZShtZXJnZSwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHRvSXRlcmF0ZSA9IHNoYWRvd2luZ05vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb21wbGV0ZVNlcnZlckRhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgIHRvSXRlcmF0ZSA9IGNvbXBvdW5kV3JpdGVBcHBseShtZXJnZSwgY29tcGxldGVTZXJ2ZXJEYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vIGNoaWxkcmVuIHRvIGl0ZXJhdGUgb25cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB0b0l0ZXJhdGUgPSB0b0l0ZXJhdGUud2l0aEluZGV4KGluZGV4KTtcclxuICAgIGlmICghdG9JdGVyYXRlLmlzRW1wdHkoKSAmJiAhdG9JdGVyYXRlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgY21wID0gaW5kZXguZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSByZXZlcnNlXHJcbiAgICAgICAgICAgID8gdG9JdGVyYXRlLmdldFJldmVyc2VJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleClcclxuICAgICAgICAgICAgOiB0b0l0ZXJhdGUuZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXgpO1xyXG4gICAgICAgIGxldCBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgbm9kZXMubGVuZ3RoIDwgY291bnQpIHtcclxuICAgICAgICAgICAgaWYgKGNtcChuZXh0LCBzdGFydFBvc3QpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1dyaXRlVHJlZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmlzaWJsZVdyaXRlczogQ29tcG91bmRXcml0ZS5lbXB0eSgpLFxyXG4gICAgICAgIGFsbFdyaXRlczogW10sXHJcbiAgICAgICAgbGFzdFdyaXRlSWQ6IC0xXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBJZiBwb3NzaWJsZSwgcmV0dXJucyBhIGNvbXBsZXRlIGV2ZW50IGNhY2hlLCB1c2luZyB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBpZiBwb3NzaWJsZS4gSW4gYWRkaXRpb24sIGNhbiBiZSB1c2VkXHJcbiAqIHRvIGdldCBhIGNhY2hlIHRoYXQgaW5jbHVkZXMgaGlkZGVuIHdyaXRlcywgYW5kIGV4Y2x1ZGVzIGFyYml0cmFyeSB3cml0ZXMuIE5vdGUgdGhhdCBjdXN0b21pemluZyB0aGUgcmV0dXJuZWQgbm9kZVxyXG4gKiBjYW4gbGVhZCB0byBhIG1vcmUgZXhwZW5zaXZlIGNhbGN1bGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gd3JpdGVJZHNUb0V4Y2x1ZGUgLSBPcHRpb25hbCB3cml0ZXMgdG8gZXhjbHVkZS5cclxuICogQHBhcmFtIGluY2x1ZGVIaWRkZW5Xcml0ZXMgLSBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcykge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcyk7XHJcbn1cclxuLyoqXHJcbiAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY2hpbGRyZW4gbm9kZSBjb250YWluaW5nIGFsbCBvZiB0aGUgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBkYXRhIGZvci4gVGhlIHJldHVybmVkIGRhdGEgaXMgYVxyXG4gKiBtaXggb2YgdGhlIGdpdmVuIHNlcnZlciBkYXRhIGFuZCB3cml0ZSBkYXRhLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZVRyZWVSZWYsIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbik7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIHRoYXQgZWl0aGVyIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkIG9yIHRoZSBvdXRzdGFuZGluZyB3cml0ZXMgaGF2ZSB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCxcclxuICogaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxyXG4gKlxyXG4gKiBQb3NzaWJpbGl0aWVzOlxyXG4gKlxyXG4gKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcclxuICpcclxuICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkXHJcbiAqXHJcbiAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdCwgdGhpcyBpcyB2YWxpZGF0ZWQgdmlhIGFuIGFzc2VydFxyXG4gKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZVRyZWVSZWYsIHBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgcGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGlmIHRoZXJlIGlzIGEgY29tcGxldGUgb3ZlcndyaXRlIGZvciB0aGlzIHBhdGguIE1vcmUgc3BlY2lmaWNhbGx5LCBpZiB0aGVyZSBpcyBhIHdyaXRlIGF0XHJcbiAqIGEgaGlnaGVyIHBhdGgsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNoaWxkIG9mIHRoYXQgd3JpdGUgcmVsYXRpdmUgdG8gdGhlIHdyaXRlIGFuZCB0aGlzIHBhdGguXHJcbiAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB3cml0ZSBhdCB0aGlzIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWVSZWYsIHBhdGgpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCBwYXRoQ2hpbGQod3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2hlbiBwcm9jZXNzaW5nIGNoaWxkIHJlbW92ZSBldmVudHMgb24gYSBxdWVyeS4gSWYgd2UgY2FuLCB3ZSBwdWxsIGluIGNoaWxkcmVuIHRoYXQgd2VyZSBvdXRzaWRlXHJcbiAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3dcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNJbmRleGVkU2xpY2Uod3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cclxuICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWVSZWYsIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlckNhY2hlKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJDYWNoZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIFdyaXRlVHJlZVJlZiBmb3IgYSBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlVHJlZVJlZiwgY2hpbGROYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3V3JpdGVUcmVlUmVmKHBhdGhDaGlsZCh3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNoaWxkTmFtZSksIHdyaXRlVHJlZVJlZi53cml0ZVRyZWUpO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1dyaXRlVHJlZVJlZihwYXRoLCB3cml0ZVRyZWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHJlZVBhdGg6IHBhdGgsXHJcbiAgICAgICAgd3JpdGVUcmVlXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIENoaWxkQ2hhbmdlQWNjdW11bGF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICB0cmFja0NoaWxkQ2hhbmdlKGNoYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGFuZ2UudHlwZTtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IGNoYW5nZS5jaGlsZE5hbWU7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGUgPT09IFwiY2hpbGRfYWRkZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0FEREVEICovIHx8XHJcbiAgICAgICAgICAgIHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyB8fFxyXG4gICAgICAgICAgICB0eXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8sICdPbmx5IGNoaWxkIGNoYW5nZXMgc3VwcG9ydGVkIGZvciB0cmFja2luZycpO1xyXG4gICAgICAgIGFzc2VydChjaGlsZEtleSAhPT0gJy5wcmlvcml0eScsICdPbmx5IG5vbi1wcmlvcml0eSBjaGlsZCBjaGFuZ2VzIGNhbiBiZSB0cmFja2VkLicpO1xyXG4gICAgICAgIGNvbnN0IG9sZENoYW5nZSA9IHRoaXMuY2hhbmdlTWFwLmdldChjaGlsZEtleSk7XHJcbiAgICAgICAgaWYgKG9sZENoYW5nZSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRUeXBlID0gb2xkQ2hhbmdlLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLmRlbGV0ZShjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRSZW1vdmVkKGNoaWxkS2V5LCBvbGRDaGFuZ2Uub2xkU25hcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRBZGRlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLm9sZFNuYXApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdJbGxlZ2FsIGNvbWJpbmF0aW9uIG9mIGNoYW5nZXM6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBvY2N1cnJlZCBhZnRlciAnICtcclxuICAgICAgICAgICAgICAgICAgICBvbGRDaGFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbmdlcygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoYW5nZU1hcC52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIENvbXBsZXRlQ2hpbGRTb3VyY2UgdGhhdCBuZXZlciByZXR1cm5zIGFueSBhZGRpdGlvbmFsIGNoaWxkcmVuXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmNsYXNzIE5vQ29tcGxldGVDaGlsZFNvdXJjZV8ge1xyXG4gICAgZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hpbGRBZnRlckNoaWxkKGluZGV4LCBjaGlsZCwgcmV2ZXJzZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UuXHJcbiAqL1xyXG5jb25zdCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UgPSBuZXcgTm9Db21wbGV0ZUNoaWxkU291cmNlXygpO1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IHVzZXMgYSBXcml0ZVRyZWUgaW4gYWRkaXRpb24gdG8gYW55IG90aGVyIHNlcnZlciBkYXRhIG9yXHJcbiAqIG9sZCBldmVudCBjYWNoZXMgYXZhaWxhYmxlIHRvIGNhbGN1bGF0ZSBjb21wbGV0ZSBjaGlsZHJlbi5cclxuICovXHJcbmNsYXNzIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Iod3JpdGVzXywgdmlld0NhY2hlXywgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZXNfID0gd3JpdGVzXztcclxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSB2aWV3Q2FjaGVfO1xyXG4gICAgICAgIHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXztcclxuICAgIH1cclxuICAgIGdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy52aWV3Q2FjaGVfLmV2ZW50Q2FjaGU7XHJcbiAgICAgICAgaWYgKG5vZGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyTm9kZSA9IHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8sIHRydWUsIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZpZXdDYWNoZV8uc2VydmVyQ2FjaGU7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh0aGlzLndyaXRlc18sIGNoaWxkS2V5LCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZEFmdGVyQ2hpbGQoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGxldGVTZXJ2ZXJEYXRhID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXHJcbiAgICAgICAgICAgID8gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xyXG4gICAgICAgICAgICA6IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh0aGlzLnZpZXdDYWNoZV8pO1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gd3JpdGVUcmVlUmVmQ2FsY0luZGV4ZWRTbGljZSh0aGlzLndyaXRlc18sIGNvbXBsZXRlU2VydmVyRGF0YSwgY2hpbGQsIDEsIHJldmVyc2UsIGluZGV4KTtcclxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdWaWV3UHJvY2Vzc29yKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIHsgZmlsdGVyIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlKSB7XHJcbiAgICBhc3NlcnQodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLmlzSW5kZXhlZCh2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleCgpKSwgJ0V2ZW50IHNuYXAgbm90IGluZGV4ZWQnKTtcclxuICAgIGFzc2VydCh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmlzSW5kZXhlZCh2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleCgpKSwgJ1NlcnZlciBzbmFwIG5vdCBpbmRleGVkJyk7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5T3BlcmF0aW9uKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSkge1xyXG4gICAgY29uc3QgYWNjdW11bGF0b3IgPSBuZXcgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcigpO1xyXG4gICAgbGV0IG5ld1ZpZXdDYWNoZSwgZmlsdGVyU2VydmVyTm9kZTtcclxuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEUpIHtcclxuICAgICAgICBjb25zdCBvdmVyd3JpdGUgPSBvcGVyYXRpb247XHJcbiAgICAgICAgaWYgKG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVVzZXIpIHtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChvdmVyd3JpdGUuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcclxuICAgICAgICAgICAgLy8gV2UgZmlsdGVyIHRoZSBub2RlIGlmIGl0J3MgYSB0YWdnZWQgdXBkYXRlIG9yIHRoZSBub2RlIGhhcyBiZWVuIHByZXZpb3VzbHkgZmlsdGVyZWQgIGFuZCB0aGVcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGlzIG5vdCBhdCB0aGUgcm9vdCBpbiB3aGljaCBjYXNlIGl0IGlzIG9rIChhbmQgbmVjZXNzYXJ5KSB0byBtYXJrIHRoZSBub2RlIHVuZmlsdGVyZWRcclxuICAgICAgICAgICAgLy8gYWdhaW5cclxuICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XHJcbiAgICAgICAgICAgICAgICBvdmVyd3JpdGUuc291cmNlLnRhZ2dlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpICYmICFwYXRoSXNFbXB0eShvdmVyd3JpdGUucGF0aCkpO1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvdmVyd3JpdGUucGF0aCwgb3ZlcndyaXRlLnNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTUVSR0UpIHtcclxuICAgICAgICBjb25zdCBtZXJnZSA9IG9wZXJhdGlvbjtcclxuICAgICAgICBpZiAobWVyZ2Uuc291cmNlLmZyb21Vc2VyKSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVVzZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KG1lcmdlLnNvdXJjZS5mcm9tU2VydmVyLCAnVW5rbm93biBzb3VyY2UuJyk7XHJcbiAgICAgICAgICAgIC8vIFdlIGZpbHRlciB0aGUgbm9kZSBpZiBpdCdzIGEgdGFnZ2VkIHVwZGF0ZSBvciB0aGUgbm9kZSBoYXMgYmVlbiBwcmV2aW91c2x5IGZpbHRlcmVkXHJcbiAgICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUgPVxyXG4gICAgICAgICAgICAgICAgbWVyZ2Uuc291cmNlLnRhZ2dlZCB8fCBvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpO1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFKSB7XHJcbiAgICAgICAgY29uc3QgYWNrVXNlcldyaXRlID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIGlmICghYWNrVXNlcldyaXRlLnJldmVydCkge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQWNrVXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIGFja1VzZXJXcml0ZS5hZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTElTVEVOX0NPTVBMRVRFKSB7XHJcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3Nvckxpc3RlbkNvbXBsZXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLnBhdGgsIHdyaXRlc0NhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignVW5rbm93biBvcGVyYXRpb24gdHlwZTogJyArIG9wZXJhdGlvbi50eXBlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNoYW5nZXMgPSBhY2N1bXVsYXRvci5nZXRDaGFuZ2VzKCk7XHJcbiAgICB2aWV3UHJvY2Vzc29yTWF5YmVBZGRWYWx1ZUV2ZW50KG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VzKTtcclxuICAgIHJldHVybiB7IHZpZXdDYWNoZTogbmV3Vmlld0NhY2hlLCBjaGFuZ2VzIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3Nvck1heWJlQWRkVmFsdWVFdmVudChvbGRWaWV3Q2FjaGUsIG5ld1ZpZXdDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IGV2ZW50U25hcCA9IG5ld1ZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IGlzTGVhZk9yRW1wdHkgPSBldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSB8fCBldmVudFNuYXAuZ2V0Tm9kZSgpLmlzRW1wdHkoKTtcclxuICAgICAgICBjb25zdCBvbGRDb21wbGV0ZVNuYXAgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUpO1xyXG4gICAgICAgIGlmIChhY2N1bXVsYXRvci5sZW5ndGggPiAwIHx8XHJcbiAgICAgICAgICAgICFvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxyXG4gICAgICAgICAgICAoaXNMZWFmT3JFbXB0eSAmJiAhZXZlbnRTbmFwLmdldE5vZGUoKS5lcXVhbHMob2xkQ29tcGxldGVTbmFwKSkgfHxcclxuICAgICAgICAgICAgIWV2ZW50U25hcC5nZXROb2RlKCkuZ2V0UHJpb3JpdHkoKS5lcXVhbHMob2xkQ29tcGxldGVTbmFwLmdldFByaW9yaXR5KCkpKSB7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goY2hhbmdlVmFsdWUodmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAobmV3Vmlld0NhY2hlKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGNoYW5nZVBhdGgsIHdyaXRlc0NhY2hlLCBzb3VyY2UsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRFdmVudFNuYXAgPSB2aWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgIGlmICh3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZXNDYWNoZSwgY2hhbmdlUGF0aCkgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHdlIGhhdmUgYSBzaGFkb3dpbmcgd3JpdGUsIGlnbm9yZSBjaGFuZ2VzXHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBuZXdFdmVudENhY2hlLCBzZXJ2ZXJOb2RlO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0aGlzIHBsYXlzIHdpdGggXCJzbGlkaW5nIGFjayB3aW5kb3dzXCJcclxuICAgICAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ0lmIGNoYW5nZSBwYXRoIGlzIGVtcHR5LCB3ZSBtdXN0IGhhdmUgY29tcGxldGUgc2VydmVyIGRhdGEnKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoaXMsIGJlY2F1c2Ugd2UgbmVlZCB0byBvbmx5IGFwcGx5IHdyaXRlcyB0byBjb21wbGV0ZSBjaGlsZHJlbiwgb3JcclxuICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGVuZCB1cCByYWlzaW5nIGV2ZW50cyBmb3IgaW5jb21wbGV0ZSBjaGlsZHJlbi4gSWYgdGhlIHNlcnZlciBkYXRhIGlzIGZpbHRlcmVkIGRlZXBcclxuICAgICAgICAgICAgICAgIC8vIHdyaXRlcyBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0byBiZSBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlQ2hpbGRyZW4gPSBzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZVxyXG4gICAgICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgICAgICA6IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVFdmVudENoaWxkcmVuID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZXNDYWNoZSwgY29tcGxldGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlRnVsbE5vZGUodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4sIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlTm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNvbXBsZXRlTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRMZW5ndGgoY2hhbmdlUGF0aCkgPT09IDEsIFwiQ2FuJ3QgaGF2ZSBhIHByaW9yaXR5IHdpdGggYWRkaXRpb25hbCBwYXRoIGNvbXBvbmVudHNcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRFdmVudE5vZGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBoYXZlIG92ZXJ3cml0ZXMgZm9yIHRoaXMgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcmlvcml0eSA9IHdyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVzQ2FjaGUsIGNoYW5nZVBhdGgsIG9sZEV2ZW50Tm9kZSwgc2VydmVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFByaW9yaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkRXZlbnROb2RlLCB1cGRhdGVkUHJpb3JpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJpb3JpdHkgZGlkbid0IGNoYW5nZSwga2VlcCBvbGQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gcGF0aFBvcEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNoaWxkXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RXZlbnRDaGlsZDtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRFdmVudFNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50Q2hpbGRVcGRhdGUgPSB3cml0ZVRyZWVSZWZDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlc0NhY2hlLCBjaGFuZ2VQYXRoLCBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRDaGlsZFVwZGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGV2ZW50Q2hpbGRVcGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBqdXN0IGtlZXAgdGhlIG9sZCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZEtleSwgdmlld0NhY2hlLnNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdFdmVudENoaWxkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlQ2hpbGQob2xkRXZlbnRTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0V2ZW50Q2hpbGQsIGNoaWxkQ2hhbmdlUGF0aCwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUgb3Igbm8gY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZFNlcnZlclNuYXAgPSBvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBsZXQgbmV3U2VydmVyQ2FjaGU7XHJcbiAgICBjb25zdCBzZXJ2ZXJGaWx0ZXIgPSBmaWx0ZXJTZXJ2ZXJOb2RlXHJcbiAgICAgICAgPyB2aWV3UHJvY2Vzc29yLmZpbHRlclxyXG4gICAgICAgIDogdmlld1Byb2Nlc3Nvci5maWx0ZXIuZ2V0SW5kZXhlZEZpbHRlcigpO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNlcnZlckZpbHRlci5maWx0ZXJzTm9kZXMoKSAmJiAhb2xkU2VydmVyU25hcC5pc0ZpbHRlcmVkKCkpIHtcclxuICAgICAgICAvLyB3ZSB3YW50IHRvIGZpbHRlciB0aGUgc2VydmVyIG5vZGUsIGJ1dCB3ZSBkaWRuJ3QgZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSB5ZXQsIHNvIHNpbXVsYXRlIGEgZnVsbCB1cGRhdGVcclxuICAgICAgICBjb25zdCBuZXdTZXJ2ZXJOb2RlID0gb2xkU2VydmVyU25hcFxyXG4gICAgICAgICAgICAuZ2V0Tm9kZSgpXHJcbiAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld1NlcnZlck5vZGUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgaWYgKCFvbGRTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JQYXRoKGNoYW5nZVBhdGgpICYmXHJcbiAgICAgICAgICAgIHBhdGhHZXRMZW5ndGgoY2hhbmdlUGF0aCkgPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHVwZGF0ZSBpbmNvbXBsZXRlIG5vZGVzIHdpdGggdXBkYXRlcyBpbnRlbmRlZCBmb3Igb3RoZXIgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHJldHVybiBvbGRWaWV3Q2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlUGF0aCA9IHBhdGhQb3BGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xyXG4gICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVDaGlsZChvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0NoaWxkTm9kZSwgY2hpbGRDaGFuZ2VQYXRoLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAob2xkVmlld0NhY2hlLCBuZXdTZXJ2ZXJDYWNoZSwgb2xkU2VydmVyU25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSwgc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIG5ld1ZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVVzZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRFdmVudFNuYXAgPSBvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgIGxldCBuZXdWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGU7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNDYWNoZSwgb2xkVmlld0NhY2hlLCBjb21wbGV0ZUNhY2hlKTtcclxuICAgIGlmIChwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgdHJ1ZSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkVmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgb2xkRXZlbnRTbmFwLmlzRmlsdGVyZWQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZVBhdGggPSBwYXRoUG9wRnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZDtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KGNoaWxkQ2hhbmdlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoaWxkIG92ZXJ3cml0ZSwgd2UgY2FuIHJlcGxhY2UgdGhlIGNoaWxkXHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoYW5nZWRTbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gc291cmNlLmdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhHZXRCYWNrKGNoaWxkQ2hhbmdlUGF0aCkgPT09ICcucHJpb3JpdHknICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5nZXRDaGlsZChwYXRoUGFyZW50KGNoaWxkQ2hhbmdlUGF0aCkpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHJpb3JpdHkgdXBkYXRlIG9uIGFuIGVtcHR5IG5vZGUuIElmIHRoaXMgbm9kZSBleGlzdHMgb24gdGhlIHNlcnZlciwgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcnZlciB3aWxsIHNlbmQgZG93biB0aGUgcHJpb3JpdHkgaW4gdGhlIHVwZGF0ZSwgc28gaWdub3JlIGZvciBub3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjaGlsZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZS51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBjb21wbGV0ZSBjaGlsZCBub2RlIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudFNuYXAgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3Q2hpbGQsIGNoaWxkQ2hhbmdlUGF0aCwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAob2xkVmlld0NhY2hlLCBuZXdFdmVudFNuYXAsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1ZpZXdDYWNoZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIGNoaWxkS2V5KSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLmV2ZW50Q2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyTWVyZ2Uodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIC8vIEhBQ0s6IEluIHRoZSBjYXNlIG9mIGEgbGltaXQgcXVlcnksIHRoZXJlIG1heSBiZSBzb21lIGNoYW5nZXMgdGhhdCBidW1wIHRoaW5ncyBvdXQgb2YgdGhlXHJcbiAgICAvLyB3aW5kb3cgbGVhdmluZyByb29tIGZvciBuZXcgaXRlbXMuICBJdCdzIGltcG9ydGFudCB3ZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgZmlyc3QsIHNvIHdlXHJcbiAgICAvLyBpdGVyYXRlIHRoZSBjaGFuZ2VzIHR3aWNlLCBmaXJzdCBwcm9jZXNzaW5nIGFueSB0aGF0IGFmZmVjdCBpdGVtcyBjdXJyZW50bHkgaW4gdmlldy5cclxuICAgIC8vIFRPRE86IEkgY29uc2lkZXIgYW4gaXRlbSBcImluIHZpZXdcIiBpZiBjYWNoZUhhc0NoaWxkIGlzIHRydWUsIHdoaWNoIGNoZWNrcyBib3RoIHRoZSBzZXJ2ZXJcclxuICAgIC8vIGFuZCBldmVudCBzbmFwLiAgSSdtIG5vdCBzdXJlIGlmIHRoaXMgd2lsbCByZXN1bHQgaW4gZWRnZSBjYXNlcyB3aGVuIGEgY2hpbGQgaXMgaW4gb25lIGJ1dFxyXG4gICAgLy8gbm90IHRoZSBvdGhlci5cclxuICAgIGxldCBjdXJWaWV3Q2FjaGUgPSB2aWV3Q2FjaGU7XHJcbiAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaCgocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICBjb25zdCB3cml0ZVBhdGggPSBwYXRoQ2hpbGQocGF0aCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBpZiAodmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQodmlld0NhY2hlLCBwYXRoR2V0RnJvbnQod3JpdGVQYXRoKSkpIHtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHBhdGhDaGlsZChwYXRoLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGlmICghdmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQodmlld0NhY2hlLCBwYXRoR2V0RnJvbnQod3JpdGVQYXRoKSkpIHtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjdXJWaWV3Q2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5TWVyZ2Uodmlld1Byb2Nlc3Nvciwgbm9kZSwgbWVyZ2UpIHtcclxuICAgIG1lcmdlLmZvcmVhY2goKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNhY2hlIHlldCwgdGhpcyBtZXJnZSB3YXMgaW50ZW5kZWQgZm9yIGEgcHJldmlvdXNseSBsaXN0ZW4gaW4gdGhlIHNhbWUgbG9jYXRpb24uIElnbm9yZSBpdCBhbmRcclxuICAgIC8vIHdhaXQgZm9yIHRoZSBjb21wbGV0ZSBkYXRhIHVwZGF0ZSBjb21pbmcgc29vbi5cclxuICAgIGlmICh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmlzRW1wdHkoKSAmJlxyXG4gICAgICAgICF2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcclxuICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcclxuICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxyXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxyXG4gICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XHJcbiAgICAvLyBub3QgdGhlIG90aGVyLlxyXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcclxuICAgIGxldCB2aWV3TWVyZ2VUcmVlO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgdmlld01lcmdlVHJlZSA9IGNoYW5nZWRDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZpZXdNZXJnZVRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKS5zZXRUcmVlKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgIGlmIChzZXJ2ZXJOb2RlLmhhc0NoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBzZXJ2ZXJDaGlsZCwgY2hpbGRUcmVlKTtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgbmV3IFBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2aWV3TWVyZ2VUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkS2V5LCBjaGlsZE1lcmdlVHJlZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzVW5rbm93bkRlZXBNZXJnZSA9ICF2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSAmJlxyXG4gICAgICAgICAgICBjaGlsZE1lcmdlVHJlZS52YWx1ZSA9PT0gbnVsbDtcclxuICAgICAgICBpZiAoIXNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpICYmICFpc1Vua25vd25EZWVwTWVyZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2hpbGQgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gdmlld1Byb2Nlc3NvckFwcGx5TWVyZ2Uodmlld1Byb2Nlc3Nvciwgc2VydmVyQ2hpbGQsIGNoaWxkTWVyZ2VUcmVlKTtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgbmV3IFBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY3VyVmlld0NhY2hlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBY2tVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBhZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgaWYgKHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBhY2tQYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIC8vIE9ubHkgZmlsdGVyIHNlcnZlciBub2RlIGlmIGl0IGlzIGN1cnJlbnRseSBmaWx0ZXJlZFxyXG4gICAgY29uc3QgZmlsdGVyU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCk7XHJcbiAgICAvLyBFc3NlbnRpYWxseSB3ZSdsbCBqdXN0IGdldCBvdXIgZXhpc3Rpbmcgc2VydmVyIGNhY2hlIGZvciB0aGUgYWZmZWN0ZWQgcGF0aHMgYW5kIHJlLWFwcGx5IGl0IGFzIGEgc2VydmVyIHVwZGF0ZVxyXG4gICAgLy8gbm93IHRoYXQgaXQgd29uJ3QgYmUgc2hhZG93ZWQuXHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGlmIChhZmZlY3RlZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gb3ZlcndyaXRlLlxyXG4gICAgICAgIGlmICgocGF0aElzRW1wdHkoYWNrUGF0aCkgJiYgc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHx8XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlLmlzQ29tcGxldGVGb3JQYXRoKGFja1BhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZ2V0Q2hpbGQoYWNrUGF0aCksIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGhJc0VtcHR5KGFja1BhdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBnb29meSBlZGdlIGNhc2Ugd2hlcmUgd2UgYXJlIGFja2luZyBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYnV0IGRvbid0IGhhdmUgZnVsbCBkYXRhLiAgV2VcclxuICAgICAgICAgICAgLy8gc2hvdWxkIGp1c3QgcmUtYXBwbHkgd2hhdGV2ZXIgd2UgaGF2ZSBpbiBvdXIgY2FjaGUgYXMgYSBtZXJnZS5cclxuICAgICAgICAgICAgbGV0IGNoYW5nZWRDaGlsZHJlbiA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZm9yRWFjaENoaWxkKEtFWV9JTkRFWCwgKG5hbWUsIG5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbiA9IGNoYW5nZWRDaGlsZHJlbi5zZXQobmV3IFBhdGgobmFtZSksIG5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgYWNrUGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgbWVyZ2UuXHJcbiAgICAgICAgbGV0IGNoYW5nZWRDaGlsZHJlbiA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGFmZmVjdGVkVHJlZS5mb3JlYWNoKChtZXJnZVBhdGgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNhY2hlUGF0aCA9IHBhdGhDaGlsZChhY2tQYXRoLCBtZXJnZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoc2VydmVyQ2FjaGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuID0gY2hhbmdlZENoaWxkcmVuLnNldChtZXJnZVBhdGgsIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChzZXJ2ZXJDYWNoZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yTGlzdGVuQ29tcGxldGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZFNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBjb25zdCBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSwgb2xkU2VydmVyTm9kZS5nZXROb2RlKCksIG9sZFNlcnZlck5vZGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHwgcGF0aElzRW1wdHkocGF0aCksIG9sZFNlcnZlck5vZGUuaXNGaWx0ZXJlZCgpKTtcclxuICAgIHJldHVybiB2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCh2aWV3UHJvY2Vzc29yLCBuZXdWaWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIGFjY3VtdWxhdG9yKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBsZXQgY29tcGxldGU7XHJcbiAgICBpZiAod3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVzQ2FjaGUsIHBhdGgpICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgY29uc3Qgb2xkRXZlbnRDYWNoZSA9IHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICBsZXQgbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkgfHwgcGF0aEdldEZyb250KHBhdGgpID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBsZXQgbmV3Tm9kZTtcclxuICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkcmVuID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydChzZXJ2ZXJDaGlsZHJlbiBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZSwgJ3NlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZScpO1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVzQ2FjaGUsIHNlcnZlckNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZEV2ZW50Q2FjaGUsIG5ld05vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q2hpbGQgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh3cml0ZXNDYWNoZSwgY2hpbGRLZXksIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZCA9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBvbGRFdmVudENhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50Q2FjaGUsIGNoaWxkS2V5LCBuZXdDaGlsZCwgcGF0aFBvcEZyb250KHBhdGgpLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCkuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUsIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudENhY2hlLCBjaGlsZEtleSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIHBhdGhQb3BGcm9udChwYXRoKSwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3RXZlbnRDYWNoZS5pc0VtcHR5KCkgJiZcclxuICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSByZXZlcnRlZCBhbGwgY2hpbGQgd3JpdGVzLiBNYXliZSB0aGUgb2xkIGV2ZW50IHdhcyBhIGxlYWYgbm9kZVxyXG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG5ld0V2ZW50Q2FjaGUsIGNvbXBsZXRlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcGxldGUgPVxyXG4gICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHxcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBuZXdFbXB0eVBhdGgoKSkgIT0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgY29tcGxldGUsIHZpZXdQcm9jZXNzb3IuZmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB2aWV3IHJlcHJlc2VudHMgYSBzcGVjaWZpYyBsb2NhdGlvbiBhbmQgcXVlcnkgdGhhdCBoYXMgMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXHJcbiAqXHJcbiAqIEl0IGRvZXMgc2V2ZXJhbCB0aGluZ3M6XHJcbiAqICAtIE1haW50YWlucyB0aGUgbGlzdCBvZiBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxyXG4gKiAgLSBNYWludGFpbnMgYSBjYWNoZSBvZiB0aGUgZGF0YSB2aXNpYmxlIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxyXG4gKiAgLSBBcHBsaWVzIG5ldyBvcGVyYXRpb25zICh2aWEgYXBwbHlPcGVyYXRpb24pLCB1cGRhdGVzIHRoZSBjYWNoZSwgYW5kIGJhc2VkIG9uIHRoZSBldmVudFxyXG4gKiAgICByZWdpc3RyYXRpb25zIHJldHVybnMgdGhlIHNldCBvZiBldmVudHMgdG8gYmUgcmFpc2VkLlxyXG4gKi9cclxuY2xhc3MgVmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeV8sIGluaXRpYWxWaWV3Q2FjaGUpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18gPSBbXTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnF1ZXJ5Xy5fcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgY29uc3QgaW5kZXhGaWx0ZXIgPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gcXVlcnlQYXJhbXNHZXROb2RlRmlsdGVyKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JfID0gbmV3Vmlld1Byb2Nlc3NvcihmaWx0ZXIpO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXJ2ZXJDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICAgICAgY29uc3QgaW5pdGlhbEV2ZW50Q2FjaGUgPSBpbml0aWFsVmlld0NhY2hlLmV2ZW50Q2FjaGU7XHJcbiAgICAgICAgLy8gRG9uJ3QgZmlsdGVyIHNlcnZlciBub2RlIHdpdGggb3RoZXIgZmlsdGVyIHRoYW4gaW5kZXgsIHdhaXQgZm9yIHRhZ2dlZCBsaXN0ZW5cclxuICAgICAgICBjb25zdCBzZXJ2ZXJTbmFwID0gaW5kZXhGaWx0ZXIudXBkYXRlRnVsbE5vZGUoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIGluaXRpYWxTZXJ2ZXJDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50U25hcCA9IGZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbEV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcclxuICAgICAgICBjb25zdCBuZXdTZXJ2ZXJDYWNoZSA9IG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgaW5pdGlhbFNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCBpbmRleEZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG5ldyBDYWNoZU5vZGUoZXZlbnRTbmFwLCBpbml0aWFsRXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgZmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSBuZXdWaWV3Q2FjaGUobmV3RXZlbnRDYWNoZSwgbmV3U2VydmVyQ2FjaGUpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRHZW5lcmF0b3JfID0gbmV3IEV2ZW50R2VuZXJhdG9yKHRoaXMucXVlcnlfKTtcclxuICAgIH1cclxuICAgIGdldCBxdWVyeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeV87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldFNlcnZlckNhY2hlKHZpZXcpIHtcclxuICAgIHJldHVybiB2aWV3LnZpZXdDYWNoZV8uc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRDb21wbGV0ZU5vZGUodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXcudmlld0NhY2hlXyk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUodmlldywgcGF0aCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlldy52aWV3Q2FjaGVfKTtcclxuICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgYSBcImxvYWRzQWxsRGF0YVwiIHZpZXcsIHRoZW4gY2FjaGUgaXNuJ3QgYWN0dWFsbHkgYSBjb21wbGV0ZSBjYWNoZSBhbmRcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNlZSBpZiBpdCBjb250YWlucyB0aGUgY2hpbGQgd2UncmUgaW50ZXJlc3RlZCBpbi5cclxuICAgICAgICBpZiAodmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkgfHxcclxuICAgICAgICAgICAgKCFwYXRoSXNFbXB0eShwYXRoKSAmJlxyXG4gICAgICAgICAgICAgICAgIWNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKHBhdGhHZXRGcm9udChwYXRoKSkuaXNFbXB0eSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0Q2hpbGQocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdmlld0lzRW1wdHkodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGggPT09IDA7XHJcbn1cclxuZnVuY3Rpb24gdmlld0FkZEV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18ucHVzaChldmVudFJlZ2lzdHJhdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIElmIG51bGwsIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm5zIENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcclxuICAgIGNvbnN0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgaWYgKGNhbmNlbEVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KGV2ZW50UmVnaXN0cmF0aW9uID09IG51bGwsICdBIGNhbmNlbCBzaG91bGQgY2FuY2VsIGFsbCBldmVudCByZWdpc3RyYXRpb25zLicpO1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSB2aWV3LnF1ZXJ5Ll9wYXRoO1xyXG4gICAgICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5mb3JFYWNoKHJlZ2lzdHJhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heWJlRXZlbnQgPSByZWdpc3RyYXRpb24uY3JlYXRlQ2FuY2VsRXZlbnQoY2FuY2VsRXJyb3IsIHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnRzLnB1c2gobWF5YmVFdmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgIGxldCByZW1haW5pbmcgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zX1tpXTtcclxuICAgICAgICAgICAgaWYgKCFleGlzdGluZy5tYXRjaGVzKGV2ZW50UmVnaXN0cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goZXhpc3RpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50UmVnaXN0cmF0aW9uLmhhc0FueUNhbGxiYWNrKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIGp1c3QgdGhpcyBvbmVcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5jb25jYXQodmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLnNsaWNlKGkgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18gPSByZW1haW5pbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18gPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIE9wZXJhdGlvbiwgdXBkYXRlcyBvdXIgY2FjaGUsIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBldmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSkge1xyXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLk1FUkdFICYmXHJcbiAgICAgICAgb3BlcmF0aW9uLnNvdXJjZS5xdWVyeUlkICE9PSBudWxsKSB7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3LnZpZXdDYWNoZV8pLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzJyk7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXcudmlld0NhY2hlXyksICdNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWaWV3Q2FjaGUgPSB2aWV3LnZpZXdDYWNoZV87XHJcbiAgICBjb25zdCByZXN1bHQgPSB2aWV3UHJvY2Vzc29yQXBwbHlPcGVyYXRpb24odmlldy5wcm9jZXNzb3JfLCBvbGRWaWV3Q2FjaGUsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpO1xyXG4gICAgdmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQodmlldy5wcm9jZXNzb3JfLCByZXN1bHQudmlld0NhY2hlKTtcclxuICAgIGFzc2VydChyZXN1bHQudmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XHJcbiAgICAgICAgIW9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ09uY2UgYSBzZXJ2ZXIgc25hcCBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIG5ldmVyIGdvIGJhY2snKTtcclxuICAgIHZpZXcudmlld0NhY2hlXyA9IHJlc3VsdC52aWV3Q2FjaGU7XHJcbiAgICByZXR1cm4gdmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18odmlldywgcmVzdWx0LmNoYW5nZXMsIHJlc3VsdC52aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRJbml0aWFsRXZlbnRzKHZpZXcsIHJlZ2lzdHJhdGlvbikge1xyXG4gICAgY29uc3QgZXZlbnRTbmFwID0gdmlldy52aWV3Q2FjaGVfLmV2ZW50Q2FjaGU7XHJcbiAgICBjb25zdCBpbml0aWFsQ2hhbmdlcyA9IFtdO1xyXG4gICAgaWYgKCFldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50Tm9kZSA9IGV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgZXZlbnROb2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goY2hhbmdlQ2hpbGRBZGRlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goY2hhbmdlVmFsdWUoZXZlbnRTbmFwLmdldE5vZGUoKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIGluaXRpYWxDaGFuZ2VzLCBldmVudFNuYXAuZ2V0Tm9kZSgpLCByZWdpc3RyYXRpb24pO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIGNoYW5nZXMsIGV2ZW50Q2FjaGUsIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICBjb25zdCByZWdpc3RyYXRpb25zID0gZXZlbnRSZWdpc3RyYXRpb25cclxuICAgICAgICA/IFtldmVudFJlZ2lzdHJhdGlvbl1cclxuICAgICAgICA6IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXztcclxuICAgIHJldHVybiBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcyh2aWV3LmV2ZW50R2VuZXJhdG9yXywgY2hhbmdlcywgZXZlbnRDYWNoZSwgcmVnaXN0cmF0aW9ucyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IHJlZmVyZW5jZUNvbnN0cnVjdG9yJDE7XHJcbi8qKlxyXG4gKiBTeW5jUG9pbnQgcmVwcmVzZW50cyBhIHNpbmdsZSBsb2NhdGlvbiBpbiBhIFN5bmNUcmVlIHdpdGggMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMsIG1lYW5pbmcgd2UgbmVlZCB0b1xyXG4gKiBtYWludGFpbiAxIG9yIG1vcmUgVmlld3MgYXQgdGhpcyBsb2NhdGlvbiB0byBjYWNoZSBzZXJ2ZXIgZGF0YSBhbmQgcmFpc2UgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBzZXJ2ZXIgY2hhbmdlc1xyXG4gKiBhbmQgdXNlciB3cml0ZXMgKHNldCwgdHJhbnNhY3Rpb24sIHVwZGF0ZSkuXHJcbiAqXHJcbiAqIEl0J3MgcmVzcG9uc2libGUgZm9yOlxyXG4gKiAgLSBNYWludGFpbmluZyB0aGUgc2V0IG9mIDEgb3IgbW9yZSB2aWV3cyBuZWNlc3NhcnkgYXQgdGhpcyBsb2NhdGlvbiAoYSBTeW5jUG9pbnQgd2l0aCAwIHZpZXdzIHNob3VsZCBiZSByZW1vdmVkKS5cclxuICogIC0gUHJveHlpbmcgdXNlciAvIHNlcnZlciBvcGVyYXRpb25zIHRvIHRoZSB2aWV3cyBhcyBhcHByb3ByaWF0ZSAoaS5lLiBhcHBseVNlcnZlck92ZXJ3cml0ZSxcclxuICogICAgYXBwbHlVc2VyT3ZlcndyaXRlLCBldGMuKVxyXG4gKi9cclxuY2xhc3MgU3luY1BvaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBWaWV3cyBiZWluZyB0cmFja2VkIGF0IHRoaXMgbG9jYXRpb24gaW4gdGhlIHRyZWUsIHN0b3JlZCBhcyBhIG1hcCB3aGVyZSB0aGUga2V5IGlzIGFcclxuICAgICAgICAgKiBxdWVyeUlkIGFuZCB0aGUgdmFsdWUgaXMgdGhlIFZpZXcgZm9yIHRoYXQgcXVlcnkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOT1RFOiBUaGlzIGxpc3Qgd2lsbCBiZSBxdWl0ZSBzbWFsbCAodXN1YWxseSAxLCBidXQgcGVyaGFwcyAyIG9yIDM7IGFueSBtb3JlIGlzIGFuIG9kZCB1c2UgY2FzZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52aWV3cyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRTZXRSZWZlcmVuY2VDb25zdHJ1Y3Rvcih2YWwpIHtcclxuICAgIGFzc2VydCghcmVmZXJlbmNlQ29uc3RydWN0b3IkMSwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XHJcbiAgICByZWZlcmVuY2VDb25zdHJ1Y3RvciQxID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xyXG4gICAgYXNzZXJ0KHJlZmVyZW5jZUNvbnN0cnVjdG9yJDEsICdSZWZlcmVuY2UudHMgaGFzIG5vdCBiZWVuIGxvYWRlZCcpO1xyXG4gICAgcmV0dXJuIHJlZmVyZW5jZUNvbnN0cnVjdG9yJDE7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50SXNFbXB0eShzeW5jUG9pbnQpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnQudmlld3Muc2l6ZSA9PT0gMDtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBvcGVyYXRpb24uc291cmNlLnF1ZXJ5SWQ7XHJcbiAgICBpZiAocXVlcnlJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgIGFzc2VydCh2aWV3ICE9IG51bGwsICdTeW5jVHJlZSBnYXZlIHVzIGFuIG9wIGZvciBhbiBpbnZhbGlkIHF1ZXJ5LicpO1xyXG4gICAgICAgIHJldHVybiB2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHZpZXdBcHBseU9wZXJhdGlvbih2aWV3LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdldCBhIHZpZXcgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byByZXR1cm4gYSB2aWV3IGZvclxyXG4gKiBAcGFyYW0gd3JpdGVzQ2FjaGVcclxuICogQHBhcmFtIHNlcnZlckNhY2hlXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFZpZXcoc3luY1BvaW50LCBxdWVyeSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKSB7XHJcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgaWYgKCF2aWV3KSB7XHJcbiAgICAgICAgLy8gVE9ETzogbWFrZSB3cml0ZXNDYWNoZSB0YWtlIGZsYWcgZm9yIGNvbXBsZXRlIHNlcnZlciBub2RlXHJcbiAgICAgICAgbGV0IGV2ZW50Q2FjaGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlID8gc2VydmVyQ2FjaGUgOiBudWxsKTtcclxuICAgICAgICBsZXQgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGV2ZW50Q2FjaGUpIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VydmVyQ2FjaGUgaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGUpIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudENhY2hlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2aWV3Q2FjaGUgPSBuZXdWaWV3Q2FjaGUobmV3IENhY2hlTm9kZShldmVudENhY2hlLCBldmVudENhY2hlQ29tcGxldGUsIGZhbHNlKSwgbmV3IENhY2hlTm9kZShzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSwgZmFsc2UpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZpZXcocXVlcnksIHZpZXdDYWNoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlldztcclxufVxyXG4vKipcclxuICogQWRkIGFuIGV2ZW50IGNhbGxiYWNrIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnlcclxuICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uXHJcbiAqIEBwYXJhbSB3cml0ZXNDYWNoZVxyXG4gKiBAcGFyYW0gc2VydmVyQ2FjaGUgLSBDb21wbGV0ZSBzZXJ2ZXIgY2FjaGUsIGlmIHdlIGhhdmUgaXQuXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRHZXRWaWV3KHN5bmNQb2ludCwgcXVlcnksIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICBpZiAoIXN5bmNQb2ludC52aWV3cy5oYXMocXVlcnkuX3F1ZXJ5SWRlbnRpZmllcikpIHtcclxuICAgICAgICBzeW5jUG9pbnQudmlld3Muc2V0KHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIsIHZpZXcpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IG5vdywgd2UganVzdCBjcmVhdGVkIGFueXRoaW5nIHRoYXQgd2FzIG1pc3NpbmdcclxuICAgIHZpZXdBZGRFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICByZXR1cm4gdmlld0dldEluaXRpYWxFdmVudHModmlldywgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgZXZlbnQgY2FsbGJhY2socykuICBSZXR1cm4gY2FuY2VsRXZlbnRzIGlmIGEgY2FuY2VsRXJyb3IgaXMgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBJZiBxdWVyeSBpcyB0aGUgZGVmYXVsdCBxdWVyeSwgd2UnbGwgY2hlY2sgYWxsIHZpZXdzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxyXG4gKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCB2aWV3KHMpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCByZW1vdmUgYWxsIGNhbGxiYWNrcy5cclxuICogQHBhcmFtIGNhbmNlbEVycm9yIC0gSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyByZW1vdmVkIHF1ZXJpZXMgYW5kIGFueSBjYW5jZWwgZXZlbnRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jUG9pbnRSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihzeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgY29uc3QgaGFkQ29tcGxldGVWaWV3ID0gc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICBpZiAocXVlcnlJZCA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgLy8gV2hlbiB5b3UgZG8gcmVmLm9mZiguLi4pLCB3ZSBzZWFyY2ggYWxsIHZpZXdzIGZvciB0aGUgcmVnaXN0cmF0aW9uIHRvIHJlbW92ZS5cclxuICAgICAgICBmb3IgKGNvbnN0IFt2aWV3UXVlcnlJZCwgdmlld10gb2Ygc3luY1BvaW50LnZpZXdzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjYW5jZWxFdmVudHMgPSBjYW5jZWxFdmVudHMuY29uY2F0KHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdJc0VtcHR5KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnQudmlld3MuZGVsZXRlKHZpZXdRdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cclxuICAgICAgICAgICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNwZWNpZmljIHZpZXcuXHJcbiAgICAgICAgY29uc3QgdmlldyA9IHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKHZpZXcpIHtcclxuICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gY2FuY2VsRXZlbnRzLmNvbmNhdCh2aWV3UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3SXNFbXB0eSh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgc3luY1BvaW50LnZpZXdzLmRlbGV0ZShxdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cclxuICAgICAgICAgICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaGFkQ29tcGxldGVWaWV3ICYmICFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KSkge1xyXG4gICAgICAgIC8vIFdlIHJlbW92ZWQgb3VyIGxhc3QgY29tcGxldGUgdmlldy5cclxuICAgICAgICByZW1vdmVkLnB1c2gobmV3IChzeW5jUG9pbnRHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpKShxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHJlbW92ZWQsIGV2ZW50czogY2FuY2VsRXZlbnRzIH07XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0UXVlcnlWaWV3cyhzeW5jUG9pbnQpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byB0aGUgZGVzaXJlZCBjb21wbGV0ZSBzbmFwc2hvdFxyXG4gKiBAcmV0dXJucyBBIGNvbXBsZXRlIGNhY2hlLCBpZiBpdCBleGlzdHNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBwYXRoKSB7XHJcbiAgICBsZXQgc2VydmVyQ2FjaGUgPSBudWxsO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUgfHwgdmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUodmlldywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VydmVyQ2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50Vmlld0ZvclF1ZXJ5KHN5bmNQb2ludCwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcztcclxuICAgIGlmIChwYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICByZXR1cm4gc3luY1BvaW50LnZpZXdzLmdldChxdWVyeUlkKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSkge1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludFZpZXdGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzeW5jUG9pbnQpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcoc3luY1BvaW50KSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldENvbXBsZXRlVmlldyhzeW5jUG9pbnQpIHtcclxuICAgIGZvciAoY29uc3QgdmlldyBvZiBzeW5jUG9pbnQudmlld3MudmFsdWVzKCkpIHtcclxuICAgICAgICBpZiAodmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IHJlZmVyZW5jZUNvbnN0cnVjdG9yO1xyXG5mdW5jdGlvbiBzeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgYXNzZXJ0KCFyZWZlcmVuY2VDb25zdHJ1Y3RvciwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XHJcbiAgICByZWZlcmVuY2VDb25zdHJ1Y3RvciA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzeW5jVHJlZUdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xyXG4gICAgYXNzZXJ0KHJlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcclxuICAgIHJldHVybiByZWZlcmVuY2VDb25zdHJ1Y3RvcjtcclxufVxyXG4vKipcclxuICogU3RhdGljIHRyYWNrZXIgZm9yIG5leHQgcXVlcnkgdGFnLlxyXG4gKi9cclxubGV0IHN5bmNUcmVlTmV4dFF1ZXJ5VGFnXyA9IDE7XHJcbi8qKlxyXG4gKiBTeW5jVHJlZSBpcyB0aGUgY2VudHJhbCBjbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnQgY2FsbGJhY2sgcmVnaXN0cmF0aW9uLCBkYXRhIGNhY2hpbmcsIHZpZXdzXHJcbiAqIChxdWVyeSBwcm9jZXNzaW5nKSwgYW5kIGV2ZW50IGdlbmVyYXRpb24uICBUaGVyZSBhcmUgdHlwaWNhbGx5IHR3byBTeW5jVHJlZSBpbnN0YW5jZXMgZm9yXHJcbiAqIGVhY2ggUmVwbywgb25lIGZvciB0aGUgbm9ybWFsIEZpcmViYXNlIGRhdGEsIGFuZCBvbmUgZm9yIHRoZSAuaW5mbyBkYXRhLlxyXG4gKlxyXG4gKiBJdCBoYXMgYSBudW1iZXIgb2YgcmVzcG9uc2liaWxpdGllcywgaW5jbHVkaW5nOlxyXG4gKiAgLSBUcmFja2luZyBhbGwgdXNlciBldmVudCBjYWxsYmFja3MgKHJlZ2lzdGVyZWQgdmlhIGFkZEV2ZW50UmVnaXN0cmF0aW9uKCkgYW5kIHJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKCkpLlxyXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHVzZXIgc2V0KCksIHRyYW5zYWN0aW9uKCksIGFuZCB1cGRhdGUoKSBjYWxsc1xyXG4gKiAgICAoYXBwbHlVc2VyT3ZlcndyaXRlKCksIGFwcGx5VXNlck1lcmdlKCkpLlxyXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHNlcnZlciBkYXRhIGNoYW5nZXMgKGFwcGx5U2VydmVyT3ZlcndyaXRlKCksXHJcbiAqICAgIGFwcGx5U2VydmVyTWVyZ2UoKSkuXHJcbiAqICAtIEdlbmVyYXRpbmcgdXNlci1mYWNpbmcgZXZlbnRzIGZvciBzZXJ2ZXIgYW5kIHVzZXIgY2hhbmdlcyAoYWxsIG9mIHRoZSBhcHBseSogbWV0aG9kc1xyXG4gKiAgICByZXR1cm4gdGhlIHNldCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIHJhaXNlZCBhcyBhIHJlc3VsdCkuXHJcbiAqICAtIE1haW50YWluaW5nIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc2VydmVyIGxpc3RlbnMgdG8gZW5zdXJlIHdlIGFyZSBhbHdheXMgc3Vic2NyaWJlZFxyXG4gKiAgICB0byB0aGUgY29ycmVjdCBzZXQgb2YgcGF0aHMgYW5kIHF1ZXJpZXMgdG8gc2F0aXNmeSB0aGUgY3VycmVudCBzZXQgb2YgdXNlciBldmVudFxyXG4gKiAgICBjYWxsYmFja3MgKGxpc3RlbnMgYXJlIHN0YXJ0ZWQvc3RvcHBlZCB1c2luZyB0aGUgcHJvdmlkZWQgbGlzdGVuUHJvdmlkZXIpLlxyXG4gKlxyXG4gKiBOT1RFOiBBbHRob3VnaCBTeW5jVHJlZSB0cmFja3MgZXZlbnQgY2FsbGJhY2tzIGFuZCBjYWxjdWxhdGVzIGV2ZW50cyB0byByYWlzZSwgdGhlIGFjdHVhbFxyXG4gKiBldmVudHMgYXJlIHJldHVybmVkIHRvIHRoZSBjYWxsZXIgcmF0aGVyIHRoYW4gcmFpc2VkIHN5bmNocm9ub3VzbHkuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBTeW5jVHJlZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBsaXN0ZW5Qcm92aWRlcl8gLSBVc2VkIGJ5IFN5bmNUcmVlIHRvIHN0YXJ0IC8gc3RvcCBsaXN0ZW5pbmdcclxuICAgICAqICAgdG8gc2VydmVyIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxpc3RlblByb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfID0gbGlzdGVuUHJvdmlkZXJfO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyZWUgb2YgU3luY1BvaW50cy4gIFRoZXJlJ3MgYSBTeW5jUG9pbnQgYXQgYW55IGxvY2F0aW9uIHRoYXQgaGFzIDEgb3IgbW9yZSB2aWV3cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN5bmNQb2ludFRyZWVfID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB0cmVlIG9mIGFsbCBwZW5kaW5nIHVzZXIgd3JpdGVzICh1c2VyLWluaXRpYXRlZCBzZXQoKSdzLCB0cmFuc2FjdGlvbigpJ3MsIHVwZGF0ZSgpJ3MsIGV0Yy4pLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlVHJlZV8gPSBuZXdXcml0ZVRyZWUoKTtcclxuICAgICAgICB0aGlzLnRhZ1RvUXVlcnlNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5xdWVyeVRvVGFnTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSB0aGUgZGF0YSBjaGFuZ2VzIGZvciBhIHVzZXItZ2VuZXJhdGVkIHNldCgpIG9yIHRyYW5zYWN0aW9uKCkgY2FsbC5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUoc3luY1RyZWUsIHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpIHtcclxuICAgIC8vIFJlY29yZCBwZW5kaW5nIHdyaXRlLlxyXG4gICAgd3JpdGVUcmVlQWRkT3ZlcndyaXRlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoLCBuZXdEYXRhLCB3cml0ZUlkLCB2aXNpYmxlKTtcclxuICAgIGlmICghdmlzaWJsZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCksIHBhdGgsIG5ld0RhdGEpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbHkgdGhlIGRhdGEgZnJvbSBhIHVzZXItZ2VuZXJhdGVkIHVwZGF0ZSgpIGNhbGxcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVVzZXJNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKSB7XHJcbiAgICAvLyBSZWNvcmQgcGVuZGluZyBtZXJnZS5cclxuICAgIHdyaXRlVHJlZUFkZE1lcmdlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xyXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlVXNlcigpLCBwYXRoLCBjaGFuZ2VUcmVlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFja25vd2xlZGdlIGEgcGVuZGluZyB1c2VyIHdyaXRlIHRoYXQgd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFwcGx5VXNlck92ZXJ3cml0ZSgpIG9yIGFwcGx5VXNlck1lcmdlKCkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZXZlcnQgLSBUcnVlIGlmIHRoZSBnaXZlbiB3cml0ZSBmYWlsZWQgYW5kIG5lZWRzIHRvIGJlIHJldmVydGVkXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQWNrVXNlcldyaXRlKHN5bmNUcmVlLCB3cml0ZUlkLCByZXZlcnQgPSBmYWxzZSkge1xyXG4gICAgY29uc3Qgd3JpdGUgPSB3cml0ZVRyZWVHZXRXcml0ZShzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgd3JpdGVJZCk7XHJcbiAgICBjb25zdCBuZWVkVG9SZWV2YWx1YXRlID0gd3JpdGVUcmVlUmVtb3ZlV3JpdGUoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHdyaXRlSWQpO1xyXG4gICAgaWYgKCFuZWVkVG9SZWV2YWx1YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGFmZmVjdGVkVHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGlmICh3cml0ZS5zbmFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlXHJcbiAgICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3RW1wdHlQYXRoKCksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWFjaCh3cml0ZS5jaGlsZHJlbiwgKHBhdGhTdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3IFBhdGgocGF0aFN0cmluZyksIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgQWNrVXNlcldyaXRlKHdyaXRlLnBhdGgsIGFmZmVjdGVkVHJlZSwgcmV2ZXJ0KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLi5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgbmV3RGF0YSkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgT3ZlcndyaXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpLCBwYXRoLCBuZXdEYXRhKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5U2VydmVyTWVyZ2Uoc3luY1RyZWUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbikge1xyXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlU2VydmVyKCksIHBhdGgsIGNoYW5nZVRyZWUpKTtcclxufVxyXG4vKipcclxuICogQXBwbHkgYSBsaXN0ZW4gY29tcGxldGUgZm9yIGEgcXVlcnlcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseUxpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBMaXN0ZW5Db21wbGV0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBhIGxpc3RlbiBjb21wbGV0ZSBmb3IgYSB0YWdnZWQgcXVlcnlcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBwYXRoLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IExpc3RlbkNvbXBsZXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBldmVudCBjYWxsYmFjayhzKS5cclxuICpcclxuICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCBxdWVyaWVzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxyXG4gKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS9xdWVyaWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCBhbGwgY2FsbGJhY2tzIGFyZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSBza2lwTGlzdGVuZXJEZWR1cCAtIFdoZW4gcGVyZm9ybWluZyBhIGBnZXQoKWAsIHdlIGRvbid0IGFkZCBhbnkgbmV3IGxpc3RlbmVycywgc28gbm9cclxuICogIGRlZHVwaW5nIG5lZWRzIHRvIHRha2UgcGxhY2UuIFRoaXMgZmxhZyBhbGxvd3MgdG9nZ2xpbmcgb2YgdGhhdCBiZWhhdmlvclxyXG4gKiBAcmV0dXJucyBDYW5jZWwgZXZlbnRzLCBpZiBjYW5jZWxFcnJvciB3YXMgcHJvdmlkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yLCBza2lwTGlzdGVuZXJEZWR1cCA9IGZhbHNlKSB7XHJcbiAgICAvLyBGaW5kIHRoZSBzeW5jUG9pbnQgZmlyc3QuIFRoZW4gZGVhbCB3aXRoIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBtYXRjaGluZyBsaXN0ZW5lcnNcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGNvbnN0IG1heWJlU3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgLy8gQSByZW1vdmFsIG9uIGEgZGVmYXVsdCBxdWVyeSBhZmZlY3RzIGFsbCBxdWVyaWVzIGF0IHRoYXQgbG9jYXRpb24uIEEgcmVtb3ZhbCBvbiBhbiBpbmRleGVkIHF1ZXJ5LCBldmVuIG9uZSB3aXRob3V0XHJcbiAgICAvLyBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgZG9lcyAqbm90KiBhZmZlY3QgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gU28gdGhpcyBjaGVjayBtdXN0IGJlIGZvciAnZGVmYXVsdCcsIGFuZFxyXG4gICAgLy8gbm90IGxvYWRzQWxsRGF0YSgpLlxyXG4gICAgaWYgKG1heWJlU3luY1BvaW50ICYmXHJcbiAgICAgICAgKHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIgPT09ICdkZWZhdWx0JyB8fFxyXG4gICAgICAgICAgICBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkobWF5YmVTeW5jUG9pbnQsIHF1ZXJ5KSkpIHtcclxuICAgICAgICBjb25zdCByZW1vdmVkQW5kRXZlbnRzID0gc3luY1BvaW50UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24obWF5YmVTeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpO1xyXG4gICAgICAgIGlmIChzeW5jUG9pbnRJc0VtcHR5KG1heWJlU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZWRBbmRFdmVudHMucmVtb3ZlZDtcclxuICAgICAgICBjYW5jZWxFdmVudHMgPSByZW1vdmVkQW5kRXZlbnRzLmV2ZW50cztcclxuICAgICAgICBpZiAoIXNraXBMaXN0ZW5lckRlZHVwKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXZSBtYXkgaGF2ZSBqdXN0IHJlbW92ZWQgb25lIG9mIG1hbnkgbGlzdGVuZXJzIGFuZCBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIHdob2xlIHByb2Nlc3NcclxuICAgICAgICAgICAgICogV2UgbWF5IGFsc28gbm90IGhhdmUgcmVtb3ZlZCBhIGRlZmF1bHQgbGlzdGVuZXIsIGluIHdoaWNoIGNhc2UgYWxsIG9mIHRoZSBkZXNjZW5kYW50IGxpc3RlbmVycyBzaG91bGQgYWxyZWFkeSBiZVxyXG4gICAgICAgICAgICAgKiBwcm9wZXJseSBzZXQgdXAuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvLyBTaW5jZSBpbmRleGVkIHF1ZXJpZXMgY2FuIHNoYWRvdyBpZiB0aGV5IGRvbid0IGhhdmUgb3RoZXIgcXVlcnkgY29uc3RyYWludHMsIGNoZWNrIGZvciBsb2Fkc0FsbERhdGEoKSwgaW5zdGVhZCBvZlxyXG4gICAgICAgICAgICAvLyBxdWVyeUlkID09PSAnZGVmYXVsdCdcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZpbmdEZWZhdWx0ID0gLTEgIT09XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkLmZpbmRJbmRleChxdWVyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBjb3ZlcmVkID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZmluZE9uUGF0aChwYXRoLCAocmVsYXRpdmVQYXRoLCBwYXJlbnRTeW5jUG9pbnQpID0+IHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhwYXJlbnRTeW5jUG9pbnQpKTtcclxuICAgICAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCAmJiAhY292ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgcG90ZW50aWFsbHkgY2hpbGQgbGlzdGVuZXJzLiBEZXRlcm1pbmUgd2hhdCBpZiBhbnkgbGlzdGVucyB3ZSBuZWVkIHRvIHNlbmQgYmVmb3JlIGV4ZWN1dGluZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIGlmICghc3VidHJlZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGZvbGQgb3ZlciBvdXIgc3VidHJlZSBhbmQgY29sbGVjdCB0aGUgbGlzdGVuZXJzIHRvIHNlbmRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWaWV3cyA9IHN5bmNUcmVlQ29sbGVjdERpc3RpbmN0Vmlld3NGb3JTdWJUcmVlXyhzdWJ0cmVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPaywgd2UndmUgY29sbGVjdGVkIGFsbCB0aGUgbGlzdGVucyB3ZSBuZWVkLiBTZXQgdGhlbSB1cC5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1ZpZXdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXdWaWV3c1tpXSwgbmV3UXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdGFydExpc3RlbmluZyhzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhuZXdRdWVyeSksIHN5bmNUcmVlVGFnRm9yUXVlcnkoc3luY1RyZWUsIG5ld1F1ZXJ5KSwgbGlzdGVuZXIuaGFzaEZuLCBsaXN0ZW5lci5vbkNvbXBsZXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlcmUncyBub3RoaW5nIGJlbG93IHVzLCBzbyBub3RoaW5nIHdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIG9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhbnl0aGluZyBhbmQgd2UncmUgbm90IGNvdmVyZWQgYnkgYSBoaWdoZXIgdXAgbGlzdGVuLCB3ZSBuZWVkIHRvIHN0b3AgbGlzdGVuaW5nIG9uIHRoaXMgcXVlcnlcclxuICAgICAgICAgICAgLy8gVGhlIGFib3ZlIGJsb2NrIGhhcyB1cyBjb3ZlcmVkIGluIHRlcm1zIG9mIG1ha2luZyBzdXJlIHdlJ3JlIHNldCB1cCBvbiBsaXN0ZW5zIGxvd2VyIGluIHRoZSB0cmVlLlxyXG4gICAgICAgICAgICAvLyBBbHNvLCBub3RlIHRoYXQgaWYgd2UgaGF2ZSBhIGNhbmNlbEVycm9yLCBpdCdzIGFscmVhZHkgYmVlbiByZW1vdmVkIGF0IHRoZSBwcm92aWRlciBsZXZlbC5cclxuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkICYmIHJlbW92ZWQubGVuZ3RoID4gMCAmJiAhY2FuY2VsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBkZWZhdWx0LCB0aGVuIHdlIHdlcmVuJ3QgbGlzdGVuaW5nIG9uIGFueSBvZiB0aGUgb3RoZXIgcXVlcmllcyBoZXJlLiBKdXN0IGNhbmNlbCB0aGUgb25lXHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFuZCBjYW5jZWwgZWFjaCBpbmRpdmlkdWFsIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdGFnIGRlZmF1bHQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFRhZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpLCBkZWZhdWx0VGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQuZm9yRWFjaCgocXVlcnlUb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdUb1JlbW92ZSA9IHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZ2V0KHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeVRvUmVtb3ZlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9SZW1vdmUpLCB0YWdUb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93LCBjbGVhciBhbGwgb2YgdGhlIHRhZ3Mgd2UncmUgdHJhY2tpbmcgZm9yIHRoZSByZW1vdmVkIGxpc3RlbnNcclxuICAgICAgICBzeW5jVHJlZVJlbW92ZVRhZ3NfKHN5bmNUcmVlLCByZW1vdmVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgc25hcCwgdGFnKSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlUXVlcnlLZXlGb3JUYWdfKHN5bmNUcmVlLCB0YWcpO1xyXG4gICAgaWYgKHF1ZXJ5S2V5ICE9IG51bGwpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoLCBzbmFwKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gUXVlcnkgbXVzdCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gZm9yIHRoZSBzcGVjaWZpZWQgdGFnZ2VkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBJbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcclxuICAgICAgICBjb25zdCBvcCA9IG5ldyBNZXJnZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoLCBjaGFuZ2VUcmVlKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSByZW1vdmVkIHRoZSBxdWVyeS4gTm8gYmlnIGRlYWwsIGlnbm9yZSB0aGUgdXBkYXRlXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24oc3luY1RyZWUsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgc2tpcFNldHVwTGlzdGVuZXIgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgbGV0IHNlcnZlckNhY2hlID0gbnVsbDtcclxuICAgIGxldCBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPSBmYWxzZTtcclxuICAgIC8vIEFueSBjb3ZlcmluZyB3cml0ZXMgd2lsbCBuZWNlc3NhcmlseSBiZSBhdCB0aGUgcm9vdCwgc28gcmVhbGx5IGFsbCB3ZSBuZWVkIHRvIGZpbmQgaXMgdGhlIHNlcnZlciBjYWNoZS5cclxuICAgIC8vIENvbnNpZGVyIG9wdGltaXppbmcgdGhpcyBvbmNlIHRoZXJlJ3MgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiB3aGF0IGFjdHVhbCBiZWhhdmlvciB3aWxsIGJlLlxyXG4gICAgc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZm9yZWFjaE9uUGF0aChwYXRoLCAocGF0aFRvU3luY1BvaW50LCBzcCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoVG9TeW5jUG9pbnQsIHBhdGgpO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID1cclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgfHwgc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzcCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxyXG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHNwKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChwYXRoKTtcclxuICAgIGlmICghc3luY1BvaW50KSB7XHJcbiAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludCgpO1xyXG4gICAgICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxyXG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNlcnZlckNhY2hlQ29tcGxldGU7XHJcbiAgICBpZiAoc2VydmVyQ2FjaGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAgICAgc3VidHJlZS5mb3JlYWNoQ2hpbGQoKGNoaWxkTmFtZSwgY2hpbGRTeW5jUG9pbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoY2hpbGRTeW5jUG9pbnQsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBsZXRlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjb21wbGV0ZUNhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdmlld0FscmVhZHlFeGlzdHMgPSBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICBpZiAoIXZpZXdBbHJlYWR5RXhpc3RzICYmICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIGEgdGFnIGZvciB0aGlzIHF1ZXJ5XHJcbiAgICAgICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZU1ha2VRdWVyeUtleV8ocXVlcnkpO1xyXG4gICAgICAgIGFzc2VydCghc3luY1RyZWUucXVlcnlUb1RhZ01hcC5oYXMocXVlcnlLZXkpLCAnVmlldyBkb2VzIG5vdCBleGlzdCwgYnV0IHdlIGhhdmUgYSB0YWcnKTtcclxuICAgICAgICBjb25zdCB0YWcgPSBzeW5jVHJlZUdldE5leHRRdWVyeVRhZ18oKTtcclxuICAgICAgICBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLnNldChxdWVyeUtleSwgdGFnKTtcclxuICAgICAgICBzeW5jVHJlZS50YWdUb1F1ZXJ5TWFwLnNldCh0YWcsIHF1ZXJ5S2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdyaXRlc0NhY2hlID0gd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHBhdGgpO1xyXG4gICAgbGV0IGV2ZW50cyA9IHN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpO1xyXG4gICAgaWYgKCF2aWV3QWxyZWFkeUV4aXN0cyAmJiAhZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ICYmICFza2lwU2V0dXBMaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRWaWV3Rm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50cztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGNvbXBsZXRlIGNhY2hlLCBpZiB3ZSBoYXZlIG9uZSwgb2YgdGhlIGRhdGEgYXQgYSBwYXJ0aWN1bGFyIHBhdGguIElmIHRoZSBsb2NhdGlvbiBkb2VzIG5vdCBoYXZlIGFcclxuICogbGlzdGVuZXIgYWJvdmUgaXQsIHdlIHdpbGwgZ2V0IGEgZmFsc2UgXCJudWxsXCIuIFRoaXMgc2hvdWxkbid0IGJlIGEgcHJvYmxlbSBiZWNhdXNlIHRyYW5zYWN0aW9ucyB3aWxsIGFsd2F5c1xyXG4gKiBoYXZlIGEgbGlzdGVuZXIgYWJvdmUsIGFuZCBhdG9taWMgb3BlcmF0aW9ucyB3b3VsZCBjb3JyZWN0bHkgc2hvdyBhIGppdHRlciBvZiA8aW5jcmVtZW50IHZhbHVlPiAtPlxyXG4gKiAgICAgPGluY3JlbWVudGVkIHRvdGFsPiBhcyB0aGUgd3JpdGUgaXMgYXBwbGllZCBsb2NhbGx5IGFuZCB0aGVuIGFja25vd2xlZGdlZCBhdCB0aGUgc2VydmVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsICppbmNsdWRlKiBoaWRkZW4gd3JpdGVzIGZyb20gdHJhbnNhY3Rpb24gd2l0aCBhcHBseUxvY2FsbHkgc2V0IHRvIGZhbHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBkYXRhIHdlIHdhbnRcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQSBzcGVjaWZpYyBzZXQgdG8gYmUgZXhjbHVkZWRcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShzeW5jVHJlZSwgcGF0aCwgd3JpdGVJZHNUb0V4Y2x1ZGUpIHtcclxuICAgIGNvbnN0IGluY2x1ZGVIaWRkZW5TZXRzID0gdHJ1ZTtcclxuICAgIGNvbnN0IHdyaXRlVHJlZSA9IHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfO1xyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGUgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5maW5kT25QYXRoKHBhdGgsIChwYXRoU29GYXIsIHN5bmNQb2ludCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoU29GYXIsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHNlcnZlckNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgcGF0aCwgc2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuU2V0cyk7XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVHZXRTZXJ2ZXJWYWx1ZShzeW5jVHJlZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGxldCBzZXJ2ZXJDYWNoZSA9IG51bGw7XHJcbiAgICAvLyBBbnkgY292ZXJpbmcgd3JpdGVzIHdpbGwgbmVjZXNzYXJpbHkgYmUgYXQgdGhlIHJvb3QsIHNvIHJlYWxseSBhbGwgd2UgbmVlZCB0byBmaW5kIGlzIHRoZSBzZXJ2ZXIgY2FjaGUuXHJcbiAgICAvLyBDb25zaWRlciBvcHRpbWl6aW5nIHRoaXMgb25jZSB0aGVyZSdzIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhY3R1YWwgYmVoYXZpb3Igd2lsbCBiZS5cclxuICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZvcmVhY2hPblBhdGgocGF0aCwgKHBhdGhUb1N5bmNQb2ludCwgc3ApID0+IHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aFRvU3luY1BvaW50LCBwYXRoKTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3AsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIGxldCBzeW5jUG9pbnQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XHJcbiAgICBpZiAoIXN5bmNQb2ludCkge1xyXG4gICAgICAgIHN5bmNQb2ludCA9IG5ldyBTeW5jUG9pbnQoKTtcclxuICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnNldChwYXRoLCBzeW5jUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IHNlcnZlckNhY2hlICE9IG51bGw7XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZU5vZGUgPSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHNlcnZlckNhY2hlLCB0cnVlLCBmYWxzZSlcclxuICAgICAgICA6IG51bGw7XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBxdWVyeS5fcGF0aCk7XHJcbiAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50R2V0VmlldyhzeW5jUG9pbnQsIHF1ZXJ5LCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlTm9kZS5nZXROb2RlKCkgOiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICByZXR1cm4gdmlld0dldENvbXBsZXRlTm9kZSh2aWV3KTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgdmlzaXRzIGFsbCBkZXNjZW5kYW50IGFuZCBhbmNlc3RvciBTeW5jUG9pbnRzLCBhcHBseWluZyB0aGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBOT1RFUzpcclxuICogLSBEZXNjZW5kYW50IFN5bmNQb2ludHMgd2lsbCBiZSB2aXNpdGVkIGZpcnN0IChzaW5jZSB3ZSByYWlzZSBldmVudHMgZGVwdGgtZmlyc3QpLlxyXG4gKlxyXG4gKiAtIFdlIGNhbGwgYXBwbHlPcGVyYXRpb24oKSBvbiBlYWNoIFN5bmNQb2ludCBwYXNzaW5nIHRocmVlIHRoaW5nczpcclxuICogICAxLiBBIHZlcnNpb24gb2YgdGhlIE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIG1hZGUgcmVsYXRpdmUgdG8gdGhlIFN5bmNQb2ludCBsb2NhdGlvbi5cclxuICogICAyLiBBIFdyaXRlVHJlZVJlZiBvZiBhbnkgd3JpdGVzIHdlIGhhdmUgY2FjaGVkIGF0IHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXHJcbiAqICAgMy4gQSBzbmFwc2hvdCBOb2RlIHdpdGggY2FjaGVkIHNlcnZlciBkYXRhLCBpZiB3ZSBoYXZlIGl0LlxyXG4gKlxyXG4gKiAtIFdlIGNvbmNhdGVuYXRlIGFsbCBvZiB0aGUgZXZlbnRzIHJldHVybmVkIGJ5IGVhY2ggU3luY1BvaW50IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBvcGVyYXRpb24pIHtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhvcGVyYXRpb24sIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLCBcclxuICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCwgd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIG5ld0VtcHR5UGF0aCgpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShvcGVyYXRpb24ucGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzeW5jUG9pbnQgPSBzeW5jUG9pbnRUcmVlLmdldChuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBjYWNoZWQgc2VydmVyIGRhdGEsIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gdGhpcyBTeW5jUG9pbnQuXHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgY29uc3QgY2hpbGROYW1lID0gcGF0aEdldEZyb250KG9wZXJhdGlvbi5wYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE9wZXJhdGlvbiA9IG9wZXJhdGlvbi5vcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHN5bmNQb2ludFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkVHJlZSAmJiBjaGlsZE9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1BvaW50QXBwbHlPcGVyYXRpb24oc3luY1BvaW50LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxyXG4gICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBzeW5jUG9pbnRUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRTZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2hpbGRXcml0ZXNDYWNoZSA9IHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldykge1xyXG4gICAgY29uc3QgcXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoYXNoRm46ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB2aWV3R2V0U2VydmVyQ2FjaGUodmlldykgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5oYXNoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNvbXBsZXRlOiAoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBxdWVyeS5fcGF0aCwgdGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5TGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHF1ZXJ5Ll9wYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGEgbGlzdGVuIGZhaWxlZCwga2lsbCBhbGwgb2YgdGhlIGxpc3RlbmVycyBoZXJlLCBub3QganVzdCB0aGUgb25lIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBuZWVkIHRvIGJlIHNjb3BlZCB0byBqdXN0IHRoaXMgbGlzdGVuZXIgaWYgd2UgY2hhbmdlIHBlcm1pc3Npb25zIG9uIGZpbHRlcmVkIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yRm9yU2VydmVyQ29kZShzdGF0dXMsIHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgXHJcbiAgICAgICAgICAgICAgICAvKmV2ZW50UmVnaXN0cmF0aW9uKi8gbnVsbCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlVGFnRm9yUXVlcnkoc3luY1RyZWUsIHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XHJcbiAgICByZXR1cm4gc3luY1RyZWUucXVlcnlUb1RhZ01hcC5nZXQocXVlcnlLZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHF1ZXJ5LCBjb21wdXRlcyBhIFwicXVlcnlLZXlcIiBzdWl0YWJsZSBmb3IgdXNlIGluIG91ciBxdWVyeVRvVGFnTWFwXy5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCkgKyAnJCcgKyBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIHF1ZXJ5IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLCBpZiB3ZSBoYXZlIG9uZVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZykge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuZ2V0KHRhZyk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgcXVlcnlLZXkgKGNyZWF0ZWQgYnkgbWFrZVF1ZXJ5S2V5KSwgcGFyc2UgaXQgYmFjayBpbnRvIGEgcGF0aCBhbmQgcXVlcnlJZC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlUGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpIHtcclxuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBxdWVyeUtleS5pbmRleE9mKCckJyk7XHJcbiAgICBhc3NlcnQoc3BsaXRJbmRleCAhPT0gLTEgJiYgc3BsaXRJbmRleCA8IHF1ZXJ5S2V5Lmxlbmd0aCAtIDEsICdCYWQgcXVlcnlLZXkuJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5S2V5LnN1YnN0cihzcGxpdEluZGV4ICsgMSksXHJcbiAgICAgICAgcGF0aDogbmV3IFBhdGgocXVlcnlLZXkuc3Vic3RyKDAsIHNwbGl0SW5kZXgpKVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRvIGFwcGx5IHRhZ2dlZCBvcGVyYXRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcGVyYXRpb24pIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChxdWVyeVBhdGgpO1xyXG4gICAgYXNzZXJ0KHN5bmNQb2ludCwgXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO1xyXG4gICAgY29uc3Qgd3JpdGVzQ2FjaGUgPSB3cml0ZVRyZWVDaGlsZFdyaXRlcyhzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgcXVlcnlQYXRoKTtcclxuICAgIHJldHVybiBzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG51bGwpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNvbGxhcHNlcyBtdWx0aXBsZSB1bmZpbHRlcmVkIHZpZXdzIGludG8gYSBzaW5nbGUgdmlldywgc2luY2Ugd2Ugb25seSBuZWVkIGEgc2luZ2xlXHJcbiAqIGxpc3RlbmVyIGZvciB0aGVtLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVDb2xsZWN0RGlzdGluY3RWaWV3c0ZvclN1YlRyZWVfKHN1YnRyZWUpIHtcclxuICAgIHJldHVybiBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICBpZiAobWF5YmVDaGlsZFN5bmNQb2ludCAmJiBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVWaWV3ID0gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2NvbXBsZXRlVmlld107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBjb21wbGV0ZSB2aWV3IGhlcmUsIGZsYXR0ZW4gYW55IGRlZXBlciBsaXN0ZW5zIGludG8gYW4gYXJyYXlcclxuICAgICAgICAgICAgbGV0IHZpZXdzID0gW107XHJcbiAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3cyA9IHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkVmlld3MpID0+IHtcclxuICAgICAgICAgICAgICAgIHZpZXdzID0gdmlld3MuY29uY2F0KGNoaWxkVmlld3MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGEgcXVlcnkgdG8gYSBxdWVyeSB3ZSBzZW5kIHRoZSBzZXJ2ZXIgZm9yIGxpc3RlbmluZ1xyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBxdWVyeVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpIHtcclxuICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkgJiYgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSkge1xyXG4gICAgICAgIC8vIFdlIHRyZWF0IHF1ZXJpZXMgdGhhdCBsb2FkIGFsbCBkYXRhIGFzIGRlZmF1bHQgcXVlcmllc1xyXG4gICAgICAgIC8vIENhc3QgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgcmVmKCkgdGVjaG5pY2FsbHkgcmV0dXJucyBGaXJlYmFzZSB3aGljaCBpcyBhY3R1YWxseSBmYi5hcGkuRmlyZWJhc2Ugd2hpY2ggaW5oZXJpdHNcclxuICAgICAgICAvLyBmcm9tIFF1ZXJ5XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoc3luY1RyZWVHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpKShxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlUmVtb3ZlVGFnc18oc3luY1RyZWUsIHF1ZXJpZXMpIHtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcXVlcmllcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeSA9IHF1ZXJpZXNbal07XHJcbiAgICAgICAgaWYgKCFyZW1vdmVkUXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGEgdGFnIGZvciB0aGlzXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhyZW1vdmVkUXVlcnkpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUXVlcnlUYWcgPSBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmdldChyZW1vdmVkUXVlcnlLZXkpO1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmRlbGV0ZShyZW1vdmVkUXVlcnlLZXkpO1xyXG4gICAgICAgICAgICBzeW5jVHJlZS50YWdUb1F1ZXJ5TWFwLmRlbGV0ZShyZW1vdmVkUXVlcnlUYWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3RhdGljIGFjY2Vzc29yIGZvciBxdWVyeSB0YWdzLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVHZXROZXh0UXVlcnlUYWdfKCkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlTmV4dFF1ZXJ5VGFnXysrO1xyXG59XHJcbi8qKlxyXG4gKiBGb3IgYSBnaXZlbiBuZXcgbGlzdGVuLCBtYW5hZ2UgdGhlIGRlLWR1cGxpY2F0aW9uIG9mIG91dHN0YW5kaW5nIHN1YnNjcmlwdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIGNhbiByZXR1cm4gZXZlbnRzIHRvIHN1cHBvcnQgc3luY2hyb25vdXMgZGF0YSBzb3VyY2VzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBzeW5jVHJlZUNyZWF0ZUxpc3RlbmVyRm9yVmlld18oc3luY1RyZWUsIHZpZXcpO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgdGFnLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xyXG4gICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAvLyBUaGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUgaGFzIG91ciBxdWVyeS4gV2UncmUgaGVyZSBiZWNhdXNlIHdlIGRlZmluaXRlbHkgbmVlZCB0byBzZW5kIGEgbGlzdGVuIGZvciB0aGF0LCBidXQgd2VcclxuICAgIC8vIG1heSBuZWVkIHRvIHNoYWRvdyBvdGhlciBsaXN0ZW5zIGFzIHdlbGwuXHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgYXNzZXJ0KCFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3VidHJlZS52YWx1ZSksIFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNoYWRvdyBldmVyeXRoaW5nIGF0IG9yIGJlbG93IHRoaXMgbG9jYXRpb24sIHRoaXMgaXMgYSBkZWZhdWx0IGxpc3RlbmVyLlxyXG4gICAgICAgIGNvbnN0IHF1ZXJpZXNUb1N0b3AgPSBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpICYmXHJcbiAgICAgICAgICAgICAgICBtYXliZUNoaWxkU3luY1BvaW50ICYmXHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpLnF1ZXJ5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgbGV0IHF1ZXJpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCkubWFwKHZpZXcgPT4gdmlldy5xdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkUXVlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXMgPSBxdWVyaWVzLmNvbmNhdChjaGlsZFF1ZXJpZXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVlcmllc1RvU3RvcC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBxdWVyeVRvU3RvcCA9IHF1ZXJpZXNUb1N0b3BbaV07XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9TdG9wKSwgc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnlUb1N0b3ApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEV4aXN0aW5nVmFsdWVQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlXykge1xyXG4gICAgICAgIHRoaXMubm9kZV8gPSBub2RlXztcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5ub2RlXy5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRXhpc3RpbmdWYWx1ZVByb3ZpZGVyKGNoaWxkKTtcclxuICAgIH1cclxuICAgIG5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV87XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN5bmNUcmVlLCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5zeW5jVHJlZV8gPSBzeW5jVHJlZTtcclxuICAgICAgICB0aGlzLnBhdGhfID0gcGF0aDtcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGhDaGlsZCh0aGlzLnBhdGhfLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyKHRoaXMuc3luY1RyZWVfLCBjaGlsZFBhdGgpO1xyXG4gICAgfVxyXG4gICAgbm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHRoaXMuc3luY1RyZWVfLCB0aGlzLnBhdGhfKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgcGxhY2Vob2xkZXJzIGZvciBkZWZlcnJlZCB2YWx1ZXMuXHJcbiAqL1xyXG5jb25zdCBnZW5lcmF0ZVdpdGhWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XHJcbiAgICB2YWx1ZXNbJ3RpbWVzdGFtcCddID0gdmFsdWVzWyd0aW1lc3RhbXAnXSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn07XHJcbi8qKlxyXG4gKiBWYWx1ZSB0byB1c2Ugd2hlbiBmaXJpbmcgbG9jYWwgZXZlbnRzLiBXaGVuIHdyaXRpbmcgc2VydmVyIHZhbHVlcywgZmlyZVxyXG4gKiBsb2NhbCBldmVudHMgd2l0aCBhbiBhcHByb3hpbWF0ZSB2YWx1ZSwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBhcy1pcy5cclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0KCcuc3YnIGluIHZhbHVlLCAnVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHMnKTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWVbJy5zdiddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSh2YWx1ZVsnLnN2J10sIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWycuc3YnXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbXBsZXhEZWZlcnJlZFZhbHVlKHZhbHVlWycuc3YnXSwgZXhpc3RpbmdWYWwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMikpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uIChvcCwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcykge1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZXNbJ3RpbWVzdGFtcCddO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgc2VydmVyIHZhbHVlOiAnICsgb3ApO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXNvbHZlQ29tcGxleERlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAob3AsIGV4aXN0aW5nLCB1bnVzZWQpIHtcclxuICAgIGlmICghb3AuaGFzT3duUHJvcGVydHkoJ2luY3JlbWVudCcpKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBKU09OLnN0cmluZ2lmeShvcCwgbnVsbCwgMikpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVsdGEgPSBvcFsnaW5jcmVtZW50J107XHJcbiAgICBpZiAodHlwZW9mIGRlbHRhICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgaW5jcmVtZW50IHZhbHVlOiAnICsgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gZXhpc3Rpbmcubm9kZSgpO1xyXG4gICAgYXNzZXJ0KGV4aXN0aW5nTm9kZSAhPT0gbnVsbCAmJiB0eXBlb2YgZXhpc3RpbmdOb2RlICE9PSAndW5kZWZpbmVkJywgJ0V4cGVjdGVkIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFIGZvciBudWxscycpO1xyXG4gICAgLy8gSW5jcmVtZW50aW5nIGEgbm9uLW51bWJlciBzZXRzIHRoZSB2YWx1ZSB0byB0aGUgaW5jcmVtZW50ZWQgYW1vdW50XHJcbiAgICBpZiAoIWV4aXN0aW5nTm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWFmID0gZXhpc3RpbmdOb2RlO1xyXG4gICAgY29uc3QgZXhpc3RpbmdWYWwgPSBsZWFmLmdldFZhbHVlKCk7XHJcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nVmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBkZWx0YTtcclxuICAgIH1cclxuICAgIC8vIE5vIG5lZWQgdG8gZG8gb3Zlci91bmRlcmZsb3cgYXJpdGhtZXRpYyBoZXJlIGJlY2F1c2UgSlMgb25seSBoYW5kbGVzIGZsb2F0cyB1bmRlciB0aGUgY292ZXJzXHJcbiAgICByZXR1cm4gZXhpc3RpbmdWYWwgKyBkZWx0YTtcclxufTtcclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgdHJlZSB3aXRoIHRoZVxyXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy5cclxuICogQHBhcmFtIHBhdGggLSBwYXRoIHRvIHdoaWNoIHdyaXRlIGlzIHJlbGF0aXZlXHJcbiAqIEBwYXJhbSBub2RlIC0gbmV3IGRhdGEgd3JpdHRlbiBhdCBwYXRoXHJcbiAqIEBwYXJhbSBzeW5jVHJlZSAtIGN1cnJlbnQgZGF0YVxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlID0gZnVuY3Rpb24gKHBhdGgsIG5vZGUsIHN5bmNUcmVlLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIHJldHVybiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBuZXcgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyKHN5bmNUcmVlLCBwYXRoKSwgc2VydmVyVmFsdWVzKTtcclxufTtcclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgbm9kZSB3aXRoIHRoZVxyXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy4gIElmIHRoZXJlIGFyZSBubyBzZXJ2ZXIgdmFsdWVzIGluIHRoZSBub2RlLFxyXG4gKiBpdCdsbCBiZSByZXR1cm5lZCBhcy1pcy5cclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QgPSBmdW5jdGlvbiAobm9kZSwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcykge1xyXG4gICAgcmV0dXJuIHJlc29sdmVEZWZlcnJlZFZhbHVlKG5vZGUsIG5ldyBFeGlzdGluZ1ZhbHVlUHJvdmlkZXIoZXhpc3RpbmcpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBleGlzdGluZ1ZhbCwgc2VydmVyVmFsdWVzKSB7XHJcbiAgICBjb25zdCByYXdQcmkgPSBub2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICBjb25zdCBwcmlvcml0eSA9IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZShyYXdQcmksIGV4aXN0aW5nVmFsLmdldEltbWVkaWF0ZUNoaWxkKCcucHJpb3JpdHknKSwgc2VydmVyVmFsdWVzKTtcclxuICAgIGxldCBuZXdOb2RlO1xyXG4gICAgaWYgKG5vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgY29uc3QgbGVhZk5vZGUgPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlKGxlYWZOb2RlLmdldFZhbHVlKCksIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbGVhZk5vZGUuZ2V0VmFsdWUoKSB8fFxyXG4gICAgICAgICAgICBwcmlvcml0eSAhPT0gbGVhZk5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlKHZhbHVlLCBub2RlRnJvbUpTT04ocHJpb3JpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgbmV3Tm9kZSA9IGNoaWxkcmVuTm9kZTtcclxuICAgICAgICBpZiAocHJpb3JpdHkgIT09IGNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZVByaW9yaXR5KG5ldyBMZWFmTm9kZShwcmlvcml0eSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWUoY2hpbGROb2RlLCBleGlzdGluZ1ZhbC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGROb2RlICE9PSBjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGxpZ2h0LXdlaWdodCB0cmVlLCB0cmF2ZXJzYWJsZSBieSBwYXRoLiAgTm9kZXMgY2FuIGhhdmUgYm90aCB2YWx1ZXMgYW5kIGNoaWxkcmVuLlxyXG4gKiBOb2RlcyBhcmUgbm90IGVudW1lcmF0ZWQgKGJ5IGZvckVhY2hDaGlsZCkgdW5sZXNzIHRoZXkgaGF2ZSBhIHZhbHVlIG9yIG5vbi1lbXB0eVxyXG4gKiBjaGlsZHJlbi5cclxuICovXHJcbmNsYXNzIFRyZWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50IC0gT3B0aW9uYWwgcGFyZW50IG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIE9wdGlvbmFsIG5vZGUgdG8gd3JhcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCBwYXJlbnQgPSBudWxsLCBub2RlID0geyBjaGlsZHJlbjoge30sIGNoaWxkQ291bnQ6IDAgfSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHN1Yi1UcmVlIGZvciB0aGUgZ2l2ZW4gcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBhdGhPYmogLSBQYXRoIHRvIGxvb2sgdXAuXHJcbiAqIEByZXR1cm5zIFRyZWUgZm9yIHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlU3ViVHJlZSh0cmVlLCBwYXRoT2JqKSB7XHJcbiAgICAvLyBUT0RPOiBSZXF1aXJlIHBhdGhPYmogdG8gYmUgUGF0aD9cclxuICAgIGxldCBwYXRoID0gcGF0aE9iaiBpbnN0YW5jZW9mIFBhdGggPyBwYXRoT2JqIDogbmV3IFBhdGgocGF0aE9iaik7XHJcbiAgICBsZXQgY2hpbGQgPSB0cmVlLCBuZXh0ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgd2hpbGUgKG5leHQgIT09IG51bGwpIHtcclxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBzYWZlR2V0KGNoaWxkLm5vZGUuY2hpbGRyZW4sIG5leHQpIHx8IHtcclxuICAgICAgICAgICAgY2hpbGRyZW46IHt9LFxyXG4gICAgICAgICAgICBjaGlsZENvdW50OiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjaGlsZCA9IG5ldyBUcmVlKG5leHQsIGNoaWxkLCBjaGlsZE5vZGUpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgbmV4dCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBkYXRhIG9yIG51bGwgaWYgbm8gZGF0YSBleGlzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlR2V0VmFsdWUodHJlZSkge1xyXG4gICAgcmV0dXJuIHRyZWUubm9kZS52YWx1ZTtcclxufVxyXG4vKipcclxuICogU2V0cyBkYXRhIHRvIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlU2V0VmFsdWUodHJlZSwgdmFsdWUpIHtcclxuICAgIHRyZWUubm9kZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRyZWUgaGFzIGFueSBjaGlsZHJlbi5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVIYXNDaGlsZHJlbih0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZS5ub2RlLmNoaWxkQ291bnQgPiAwO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBXaGV0aGUgcnRoZSB0cmVlIGlzIGVtcHR5IChubyB2YWx1ZSBvciBjaGlsZHJlbikuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlSXNFbXB0eSh0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZUdldFZhbHVlKHRyZWUpID09PSB1bmRlZmluZWQgJiYgIXRyZWVIYXNDaGlsZHJlbih0cmVlKTtcclxufVxyXG4vKipcclxuICogQ2FsbHMgYWN0aW9uIGZvciBlYWNoIGNoaWxkIG9mIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoQ2hpbGQodHJlZSwgYWN0aW9uKSB7XHJcbiAgICBlYWNoKHRyZWUubm9kZS5jaGlsZHJlbiwgKGNoaWxkLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICBhY3Rpb24obmV3IFRyZWUoY2hpbGQsIHRyZWUsIGNoaWxkVHJlZSkpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlJ3MgZGVzY2VuZGFudHMsIGNhbGxpbmcgYWN0aW9uIGZvciBlYWNoIG9uZS5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiAtIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXHJcbiAqIEBwYXJhbSBpbmNsdWRlU2VsZiAtIFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gdGhpcyBub2RlIGFzIHdlbGwuIERlZmF1bHRzIHRvXHJcbiAqICAgZmFsc2UuXHJcbiAqIEBwYXJhbSBjaGlsZHJlbkZpcnN0IC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiBjaGlsZHJlbiBiZWZvcmUgY2FsbGluZyBpdCBvblxyXG4gKiAgIHBhcmVudC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoRGVzY2VuZGFudCh0cmVlLCBhY3Rpb24sIGluY2x1ZGVTZWxmLCBjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICBpZiAoaW5jbHVkZVNlbGYgJiYgIWNoaWxkcmVuRmlyc3QpIHtcclxuICAgICAgICBhY3Rpb24odHJlZSk7XHJcbiAgICB9XHJcbiAgICB0cmVlRm9yRWFjaENoaWxkKHRyZWUsIGNoaWxkID0+IHtcclxuICAgICAgICB0cmVlRm9yRWFjaERlc2NlbmRhbnQoY2hpbGQsIGFjdGlvbiwgdHJ1ZSwgY2hpbGRyZW5GaXJzdCk7XHJcbiAgICB9KTtcclxuICAgIGlmIChpbmNsdWRlU2VsZiAmJiBjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICAgICAgYWN0aW9uKHRyZWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxscyBhY3Rpb24gb24gZWFjaCBhbmNlc3RvciBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoIHBhcmVudDsgcmV0dXJuXHJcbiAqICAgdHJ1ZSB0byBhYm9ydC5cclxuICogQHBhcmFtIGluY2x1ZGVTZWxmIC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgYWN0aW9uIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlRm9yRWFjaEFuY2VzdG9yKHRyZWUsIGFjdGlvbiwgaW5jbHVkZVNlbGYpIHtcclxuICAgIGxldCBub2RlID0gaW5jbHVkZVNlbGYgPyB0cmVlIDogdHJlZS5wYXJlbnQ7XHJcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChhY3Rpb24obm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVGhlIHBhdGggb2YgdGhpcyB0cmVlIG5vZGUsIGFzIGEgUGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVHZXRQYXRoKHRyZWUpIHtcclxuICAgIHJldHVybiBuZXcgUGF0aCh0cmVlLnBhcmVudCA9PT0gbnVsbFxyXG4gICAgICAgID8gdHJlZS5uYW1lXHJcbiAgICAgICAgOiB0cmVlR2V0UGF0aCh0cmVlLnBhcmVudCkgKyAnLycgKyB0cmVlLm5hbWUpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIG9yIHJlbW92ZXMgdGhpcyBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgYmFzZWQgb24gd2hldGhlciBpdCdzIGVtcHR5IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVVcGRhdGVQYXJlbnRzKHRyZWUpIHtcclxuICAgIGlmICh0cmVlLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRyZWVVcGRhdGVDaGlsZCh0cmVlLnBhcmVudCwgdHJlZS5uYW1lLCB0cmVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBvciByZW1vdmVzIHRoZSBwYXNzZWQgY2hpbGQgdG8gdGhpcyB0cmVlIG5vZGUsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0J3MgZW1wdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gdXBkYXRlLlxyXG4gKiBAcGFyYW0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gdXBkYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVVwZGF0ZUNoaWxkKHRyZWUsIGNoaWxkTmFtZSwgY2hpbGQpIHtcclxuICAgIGNvbnN0IGNoaWxkRW1wdHkgPSB0cmVlSXNFbXB0eShjaGlsZCk7XHJcbiAgICBjb25zdCBjaGlsZEV4aXN0cyA9IGNvbnRhaW5zKHRyZWUubm9kZS5jaGlsZHJlbiwgY2hpbGROYW1lKTtcclxuICAgIGlmIChjaGlsZEVtcHR5ICYmIGNoaWxkRXhpc3RzKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyZWUubm9kZS5jaGlsZHJlbltjaGlsZE5hbWVdO1xyXG4gICAgICAgIHRyZWUubm9kZS5jaGlsZENvdW50LS07XHJcbiAgICAgICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghY2hpbGRFbXB0eSAmJiAhY2hpbGRFeGlzdHMpIHtcclxuICAgICAgICB0cmVlLm5vZGUuY2hpbGRyZW5bY2hpbGROYW1lXSA9IGNoaWxkLm5vZGU7XHJcbiAgICAgICAgdHJlZS5ub2RlLmNoaWxkQ291bnQrKztcclxuICAgICAgICB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBrZXlzXHJcbiAqL1xyXG5jb25zdCBJTlZBTElEX0tFWV9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcL1xcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcclxuLyoqXHJcbiAqIFRydWUgZm9yIGludmFsaWQgRmlyZWJhc2UgcGF0aHMuXHJcbiAqIEFsbG93cyAnLycgaW4gcGF0aHMuXHJcbiAqL1xyXG5jb25zdCBJTlZBTElEX1BBVEhfUkVHRVhfID0gL1tcXFtcXF0uIyRcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XHJcbi8qKlxyXG4gKiBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFsbG93IGluIGxlYWYgdmFsdWVcclxuICovXHJcbmNvbnN0IE1BWF9MRUFGX1NJWkVfID0gMTAgKiAxMDI0ICogMTAyNDtcclxuY29uc3QgaXNWYWxpZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCAhPT0gMCAmJiAhSU5WQUxJRF9LRVlfUkVHRVhfLnRlc3Qoa2V5KSk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHBhdGhTdHJpbmcgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgcGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiZcclxuICAgICAgICAhSU5WQUxJRF9QQVRIX1JFR0VYXy50ZXN0KHBhdGhTdHJpbmcpKTtcclxufTtcclxuY29uc3QgaXNWYWxpZFJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcclxuICAgIGlmIChwYXRoU3RyaW5nKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgJy8uaW5mby8nIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNWYWxpZFBhdGhTdHJpbmcocGF0aFN0cmluZyk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgcmV0dXJuIChwcmlvcml0eSA9PT0gbnVsbCB8fFxyXG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJyAmJiAhaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpIHx8XHJcbiAgICAgICAgKHByaW9yaXR5ICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29udGFpbnMocHJpb3JpdHksICcuc3YnKSkpO1xyXG59O1xyXG4vKipcclxuICogUHJlLXZhbGlkYXRlIGEgZGF0dW0gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIEZpcmViYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcgPSBmdW5jdGlvbiAoZm5OYW1lLCB2YWx1ZSwgcGF0aCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgoZm5OYW1lLCAndmFsdWUnKSwgdmFsdWUsIHBhdGgpO1xyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGUgYSBkYXRhIG9iamVjdCBjbGllbnQtc2lkZSBiZWZvcmUgc2VuZGluZyB0byBzZXJ2ZXIuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlRGF0YSA9IGZ1bmN0aW9uIChlcnJvclByZWZpeCwgZGF0YSwgcGF0aF8pIHtcclxuICAgIGNvbnN0IHBhdGggPSBwYXRoXyBpbnN0YW5jZW9mIFBhdGggPyBuZXcgVmFsaWRhdGlvblBhdGgocGF0aF8sIGVycm9yUHJlZml4KSA6IHBhdGhfO1xyXG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArICdjb250YWlucyB1bmRlZmluZWQgJyArIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAnY29udGFpbnMgYSBmdW5jdGlvbiAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgJyB3aXRoIGNvbnRlbnRzID0gJyArXHJcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyAnICtcclxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpKTtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIG1heCBsZWFmIHNpemUsIGJ1dCB0cnkgdG8gYXZvaWQgdGhlIHV0ZjggY29udmVyc2lvbiBpZiB3ZSBjYW4uXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgZGF0YS5sZW5ndGggPiBNQVhfTEVBRl9TSVpFXyAvIDMgJiZcclxuICAgICAgICBzdHJpbmdMZW5ndGgoZGF0YSkgPiBNQVhfTEVBRl9TSVpFXykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gJyArXHJcbiAgICAgICAgICAgIE1BWF9MRUFGX1NJWkVfICtcclxuICAgICAgICAgICAgJyB1dGY4IGJ5dGVzICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICBcIiAoJ1wiICtcclxuICAgICAgICAgICAgZGF0YS5zdWJzdHJpbmcoMCwgNTApICtcclxuICAgICAgICAgICAgXCIuLi4nKVwiKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8gPSBQZXJmID0gQ29uc2lkZXIgY29tYmluaW5nIHRoZSByZWN1cnNpdmUgdmFsaWRhdGlvbiBvZiBrZXlzIGludG8gTm9kZUZyb21KU09OXHJcbiAgICAvLyB0byBzYXZlIGV4dHJhIHdhbGtpbmcgb2YgbGFyZ2Ugb2JqZWN0cy5cclxuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGxldCBoYXNEb3RWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBoYXNBY3R1YWxDaGlsZCA9IGZhbHNlO1xyXG4gICAgICAgIGVhY2goZGF0YSwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJy52YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgIGhhc0RvdFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcucHJpb3JpdHknICYmIGtleSAhPT0gJy5zdicpIHtcclxuICAgICAgICAgICAgICAgIGhhc0FjdHVhbENoaWxkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyBjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnLiAgS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhQdXNoKHBhdGgsIGtleSk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aCk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoUG9wKHBhdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChoYXNEb3RWYWx1ZSAmJiBoYXNBY3R1YWxDaGlsZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgJyBjb250YWlucyBcIi52YWx1ZVwiIGNoaWxkICcgK1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgICAgICcgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFByZS12YWxpZGF0ZSBwYXRocyBwYXNzZWQgaW4gdGhlIGZpcmViYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMgPSBmdW5jdGlvbiAoZXJyb3JQcmVmaXgsIG1lcmdlUGF0aHMpIHtcclxuICAgIGxldCBpLCBjdXJQYXRoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcclxuICAgICAgICBjb25zdCBrZXlzID0gcGF0aFNsaWNlKGN1clBhdGgpO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoa2V5c1tqXSA9PT0gJy5wcmlvcml0eScgJiYgaiA9PT0ga2V5cy5sZW5ndGggLSAxKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZhbGlkS2V5KGtleXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgICAgICdjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAga2V5c1tqXSArXHJcbiAgICAgICAgICAgICAgICAgICAgJykgaW4gcGF0aCAnICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcuIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyAnICtcclxuICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayB0aGF0IHVwZGF0ZSBrZXlzIGFyZSBub3QgZGVzY2VuZGFudHMgb2YgZWFjaCBvdGhlci5cclxuICAgIC8vIFdlIHJlbHkgb24gdGhlIHByb3BlcnR5IHRoYXQgc29ydGluZyBndWFyYW50ZWVzIHRoYXQgYW5jZXN0b3JzIGNvbWVcclxuICAgIC8vIHJpZ2h0IGJlZm9yZSBkZXNjZW5kYW50cy5cclxuICAgIG1lcmdlUGF0aHMuc29ydChwYXRoQ29tcGFyZSk7XHJcbiAgICBsZXQgcHJldlBhdGggPSBudWxsO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcclxuICAgICAgICBpZiAocHJldlBhdGggIT09IG51bGwgJiYgcGF0aENvbnRhaW5zKHByZXZQYXRoLCBjdXJQYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGEgcGF0aCAnICtcclxuICAgICAgICAgICAgICAgIHByZXZQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgJyB0aGF0IGlzIGFuY2VzdG9yIG9mIGFub3RoZXIgcGF0aCAnICtcclxuICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZQYXRoID0gY3VyUGF0aDtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIHByZS12YWxpZGF0ZSBhbiBvYmplY3QgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGZpcmViYXNlIGZ1bmN0aW9uIChcclxuICogbXVzdCBiZSBhbiBvYmplY3QgLSBlLmcuIGZvciBmaXJlYmFzZS51cGRhdGUoKSkuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnID0gZnVuY3Rpb24gKGZuTmFtZSwgZGF0YSwgcGF0aCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvclByZWZpeCQxID0gZXJyb3JQcmVmaXgoZm5OYW1lLCAndmFsdWVzJyk7XHJcbiAgICBpZiAoIShkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCQxICsgJyBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWVyZ2VQYXRocyA9IFtdO1xyXG4gICAgZWFjaChkYXRhLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1clBhdGggPSBuZXcgUGF0aChrZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4JDEsIHZhbHVlLCBwYXRoQ2hpbGQocGF0aCwgY3VyUGF0aCkpO1xyXG4gICAgICAgIGlmIChwYXRoR2V0QmFjayhjdXJQYXRoKSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkUHJpb3JpdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgkMSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlIGZvciAnXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCInLCB3aGljaCBtdXN0IGJlIGEgdmFsaWQgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICdGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2VQYXRocy5wdXNoKGN1clBhdGgpO1xyXG4gICAgfSk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyhlcnJvclByZWZpeCQxLCBtZXJnZVBhdGhzKTtcclxufTtcclxuY29uc3QgdmFsaWRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChmbk5hbWUsIHByaW9yaXR5LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAncHJpb3JpdHknKSArXHJcbiAgICAgICAgICAgICdpcyAnICtcclxuICAgICAgICAgICAgcHJpb3JpdHkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcsIGJ1dCBtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCAnICtcclxuICAgICAgICAgICAgJ3NlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gYWxsb3cgaW1wb3J0aW5nIGRhdGEgd2l0aCBhIC5zdi5cclxuICAgIGlmICghaXNWYWxpZFByaW9yaXR5KHByaW9yaXR5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICdwcmlvcml0eScpICtcclxuICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAnICtcclxuICAgICAgICAgICAgJyhhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS4nKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVLZXkgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGtleSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArXHJcbiAgICAgICAgICAgICd3YXMgYW4gaW52YWxpZCBrZXkgPSBcIicgK1xyXG4gICAgICAgICAgICBrZXkgK1xyXG4gICAgICAgICAgICAnXCIuICBGaXJlYmFzZSBrZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xyXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgcGF0aFN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgK1xyXG4gICAgICAgICAgICAnd2FzIGFuIGludmFsaWQgcGF0aCA9IFwiJyArXHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmcgK1xyXG4gICAgICAgICAgICAnXCIuIFBhdGhzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xyXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIicpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2YWxpZGF0ZVJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROYW1lLCBwYXRoU3RyaW5nLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKHBhdGhTdHJpbmcpIHtcclxuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cclxuICAgICAgICBwYXRoU3RyaW5nID0gcGF0aFN0cmluZy5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLywgJy8nKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aFN0cmluZyhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgcGF0aFN0cmluZywgb3B0aW9uYWwpO1xyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZVdyaXRhYmxlUGF0aCA9IGZ1bmN0aW9uIChmbk5hbWUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm5OYW1lICsgXCIgZmFpbGVkID0gQ2FuJ3QgbW9kaWZ5IGRhdGEgdW5kZXIgLy5pbmZvL1wiKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVVcmwgPSBmdW5jdGlvbiAoZm5OYW1lLCBwYXJzZWRVcmwpIHtcclxuICAgIC8vIFRPRE8gPSBWYWxpZGF0ZSBzZXJ2ZXIgYmV0dGVyLlxyXG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHBhcnNlZFVybC5wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoISh0eXBlb2YgcGFyc2VkVXJsLnJlcG9JbmZvLmhvc3QgPT09ICdzdHJpbmcnKSB8fFxyXG4gICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0Lmxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICAgICghaXNWYWxpZEtleShwYXJzZWRVcmwucmVwb0luZm8ubmFtZXNwYWNlKSAmJlxyXG4gICAgICAgICAgICBwYXJzZWRVcmwucmVwb0luZm8uaG9zdC5zcGxpdCgnOicpWzBdICE9PSAnbG9jYWxob3N0JykgfHxcclxuICAgICAgICAocGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiYgIWlzVmFsaWRSb290UGF0aFN0cmluZyhwYXRoU3RyaW5nKSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAndXJsJykgK1xyXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIFVSTCBhbmQgJyArXHJcbiAgICAgICAgICAgICd0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO1xyXG4gICAgfVxyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGV2ZW50IHF1ZXVlIHNlcnZlcyBhIGZldyBwdXJwb3NlczpcclxuICogMS4gSXQgZW5zdXJlcyB3ZSBtYWludGFpbiBldmVudCBvcmRlciBpbiB0aGUgZmFjZSBvZiBldmVudCBjYWxsYmFja3MgZG9pbmcgb3BlcmF0aW9ucyB0aGF0IHJlc3VsdCBpbiBtb3JlXHJcbiAqICAgIGV2ZW50cyBiZWluZyBxdWV1ZWQuXHJcbiAqIDIuIHJhaXNlUXVldWVkRXZlbnRzKCkgaGFuZGxlcyBiZWluZyBjYWxsZWQgcmVlbnRyYW50bHkgbmljZWx5LiAgVGhhdCBpcywgaWYgaW4gdGhlIGNvdXJzZSBvZiByYWlzaW5nIGV2ZW50cyxcclxuICogICAgcmFpc2VRdWV1ZWRFdmVudHMoKSBpcyBjYWxsZWQgYWdhaW4sIHRoZSBcImlubmVyXCIgY2FsbCB3aWxsIHBpY2sgdXAgcmFpc2luZyBldmVudHMgd2hlcmUgdGhlIFwib3V0ZXJcIiBjYWxsXHJcbiAqICAgIGxlZnQgb2ZmLCBlbnN1cmluZyB0aGF0IHRoZSBldmVudHMgYXJlIHN0aWxsIHJhaXNlZCBzeW5jaHJvbm91c2x5IGFuZCBpbiBvcmRlci5cclxuICogMy4gWW91IGNhbiB1c2UgcmFpc2VFdmVudHNBdFBhdGggYW5kIHJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGggdG8gZW5zdXJlIG9ubHkgcmVsZXZhbnQgcHJldmlvdXNseS1xdWV1ZWRcclxuICogICAgZXZlbnRzIGFyZSByYWlzZWQgc3luY2hyb25vdXNseS5cclxuICpcclxuICogTk9URTogVGhpcyBjYW4gYWxsIGdvIGF3YXkgaWYvd2hlbiB3ZSBtb3ZlIHRvIGFzeW5jIGV2ZW50cy5cclxuICpcclxuICovXHJcbmNsYXNzIEV2ZW50UXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudExpc3RzXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyByZWN1cnNpb24gZGVwdGggb2YgcmFpc2VRdWV1ZWRFdmVudHNfLCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfID0gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgbmV3IGV2ZW50cyB0byBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KSB7XHJcbiAgICAvLyBXZSBncm91cCBldmVudHMgYnkgcGF0aCwgc3RvcmluZyB0aGVtIGluIGEgc2luZ2xlIEV2ZW50TGlzdCwgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc2tpcCBvdmVyIHRoZW0gcXVpY2tseS5cclxuICAgIGxldCBjdXJyTGlzdCA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50RGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnREYXRhTGlzdFtpXTtcclxuICAgICAgICBjb25zdCBwYXRoID0gZGF0YS5nZXRQYXRoKCk7XHJcbiAgICAgICAgaWYgKGN1cnJMaXN0ICE9PSBudWxsICYmICFwYXRoRXF1YWxzKHBhdGgsIGN1cnJMaXN0LnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XHJcbiAgICAgICAgICAgIGN1cnJMaXN0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJMaXN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGN1cnJMaXN0ID0geyBldmVudHM6IFtdLCBwYXRoIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJMaXN0LmV2ZW50cy5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGN1cnJMaXN0KSB7XHJcbiAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzXy5wdXNoKGN1cnJMaXN0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcylcclxuICogZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBuZXcgZXZlbnRzIGFyZSBhbGwgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxyXG4gKiBAcGFyYW0gZXZlbnREYXRhTGlzdCAtIFRoZSBuZXcgZXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoKGV2ZW50UXVldWUsIHBhdGgsIGV2ZW50RGF0YUxpc3QpIHtcclxuICAgIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KTtcclxuICAgIGV2ZW50UXVldWVSYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlKGV2ZW50UXVldWUsIGV2ZW50UGF0aCA9PiBwYXRoRXF1YWxzKGV2ZW50UGF0aCwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBRdWV1ZXMgdGhlIHNwZWNpZmllZCBldmVudHMgYW5kIHN5bmNocm9ub3VzbHkgcmFpc2VzIGFsbCBldmVudHMgKGluY2x1ZGluZyBwcmV2aW91c2x5IHF1ZXVlZCBvbmVzKSBmb3JcclxuICogbG9jYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHNwZWNpZmllZCBjaGFuZ2UgcGF0aCAoaS5lLiBhbGwgYW5jZXN0b3JzIGFuZCBkZXNjZW5kYW50cykuXHJcbiAqXHJcbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbmV3IGV2ZW50cyBhcmUgYWxsIHJlbGF0ZWQgKGFuY2VzdG9yIG9yIGRlc2NlbmRhbnQpIHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNoYW5nZWRQYXRoIC0gVGhlIHBhdGggdG8gcmFpc2UgZXZlbnRzIGZvci5cclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgZXZlbnRzIHRvIHJhaXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChldmVudFF1ZXVlLCBjaGFuZ2VkUGF0aCwgZXZlbnREYXRhTGlzdCkge1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKGV2ZW50UXVldWUsIGV2ZW50RGF0YUxpc3QpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgZXZlbnRQYXRoID0+IHBhdGhDb250YWlucyhldmVudFBhdGgsIGNoYW5nZWRQYXRoKSB8fFxyXG4gICAgICAgIHBhdGhDb250YWlucyhjaGFuZ2VkUGF0aCwgZXZlbnRQYXRoKSk7XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgcHJlZGljYXRlKSB7XHJcbiAgICBldmVudFF1ZXVlLnJlY3Vyc2lvbkRlcHRoXysrO1xyXG4gICAgbGV0IHNlbnRBbGwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudFF1ZXVlLmV2ZW50TGlzdHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ID0gZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXTtcclxuICAgICAgICBpZiAoZXZlbnRMaXN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50UGF0aCA9IGV2ZW50TGlzdC5wYXRoO1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGV2ZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TGlzdFJhaXNlKGV2ZW50UXVldWUuZXZlbnRMaXN0c19baV0pO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZW50QWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2VudEFsbCkge1xyXG4gICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18gPSBbXTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWUucmVjdXJzaW9uRGVwdGhfLS07XHJcbn1cclxuLyoqXHJcbiAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGxpc3QgYW5kIHJhaXNlcyBlYWNoIGV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudExpc3RSYWlzZShldmVudExpc3QpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRMaXN0LmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGV2ZW50TGlzdC5ldmVudHNbaV07XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudExpc3QuZXZlbnRzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRGbiA9IGV2ZW50RGF0YS5nZXRFdmVudFJ1bm5lcigpO1xyXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBsb2coJ2V2ZW50OiAnICsgZXZlbnREYXRhLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGV2ZW50Rm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBJTlRFUlJVUFRfUkVBU09OID0gJ3JlcG9faW50ZXJydXB0JztcclxuLyoqXHJcbiAqIElmIGEgdHJhbnNhY3Rpb24gZG9lcyBub3Qgc3VjY2VlZCBhZnRlciAyNSByZXRyaWVzLCB3ZSBhYm9ydCBpdC4gQW1vbmcgb3RoZXJcclxuICogdGhpbmdzIHRoaXMgZW5zdXJlIHRoYXQgaWYgdGhlcmUncyBldmVyIGEgYnVnIGNhdXNpbmcgYSBtaXNtYXRjaCBiZXR3ZWVuXHJcbiAqIGNsaWVudCAvIHNlcnZlciBoYXNoZXMgZm9yIHNvbWUgZGF0YSwgd2Ugd29uJ3QgcmV0cnkgaW5kZWZpbml0ZWx5LlxyXG4gKi9cclxuY29uc3QgTUFYX1RSQU5TQUNUSU9OX1JFVFJJRVMgPSAyNTtcclxuLyoqXHJcbiAqIEEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBkYXRhIHJlcG9zaXRvcnkuXHJcbiAqL1xyXG5jbGFzcyBSZXBvIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvXywgZm9yY2VSZXN0Q2xpZW50XywgYXV0aFRva2VuUHJvdmlkZXJfLCBhcHBDaGVja1Byb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZXN0Q2xpZW50XyA9IGZvcmNlUmVzdENsaWVudF87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyXyA9IGFwcENoZWNrUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuZGF0YVVwZGF0ZUNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfID0gbmV3IEV2ZW50UXVldWUoKTtcclxuICAgICAgICB0aGlzLm5leHRXcml0ZUlkXyA9IDE7XHJcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfID0gbnVsbDtcclxuICAgICAgICAvKiogQSBsaXN0IG9mIGRhdGEgcGllY2VzIGFuZCBwYXRocyB0byBiZSBzZXQgd2hlbiB0aGlzIGNsaWVudCBkaXNjb25uZWN0cy4gKi9cclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKTtcclxuICAgICAgICAvKiogU3RvcmVzIHF1ZXVlcyBvZiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgZm9yIEZpcmViYXNlIGxvY2F0aW9ucy4gKi9cclxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXyA9IG5ldyBUcmVlKCk7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgQHByaXZhdGUgYnV0IGl0J3MgdXNlZCBieSB0ZXN0X2FjY2Vzcy5qcyBhbmQgaW50ZXJuYWwuanNcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXyA9IG51bGw7XHJcbiAgICAgICAgLy8gVGhpcyBrZXkgaXMgaW50ZW50aW9uYWxseSBub3QgdXBkYXRlZCBpZiBSZXBvSW5mbyBpcyBsYXRlciBjaGFuZ2VkIG9yIHJlcGxhY2VkXHJcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnJlcG9JbmZvXy50b1VSTFN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVVJMIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3Qgb2YgdGhpcyBGaXJlYmFzZS5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5yZXBvSW5mb18uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgKyB0aGlzLnJlcG9JbmZvXy5ob3N0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvU3RhcnQocmVwbywgYXBwSWQsIGF1dGhPdmVycmlkZSkge1xyXG4gICAgcmVwby5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG8ucmVwb0luZm9fKTtcclxuICAgIGlmIChyZXBvLmZvcmNlUmVzdENsaWVudF8gfHwgYmVpbmdDcmF3bGVkKCkpIHtcclxuICAgICAgICByZXBvLnNlcnZlcl8gPSBuZXcgUmVhZG9ubHlSZXN0Q2xpZW50KHJlcG8ucmVwb0luZm9fLCAocGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKTtcclxuICAgICAgICB9LCByZXBvLmF1dGhUb2tlblByb3ZpZGVyXywgcmVwby5hcHBDaGVja1Byb3ZpZGVyXyk7XHJcbiAgICAgICAgLy8gTWlub3IgaGFjazogRmlyZSBvbkNvbm5lY3QgaW1tZWRpYXRlbHksIHNpbmNlIHRoZXJlJ3Mgbm8gYWN0dWFsIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXBvT25Db25uZWN0U3RhdHVzKHJlcG8sIC8qIGNvbm5lY3RTdGF0dXM9ICovIHRydWUpLCAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFZhbGlkYXRlIGF1dGhPdmVycmlkZVxyXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJyAmJiBhdXRoT3ZlcnJpZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRoT3ZlcnJpZGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb2JqZWN0cyBhcmUgc3VwcG9ydGVkIGZvciBvcHRpb24gZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoYXV0aE92ZXJyaWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF1dGhPdmVycmlkZSBwcm92aWRlZDogJyArIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fID0gbmV3IFBlcnNpc3RlbnRDb25uZWN0aW9uKHJlcG8ucmVwb0luZm9fLCBhcHBJZCwgKHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25EYXRhVXBkYXRlKHJlcG8sIHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZyk7XHJcbiAgICAgICAgfSwgKGNvbm5lY3RTdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCBjb25uZWN0U3RhdHVzKTtcclxuICAgICAgICB9LCAodXBkYXRlcykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25TZXJ2ZXJJbmZvVXBkYXRlKHJlcG8sIHVwZGF0ZXMpO1xyXG4gICAgICAgIH0sIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfLCByZXBvLmFwcENoZWNrUHJvdmlkZXJfLCBhdXRoT3ZlcnJpZGUpO1xyXG4gICAgICAgIHJlcG8uc2VydmVyXyA9IHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fO1xyXG4gICAgfVxyXG4gICAgcmVwby5hdXRoVG9rZW5Qcm92aWRlcl8uYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcih0b2tlbiA9PiB7XHJcbiAgICAgICAgcmVwby5zZXJ2ZXJfLnJlZnJlc2hBdXRoVG9rZW4odG9rZW4pO1xyXG4gICAgfSk7XHJcbiAgICByZXBvLmFwcENoZWNrUHJvdmlkZXJfLmFkZFRva2VuQ2hhbmdlTGlzdGVuZXIocmVzdWx0ID0+IHtcclxuICAgICAgICByZXBvLnNlcnZlcl8ucmVmcmVzaEFwcENoZWNrVG9rZW4ocmVzdWx0LnRva2VuKTtcclxuICAgIH0pO1xyXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgUmVwb3MgZm9yIHRoZSBzYW1lIHJlcG9JbmZvIChpLmUuIHRoZXJlIGFyZSBtdWx0aXBsZSBGaXJlYmFzZS5Db250ZXh0cyBiZWluZyB1c2VkKSxcclxuICAgIC8vIHdlIG9ubHkgd2FudCB0byBjcmVhdGUgb25lIFN0YXRzUmVwb3J0ZXIuICBBcyBzdWNoLCB3ZSdsbCByZXBvcnQgc3RhdHMgb3ZlciB0aGUgZmlyc3QgUmVwbyBjcmVhdGVkLlxyXG4gICAgcmVwby5zdGF0c1JlcG9ydGVyXyA9IHN0YXRzTWFuYWdlckdldE9yQ3JlYXRlUmVwb3J0ZXIocmVwby5yZXBvSW5mb18sICgpID0+IG5ldyBTdGF0c1JlcG9ydGVyKHJlcG8uc3RhdHNfLCByZXBvLnNlcnZlcl8pKTtcclxuICAgIC8vIFVzZWQgZm9yIC5pbmZvLlxyXG4gICAgcmVwby5pbmZvRGF0YV8gPSBuZXcgU25hcHNob3RIb2xkZXIoKTtcclxuICAgIHJlcG8uaW5mb1N5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbmZvRXZlbnRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSByZXBvLmluZm9EYXRhXy5nZXROb2RlKHF1ZXJ5Ll9wYXRoKTtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3NzaWJseSBhIGhhY2ssIGJ1dCB3ZSBoYXZlIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIC5pbmZvIGVuZHBvaW50cy4gV2UgZG9uJ3QgcmFpc2UgbnVsbCBldmVudHNcclxuICAgICAgICAgICAgLy8gb24gaW5pdGlhbCBkYXRhLi4uXHJcbiAgICAgICAgICAgIGlmICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGluZm9FdmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnkuX3BhdGgsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgnb2snKTtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvRXZlbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcExpc3RlbmluZzogKCkgPT4geyB9XHJcbiAgICB9KTtcclxuICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sICdjb25uZWN0ZWQnLCBmYWxzZSk7XHJcbiAgICByZXBvLnNlcnZlclN5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG8uc2VydmVyXy5saXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgKHN0YXR1cywgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gb25Db21wbGV0ZShzdGF0dXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBObyBzeW5jaHJvbm91cyBldmVudHMgZm9yIG5ldHdvcmstYmFja2VkIHN5bmMgdHJlZXNcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcExpc3RlbmluZzogKHF1ZXJ5LCB0YWcpID0+IHtcclxuICAgICAgICAgICAgcmVwby5zZXJ2ZXJfLnVubGlzdGVuKHF1ZXJ5LCB0YWcpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMsIHRha2luZyB0aGUgc2VydmVyIG9mZnNldCBpbnRvIGFjY291bnQgaWYgd2UgaGF2ZSBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvU2VydmVyVGltZShyZXBvKSB7XHJcbiAgICBjb25zdCBvZmZzZXROb2RlID0gcmVwby5pbmZvRGF0YV8uZ2V0Tm9kZShuZXcgUGF0aCgnLmluZm8vc2VydmVyVGltZU9mZnNldCcpKTtcclxuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldE5vZGUudmFsKCkgfHwgMDtcclxuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIG9mZnNldDtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgU2VydmVyVmFsdWVzIHVzaW5nIHNvbWUgdmFyaWFibGVzIGZyb20gdGhlIHJlcG8gb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZVdpdGhWYWx1ZXMoe1xyXG4gICAgICAgIHRpbWVzdGFtcDogcmVwb1NlcnZlclRpbWUocmVwbylcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgYnkgcmVhbHRpbWUgd2hlbiB3ZSBnZXQgbmV3IG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSB7XHJcbiAgICAvLyBGb3IgdGVzdGluZy5cclxuICAgIHJlcG8uZGF0YVVwZGF0ZUNvdW50Kys7XHJcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgocGF0aFN0cmluZyk7XHJcbiAgICBkYXRhID0gcmVwby5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfXHJcbiAgICAgICAgPyByZXBvLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18ocGF0aFN0cmluZywgZGF0YSlcclxuICAgICAgICA6IGRhdGE7XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgaWYgKGlzTWVyZ2UpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFnZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSwgKHJhdykgPT4gbm9kZUZyb21KU09OKHJhdykpO1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgdGFnZ2VkQ2hpbGRyZW4sIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdnZWRTbmFwID0gbm9kZUZyb21KU09OKGRhdGEpO1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHRhZ2dlZFNuYXAsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNNZXJnZSkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRDaGlsZHJlbiA9IG1hcChkYXRhLCAocmF3KSA9PiBub2RlRnJvbUpTT04ocmF3KSk7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVNlcnZlck1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc25hcCA9IG5vZGVGcm9tSlNPTihkYXRhKTtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBzbmFwKTtcclxuICAgIH1cclxuICAgIGxldCBhZmZlY3RlZFBhdGggPSBwYXRoO1xyXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBhIGxpc3RlbmVyIG91dHN0YW5kaW5nIGZvciBlYWNoIHRyYW5zYWN0aW9uLCByZWNlaXZpbmcgYW55IGV2ZW50c1xyXG4gICAgICAgIC8vIGlzIGEgcHJveHkgZm9yIHNvbWUgY2hhbmdlIGhhdmluZyBvY2N1cnJlZC5cclxuICAgICAgICBhZmZlY3RlZFBhdGggPSByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBhZmZlY3RlZFBhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCBjb25uZWN0U3RhdHVzKSB7XHJcbiAgICByZXBvVXBkYXRlSW5mbyhyZXBvLCAnY29ubmVjdGVkJywgY29ubmVjdFN0YXR1cyk7XHJcbiAgICBpZiAoY29ubmVjdFN0YXR1cyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXBvUnVuT25EaXNjb25uZWN0RXZlbnRzKHJlcG8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9PblNlcnZlckluZm9VcGRhdGUocmVwbywgdXBkYXRlcykge1xyXG4gICAgZWFjaCh1cGRhdGVzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sIGtleSwgdmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1VwZGF0ZUluZm8ocmVwbywgcGF0aFN0cmluZywgdmFsdWUpIHtcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aCgnLy5pbmZvLycgKyBwYXRoU3RyaW5nKTtcclxuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xyXG4gICAgcmVwby5pbmZvRGF0YV8udXBkYXRlU25hcHNob3QocGF0aCwgbmV3Tm9kZSk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uaW5mb1N5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKSB7XHJcbiAgICByZXR1cm4gcmVwby5uZXh0V3JpdGVJZF8rKztcclxufVxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgYGdldFZhbHVlYCBpcyB0byByZXR1cm4gdGhlIGxhdGVzdCBrbm93biB2YWx1ZVxyXG4gKiBzYXRpc2Z5aW5nIGBxdWVyeWAuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIHdpbGwgZmlyc3QgY2hlY2sgZm9yIGluLW1lbW9yeSBjYWNoZWQgdmFsdWVzXHJcbiAqIGJlbG9uZ2luZyB0byBhY3RpdmUgbGlzdGVuZXJzLiBJZiB0aGV5IGFyZSBmb3VuZCwgc3VjaCB2YWx1ZXNcclxuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIG1vc3QgdXAtdG8tZGF0ZS5cclxuICpcclxuICogSWYgdGhlIGNsaWVudCBpcyBub3QgY29ubmVjdGVkLCB0aGlzIG1ldGhvZCB3aWxsIHdhaXQgdW50aWwgdGhlXHJcbiAqICByZXBvIGhhcyBlc3RhYmxpc2hlZCBhIGNvbm5lY3Rpb24gYW5kIHRoZW4gcmVxdWVzdCB0aGUgdmFsdWUgZm9yIGBxdWVyeWAuXHJcbiAqIElmIHRoZSBjbGllbnQgaXMgbm90IGFibGUgdG8gcmV0cmlldmUgdGhlIHF1ZXJ5IHJlc3VsdCBmb3IgYW5vdGhlciByZWFzb24sXHJcbiAqIGl0IHJlcG9ydHMgYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzdXJmYWNlIGEgdmFsdWUgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dldFZhbHVlKHJlcG8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgLy8gT25seSBhY3RpdmUgcXVlcmllcyBhcmUgY2FjaGVkLiBUaGVyZSBpcyBubyBwZXJzaXN0ZWQgY2FjaGUuXHJcbiAgICBjb25zdCBjYWNoZWQgPSBzeW5jVHJlZUdldFNlcnZlclZhbHVlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSk7XHJcbiAgICBpZiAoY2FjaGVkICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVwby5zZXJ2ZXJfLmdldChxdWVyeSkudGhlbihwYXlsb2FkID0+IHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZUZyb21KU09OKHBheWxvYWQpLndpdGhJbmRleChxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVsb3cgd2Ugc2ltdWxhdGUgdGhlIGFjdGlvbnMgb2YgYW4gYG9ubHlPbmNlYCBgb25WYWx1ZSgpYCBldmVudCB3aGVyZTpcclxuICAgICAgICAgKiBBZGQgYW4gZXZlbnQgcmVnaXN0cmF0aW9uLFxyXG4gICAgICAgICAqIFVwZGF0ZSBkYXRhIGF0IHRoZSBwYXRoLFxyXG4gICAgICAgICAqIFJhaXNlIGFueSBldmVudHMsXHJcbiAgICAgICAgICogQ2xlYW51cCB0aGUgU3luY1RyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHRydWUpO1xyXG4gICAgICAgIGxldCBldmVudHM7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeS5fcGF0aCwgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnkuX3BhdGgsIG5vZGUsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogV2UgbmVlZCB0byByYWlzZSBldmVudHMgaW4gdGhlIHNjZW5hcmlvIHdoZXJlIGBnZXQoKWAgaXMgY2FsbGVkIGF0IGEgcGFyZW50IHBhdGgsIGFuZFxyXG4gICAgICAgICAqIHdoaWxlIHRoZSBgZ2V0KClgIGlzIHBlbmRpbmcsIGBvblZhbHVlYCBpcyBjYWxsZWQgYXQgYSBjaGlsZCBsb2NhdGlvbi4gV2hpbGUgZ2V0KCkgaXMgd2FpdGluZ1xyXG4gICAgICAgICAqIGZvciB0aGUgZGF0YSwgYG9uVmFsdWVgIHdpbGwgcmVnaXN0ZXIgYSBuZXcgZXZlbnQuIFRoZW4sIGdldCgpIHdpbGwgY29tZSBiYWNrLCBhbmQgdXBkYXRlIHRoZSBzeW5jVHJlZVxyXG4gICAgICAgICAqIGFuZCBpdHMgY29ycmVzcG9uZGluZyBzZXJ2ZXJDYWNoZSwgaW5jbHVkaW5nIHRoZSBjaGlsZCBsb2NhdGlvbiB3aGVyZSBgb25WYWx1ZWAgaXMgY2FsbGVkLiBUaGVuLFxyXG4gICAgICAgICAqIGBvblZhbHVlYCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50IGZyb20gdGhlIHNlcnZlciwgYnV0IGxvb2sgYXQgdGhlIHN5bmNUcmVlIGFuZCBzZWUgdGhhdCB0aGUgZGF0YSByZWNlaXZlZFxyXG4gICAgICAgICAqIGZyb20gdGhlIHNlcnZlciBpcyBhbHJlYWR5IGF0IHRoZSBTeW5jUG9pbnQsIGFuZCBzbyB0aGUgYG9uVmFsdWVgIGNhbGxiYWNrIHdpbGwgbmV2ZXIgZ2V0IGZpcmVkLlxyXG4gICAgICAgICAqIENhbGxpbmcgYGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKClgIGlzIHRoZSBjb3JyZWN0IHdheSB0byBwcm9wYWdhdGUgdGhlIGV2ZW50cyBhbmRcclxuICAgICAgICAgKiBlbnN1cmUgdGhlIGNvcnJlc3BvbmRpbmcgY2hpbGQgZXZlbnRzIHdpbGwgZ2V0IGZpcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG4gICAgICAgIHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgIHJlcG9Mb2cocmVwbywgJ2dldCBmb3IgcXVlcnkgJyArIHN0cmluZ2lmeShxdWVyeSkgKyAnIGZhaWxlZDogJyArIGVycik7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVwbywgcGF0aCwgbmV3VmFsLCBuZXdQcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAnc2V0Jywge1xyXG4gICAgICAgIHBhdGg6IHBhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICB2YWx1ZTogbmV3VmFsLFxyXG4gICAgICAgIHByaW9yaXR5OiBuZXdQcmlvcml0eVxyXG4gICAgfSk7XHJcbiAgICAvLyBUT0RPOiBPcHRpbWl6ZSB0aGlzIGJlaGF2aW9yIHRvIGVpdGhlciAoYSkgc3RvcmUgZmxhZyB0byBza2lwIHJlc29sdmluZyB3aGVyZSBwb3NzaWJsZSBhbmQgLyBvclxyXG4gICAgLy8gKGIpIHN0b3JlIHVucmVzb2x2ZWQgcGF0aHMgb24gSlNPTiBwYXJzZVxyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT04obmV3VmFsLCBuZXdQcmlvcml0eSk7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCk7XHJcbiAgICBjb25zdCBuZXdOb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcyk7XHJcbiAgICBjb25zdCB3cml0ZUlkID0gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUsIHdyaXRlSWQsIHRydWUpO1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKHJlcG8uZXZlbnRRdWV1ZV8sIGV2ZW50cyk7XHJcbiAgICByZXBvLnNlcnZlcl8ucHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZVVucmVzb2x2ZWQudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XHJcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oJ3NldCBhdCAnICsgcGF0aCArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2xlYXJFdmVudHMgPSBzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgd3JpdGVJZCwgIXN1Y2Nlc3MpO1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGNsZWFyRXZlbnRzKTtcclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpO1xyXG4gICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgYWZmZWN0ZWRQYXRoLCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1VwZGF0ZShyZXBvLCBwYXRoLCBjaGlsZHJlblRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ3VwZGF0ZScsIHsgcGF0aDogcGF0aC50b1N0cmluZygpLCB2YWx1ZTogY2hpbGRyZW5Ub01lcmdlIH0pO1xyXG4gICAgLy8gU3RhcnQgd2l0aCBvdXIgZXhpc3RpbmcgZGF0YSBhbmQgbWVyZ2UgZWFjaCBjaGlsZCBpbnRvIGl0LlxyXG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcclxuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgIGNvbnN0IGNoYW5nZWRDaGlsZHJlbiA9IHt9O1xyXG4gICAgZWFjaChjaGlsZHJlblRvTWVyZ2UsIChjaGFuZ2VkS2V5LCBjaGFuZ2VkVmFsdWUpID0+IHtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNoYW5nZWRDaGlsZHJlbltjaGFuZ2VkS2V5XSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShwYXRoQ2hpbGQocGF0aCwgY2hhbmdlZEtleSksIG5vZGVGcm9tSlNPTihjaGFuZ2VkVmFsdWUpLCByZXBvLnNlcnZlclN5bmNUcmVlXywgc2VydmVyVmFsdWVzKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKCFlbXB0eSkge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKTtcclxuICAgICAgICBldmVudFF1ZXVlUXVldWVFdmVudHMocmVwby5ldmVudFF1ZXVlXywgZXZlbnRzKTtcclxuICAgICAgICByZXBvLnNlcnZlcl8ubWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XHJcbiAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgd2FybigndXBkYXRlIGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNsZWFyRXZlbnRzID0gc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHdyaXRlSWQsICFzdWNjZXNzKTtcclxuICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gY2xlYXJFdmVudHMubGVuZ3RoID4gMCA/IHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKSA6IHBhdGg7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIGFmZmVjdGVkUGF0aCwgY2xlYXJFdmVudHMpO1xyXG4gICAgICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoYW5nZWRQYXRoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoQ2hpbGQocGF0aCwgY2hhbmdlZFBhdGgpKTtcclxuICAgICAgICAgICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgcXVldWVkIHRoZSBldmVudHMgYWJvdmUsIHNvIGp1c3QgZmx1c2ggdGhlIHF1ZXVlIGhlcmVcclxuICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBbXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsb2coXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpO1xyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsICdvaycsIHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIHN0b3JlZCB1cCBpbiB0aGUgb25EaXNjb25uZWN0XyB0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1J1bk9uRGlzY29ubmVjdEV2ZW50cyhyZXBvKSB7XHJcbiAgICByZXBvTG9nKHJlcG8sICdvbkRpc2Nvbm5lY3RFdmVudHMnKTtcclxuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgIGNvbnN0IHJlc29sdmVkT25EaXNjb25uZWN0VHJlZSA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUocmVwby5vbkRpc2Nvbm5lY3RfLCBuZXdFbXB0eVBhdGgoKSwgKHBhdGgsIG5vZGUpID0+IHtcclxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShwYXRoLCBub2RlLCByZXBvLnNlcnZlclN5bmNUcmVlXywgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUsIHBhdGgsIHJlc29sdmVkKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUocmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlLCBuZXdFbXB0eVBhdGgoKSwgKHBhdGgsIHNuYXApID0+IHtcclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHNuYXApKTtcclxuICAgICAgICBjb25zdCBhZmZlY3RlZFBhdGggPSByZXBvQWJvcnRUcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICAgICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHJlcG8ub25EaXNjb25uZWN0XyA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgbmV3RW1wdHlQYXRoKCksIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uRGlzY29ubmVjdENhbmNlbChyZXBvLCBwYXRoLCBvbkNvbXBsZXRlKSB7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0Q2FuY2VsKHBhdGgudG9TdHJpbmcoKSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RTZXQocmVwbywgcGF0aCwgdmFsdWUsIG9uQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xyXG4gICAgcmVwby5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0U2V0V2l0aFByaW9yaXR5KHJlcG8sIHBhdGgsIHZhbHVlLCBwcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSwgcHJpb3JpdHkpO1xyXG4gICAgcmVwby5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0VXBkYXRlKHJlcG8sIHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xyXG4gICAgaWYgKGlzRW1wdHkoY2hpbGRyZW5Ub01lcmdlKSkge1xyXG4gICAgICAgIGxvZyhcIm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIik7XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgJ29rJywgdW5kZWZpbmVkKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0TWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHJlcG8ub25EaXNjb25uZWN0XywgcGF0aENoaWxkKHBhdGgsIGNoaWxkTmFtZSksIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9BZGRFdmVudENhbGxiYWNrRm9yUXVlcnkocmVwbywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICBsZXQgZXZlbnRzO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChxdWVyeS5fcGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShyZXBvLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIC8vIFRoZXNlIGFyZSBndWFyYW50ZWVkIG5vdCB0byByYWlzZSBldmVudHMsIHNpbmNlIHdlJ3JlIG5vdCBwYXNzaW5nIGluIGEgY2FuY2VsRXJyb3IuIEhvd2V2ZXIsIHdlIGNhbiBmdXR1cmUtcHJvb2ZcclxuICAgIC8vIGEgbGl0dGxlIGJpdCBieSBoYW5kbGluZyB0aGUgcmV0dXJuIHZhbHVlcyBhbnl3YXlzLlxyXG4gICAgbGV0IGV2ZW50cztcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocXVlcnkuX3BhdGgpID09PSAnLmluZm8nKSB7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihyZXBvLmluZm9TeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9JbnRlcnJ1cHQocmVwbykge1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaW50ZXJydXB0KElOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9SZXN1bWUocmVwbykge1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8ucmVzdW1lKElOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9Mb2cocmVwbywgLi4udmFyQXJncykge1xyXG4gICAgbGV0IHByZWZpeCA9ICcnO1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcHJlZml4ID0gcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaWQgKyAnOic7XHJcbiAgICB9XHJcbiAgICBsb2cocHJlZml4LCAuLi52YXJBcmdzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBjYWxsYmFjaywgc3RhdHVzLCBlcnJvclJlYXNvbikge1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAoc3RhdHVzIHx8ICdlcnJvcicpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZWFzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICc6ICcgKyBlcnJvclJlYXNvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24sIGFkZHMgaXQgdG8gdGhlIHRyYW5zYWN0aW9ucyB3ZSdyZSB0cmFja2luZywgYW5kXHJcbiAqIHNlbmRzIGl0IHRvIHRoZSBzZXJ2ZXIgaWYgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCBhdCB3aGljaCB0byBkbyB0cmFuc2FjdGlvbi5cclxuICogQHBhcmFtIHRyYW5zYWN0aW9uVXBkYXRlIC0gVXBkYXRlIGNhbGxiYWNrLlxyXG4gKiBAcGFyYW0gb25Db21wbGV0ZSAtIENvbXBsZXRpb24gY2FsbGJhY2suXHJcbiAqIEBwYXJhbSB1bndhdGNoZXIgLSBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHRyYW5zYWN0aW9uIG5vIGxvbmdlclxyXG4gKiBuZWVkIGRhdGEgdXBkYXRlcyBmb3IgYHBhdGhgLlxyXG4gKiBAcGFyYW0gYXBwbHlMb2NhbGx5IC0gV2hldGhlciBvciBub3QgdG8gbWFrZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyB2aXNpYmxlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvU3RhcnRUcmFuc2FjdGlvbihyZXBvLCBwYXRoLCB0cmFuc2FjdGlvblVwZGF0ZSwgb25Db21wbGV0ZSwgdW53YXRjaGVyLCBhcHBseUxvY2FsbHkpIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ3RyYW5zYWN0aW9uIG9uICcgKyBwYXRoKTtcclxuICAgIC8vIEluaXRpYWxpemUgdHJhbnNhY3Rpb24uXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHVwZGF0ZTogdHJhbnNhY3Rpb25VcGRhdGUsXHJcbiAgICAgICAgb25Db21wbGV0ZSxcclxuICAgICAgICAvLyBPbmUgb2YgVHJhbnNhY3Rpb25TdGF0dXMgZW51bXMuXHJcbiAgICAgICAgc3RhdHVzOiBudWxsLFxyXG4gICAgICAgIC8vIFVzZWQgd2hlbiBjb21iaW5pbmcgdHJhbnNhY3Rpb25zIGF0IGRpZmZlcmVudCBsb2NhdGlvbnMgdG8gZmlndXJlIG91dFxyXG4gICAgICAgIC8vIHdoaWNoIG9uZSBnb2VzIGZpcnN0LlxyXG4gICAgICAgIG9yZGVyOiBMVUlER2VuZXJhdG9yKCksXHJcbiAgICAgICAgLy8gV2hldGhlciB0byByYWlzZSBsb2NhbCBldmVudHMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgYXBwbHlMb2NhbGx5LFxyXG4gICAgICAgIC8vIENvdW50IG9mIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIHJldHJpZWQgdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgIHJldHJ5Q291bnQ6IDAsXHJcbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2FsbCB0byBjbGVhbiB1cCBvdXIgLm9uKCkgbGlzdGVuZXIuXHJcbiAgICAgICAgdW53YXRjaGVyLFxyXG4gICAgICAgIC8vIFN0b3JlcyB3aHkgYSB0cmFuc2FjdGlvbiB3YXMgYWJvcnRlZC5cclxuICAgICAgICBhYm9ydFJlYXNvbjogbnVsbCxcclxuICAgICAgICBjdXJyZW50V3JpdGVJZDogbnVsbCxcclxuICAgICAgICBjdXJyZW50SW5wdXRTbmFwc2hvdDogbnVsbCxcclxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSYXc6IG51bGwsXHJcbiAgICAgICAgY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQ6IG51bGxcclxuICAgIH07XHJcbiAgICAvLyBSdW4gdHJhbnNhY3Rpb24gaW5pdGlhbGx5LlxyXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHBhdGgsIHVuZGVmaW5lZCk7XHJcbiAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnRTdGF0ZTtcclxuICAgIGNvbnN0IG5ld1ZhbCA9IHRyYW5zYWN0aW9uLnVwZGF0ZShjdXJyZW50U3RhdGUudmFsKCkpO1xyXG4gICAgaWYgKG5ld1ZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gQWJvcnQgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgdHJhbnNhY3Rpb24udW53YXRjaGVyKCk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbnVsbDtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25Db21wbGV0ZShudWxsLCBmYWxzZSwgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3VmFsLCB0cmFuc2FjdGlvbi5wYXRoKTtcclxuICAgICAgICAvLyBNYXJrIGFzIHJ1biBhbmQgYWRkIHRvIG91ciBxdWV1ZS5cclxuICAgICAgICB0cmFuc2FjdGlvbi5zdGF0dXMgPSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLztcclxuICAgICAgICBjb25zdCBxdWV1ZU5vZGUgPSB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZVF1ZXVlID0gdHJlZUdldFZhbHVlKHF1ZXVlTm9kZSkgfHwgW107XHJcbiAgICAgICAgbm9kZVF1ZXVlLnB1c2godHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHRyZWVTZXRWYWx1ZShxdWV1ZU5vZGUsIG5vZGVRdWV1ZSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHZpc2libGVEYXRhIGFuZCByYWlzZSBldmVudHNcclxuICAgICAgICAvLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IHJhaXNlIGV2ZW50cyBhZnRlciB1cGRhdGluZyBhbGwgb2Ygb3VyXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSB1c2VyIGNvdWxkIHN0YXJ0IG5ldyB0cmFuc2FjdGlvbnMgZnJvbSB0aGVcclxuICAgICAgICAvLyBldmVudCBjYWxsYmFja3MuXHJcbiAgICAgICAgbGV0IHByaW9yaXR5Rm9yTm9kZTtcclxuICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgbmV3VmFsICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIGNvbnRhaW5zKG5ld1ZhbCwgJy5wcmlvcml0eScpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IHNhZmVHZXQobmV3VmFsLCAnLnByaW9yaXR5Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydChpc1ZhbGlkUHJpb3JpdHkocHJpb3JpdHlGb3JOb2RlKSwgJ0ludmFsaWQgcHJpb3JpdHkgcmV0dXJuZWQgYnkgdHJhbnNhY3Rpb24uICcgK1xyXG4gICAgICAgICAgICAgICAgJ1ByaW9yaXR5IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoKSB8fFxyXG4gICAgICAgICAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTihuZXdWYWwsIHByaW9yaXR5Rm9yTm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3Tm9kZVVucmVzb2x2ZWQsIGN1cnJlbnRTdGF0ZSwgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBuZXdOb2RlVW5yZXNvbHZlZDtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG5ld05vZGU7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUsIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cmFuc2FjdGlvbi5hcHBseUxvY2FsbHkpO1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBleGNsdWRlU2V0cyAtIEEgc3BlY2lmaWMgc2V0IHRvIGV4Y2x1ZGVcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCBwYXRoLCBleGNsdWRlU2V0cykge1xyXG4gICAgcmV0dXJuIChzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIGV4Y2x1ZGVTZXRzKSB8fFxyXG4gICAgICAgIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxufVxyXG4vKipcclxuICogU2VuZHMgYW55IGFscmVhZHktcnVuIHRyYW5zYWN0aW9ucyB0aGF0IGFyZW4ndCB3YWl0aW5nIGZvciBvdXRzdGFuZGluZ1xyXG4gKiB0cmFuc2FjdGlvbnMgdG8gY29tcGxldGUuXHJcbiAqXHJcbiAqIEV4dGVybmFsbHkgaXQncyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIGJ1dCBpdCBjYWxscyBpdHNlbGYgcmVjdXJzaXZlbHlcclxuICogd2l0aCBhIHBhcnRpY3VsYXIgdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byByZWN1cnNlIHRocm91Z2ggdGhlIHRyZWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlIC0gdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byBzdGFydCBhdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgbm9kZSA9IHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKSB7XHJcbiAgICAvLyBCZWZvcmUgcmVjdXJzaW5nLCBtYWtlIHN1cmUgYW55IGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgYXJlIHJlbW92ZWQuXHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXBvUHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHJlZUdldFZhbHVlKG5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSByZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIG5vZGUpO1xyXG4gICAgICAgIGFzc2VydChxdWV1ZS5sZW5ndGggPiAwLCAnU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZScpO1xyXG4gICAgICAgIGNvbnN0IGFsbFJ1biA9IHF1ZXVlLmV2ZXJ5KCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLyk7XHJcbiAgICAgICAgLy8gSWYgdGhleSdyZSBhbGwgcnVuIChhbmQgbm90IHNlbnQpLCB3ZSBjYW4gc2VuZCB0aGVtLiAgRWxzZSwgd2UgbXVzdCB3YWl0LlxyXG4gICAgICAgIGlmIChhbGxSdW4pIHtcclxuICAgICAgICAgICAgcmVwb1NlbmRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHRyZWVHZXRQYXRoKG5vZGUpLCBxdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJlZUhhc0NoaWxkcmVuKG5vZGUpKSB7XHJcbiAgICAgICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGlzdCBvZiBydW4gdHJhbnNhY3Rpb25zLCBzZW5kIHRoZW0gdG8gdGhlIHNlcnZlciBhbmQgdGhlbiBoYW5kbGVcclxuICogdGhlIHJlc3VsdCAoc3VjY2VzcyBvciBmYWlsdXJlKS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgbG9jYXRpb24gb2YgdGhlIHF1ZXVlLlxyXG4gKiBAcGFyYW0gcXVldWUgLSBRdWV1ZSBvZiB0cmFuc2FjdGlvbnMgdW5kZXIgdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZW5kVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBwYXRoLCBxdWV1ZSkge1xyXG4gICAgLy8gTWFyayB0cmFuc2FjdGlvbnMgYXMgc2VudCBhbmQgaW5jcmVtZW50IHJldHJ5IGNvdW50IVxyXG4gICAgY29uc3Qgc2V0c1RvSWdub3JlID0gcXVldWUubWFwKHR4biA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHR4bi5jdXJyZW50V3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGF0ZXN0U3RhdGUgPSByZXBvR2V0TGF0ZXN0U3RhdGUocmVwbywgcGF0aCwgc2V0c1RvSWdub3JlKTtcclxuICAgIGxldCBzbmFwVG9TZW5kID0gbGF0ZXN0U3RhdGU7XHJcbiAgICBjb25zdCBsYXRlc3RIYXNoID0gbGF0ZXN0U3RhdGUuaGFzaCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHR4biA9IHF1ZXVlW2ldO1xyXG4gICAgICAgIGFzc2VydCh0eG4uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLywgJ3RyeVRvU2VuZFRyYW5zYWN0aW9uUXVldWVfOiBpdGVtcyBpbiBxdWV1ZSBzaG91bGQgYWxsIGJlIHJ1bi4nKTtcclxuICAgICAgICB0eG4uc3RhdHVzID0gMSAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UICovO1xyXG4gICAgICAgIHR4bi5yZXRyeUNvdW50Kys7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGgsIHR4bi5wYXRoKTtcclxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgdGhlIG91dHB1dCBzbmFwc2hvdCBtdXN0IGJlIGRlZmluZWQuXHJcbiAgICAgICAgc25hcFRvU2VuZCA9IHNuYXBUb1NlbmQudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoIC8qKiBAdHlwZSB7IU5vZGV9ICovLCB0eG4uY3VycmVudE91dHB1dFNuYXBzaG90UmF3KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGFUb1NlbmQgPSBzbmFwVG9TZW5kLnZhbCh0cnVlKTtcclxuICAgIGNvbnN0IHBhdGhUb1NlbmQgPSBwYXRoO1xyXG4gICAgLy8gU2VuZCB0aGUgcHV0LlxyXG4gICAgcmVwby5zZXJ2ZXJfLnB1dChwYXRoVG9TZW5kLnRvU3RyaW5nKCksIGRhdGFUb1NlbmQsIChzdGF0dXMpID0+IHtcclxuICAgICAgICByZXBvTG9nKHJlcG8sICd0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2UnLCB7XHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGhUb1NlbmQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgc3RhdHVzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgLy8gUXVldWUgdXAgdGhlIGNhbGxiYWNrcyBhbmQgZmlyZSB0aGVtIGFmdGVyIGNsZWFuaW5nIHVwIGFsbCBvZiBvdXJcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmVcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIG9yIHNldHMuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSAyIC8qIFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCAqLztcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5ldmVyIHVuc2V0IHRoZSBvdXRwdXQgc25hcHNob3QsIGFuZCBnaXZlbiB0aGF0IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKCgpID0+IHF1ZXVlW2ldLm9uQ29tcGxldGUobnVsbCwgdHJ1ZSwgcXVldWVbaV0uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdyByZW1vdmUgdGhlIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMuXHJcbiAgICAgICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCkpO1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgcGVuZGluZyB0cmFuc2FjdGlvbnMgdGhhdCB3ZSBjYW4gbm93IHNlbmQuXHJcbiAgICAgICAgICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pO1xyXG4gICAgICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBldmVudHMpO1xyXG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB0cmlnZ2VyIG9uQ29tcGxldGUgY2FsbGJhY2tzLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFyZSBubyBsb25nZXIgc2VudC4gIFVwZGF0ZSB0aGVpciBzdGF0dXMgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2RhdGFzdGFsZScpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSAzIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ3RyYW5zYWN0aW9uIGF0ICcgKyBwYXRoVG9TZW5kLnRvU3RyaW5nKCkgKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5hYm9ydFJlYXNvbiA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgbGF0ZXN0SGFzaCk7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmRzIGFsbCB0cmFuc2FjdGlvbnMgZGVwZW5kZW50IG9uIHRoZSBkYXRhIGF0IGNoYW5nZWRQYXRoIGFuZCByZXJ1bnMgdGhlbS5cclxuICpcclxuICogU2hvdWxkIGJlIGNhbGxlZCBhbnkgdGltZSBjYWNoZWQgZGF0YSBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBSZXR1cm4gdGhlIGhpZ2hlc3QgcGF0aCB0aGF0IHdhcyBhZmZlY3RlZCBieSByZXJ1bm5pbmcgdHJhbnNhY3Rpb25zLiBUaGlzXHJcbiAqIGlzIHRoZSBwYXRoIGF0IHdoaWNoIGV2ZW50cyBuZWVkIHRvIGJlIHJhaXNlZCBmb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGFuZ2VkUGF0aCAtIFRoZSBwYXRoIGluIG1lcmdlZERhdGEgdGhhdCBjaGFuZ2VkLlxyXG4gKiBAcmV0dXJucyBUaGUgcm9vdG1vc3QgcGF0aCB0aGF0IHdhcyBhZmZlY3RlZCBieSByZXJ1bm5pbmcgdHJhbnNhY3Rpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGNoYW5nZWRQYXRoKSB7XHJcbiAgICBjb25zdCByb290TW9zdFRyYW5zYWN0aW9uTm9kZSA9IHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBjaGFuZ2VkUGF0aCk7XHJcbiAgICBjb25zdCBwYXRoID0gdHJlZUdldFBhdGgocm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgY29uc3QgcXVldWUgPSByZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlKTtcclxuICAgIHJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUocmVwbywgcXVldWUsIHBhdGgpO1xyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYWxsIHRoZSB3b3JrIG9mIHJlcnVubmluZyB0cmFuc2FjdGlvbnMgKGFzIHdlbGwgYXMgY2xlYW5zIHVwIGFib3J0ZWRcclxuICogdHJhbnNhY3Rpb25zIGFuZCB3aGF0bm90KS5cclxuICpcclxuICogQHBhcmFtIHF1ZXVlIC0gVGhlIHF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB0byBydW4uXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdGhlIHF1ZXVlIGlzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUocmVwbywgcXVldWUsIHBhdGgpIHtcclxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8hXHJcbiAgICB9XHJcbiAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yXHJcbiAgICAvLyBzZXRzLlxyXG4gICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAvLyBJZ25vcmUgYWxsIG9mIHRoZSBzZXRzIHdlJ3JlIGdvaW5nIHRvIHJlLXJ1bi5cclxuICAgIGNvbnN0IHR4bnNUb1JlcnVuID0gcXVldWUuZmlsdGVyKHEgPT4ge1xyXG4gICAgICAgIHJldHVybiBxLnN0YXR1cyA9PT0gMCAvKiBUcmFuc2FjdGlvblN0YXR1cy5SVU4gKi87XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHNldHNUb0lnbm9yZSA9IHR4bnNUb1JlcnVuLm1hcChxID0+IHtcclxuICAgICAgICByZXR1cm4gcS5jdXJyZW50V3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcXVldWVbaV07XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGgsIHRyYW5zYWN0aW9uLnBhdGgpO1xyXG4gICAgICAgIGxldCBhYm9ydFRyYW5zYWN0aW9uID0gZmFsc2UsIGFib3J0UmVhc29uO1xyXG4gICAgICAgIGFzc2VydChyZWxhdGl2ZVBhdGggIT09IG51bGwsICdyZXJ1blRyYW5zYWN0aW9uc1VuZGVyTm9kZV86IHJlbGF0aXZlUGF0aCBzaG91bGQgbm90IGJlIG51bGwuJyk7XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLykge1xyXG4gICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgYWJvcnRSZWFzb24gPSB0cmFuc2FjdGlvbi5hYm9ydFJlYXNvbjtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLykge1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ucmV0cnlDb3VudCA+PSBNQVhfVFJBTlNBQ1RJT05fUkVUUklFUykge1xyXG4gICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9ICdtYXhyZXRyeSc7XHJcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHJlcnVucyBhIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCB0cmFuc2FjdGlvbi5wYXRoLCBzZXRzVG9JZ25vcmUpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QgPSBjdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSBxdWV1ZVtpXS51cGRhdGUoY3VycmVudE5vZGUudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3RGF0YSwgdHJhbnNhY3Rpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0RhdGFOb2RlID0gbm9kZUZyb21KU09OKG5ld0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cGxpY2l0UHJpb3JpdHkgPSB0eXBlb2YgbmV3RGF0YSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKG5ld0RhdGEsICcucHJpb3JpdHknKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0UHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgb2xkIHByaW9yaXR5IGlmIHRoZXJlIHdhc24ndCBhIHByaW9yaXR5IGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhTm9kZSA9IG5ld0RhdGFOb2RlLnVwZGF0ZVByaW9yaXR5KGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRXcml0ZUlkID0gdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGVSZXNvbHZlZCA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3RGF0YU5vZGUsIGN1cnJlbnROb2RlLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld0RhdGFOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZVJlc29sdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkID0gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE11dGF0ZXMgc2V0c1RvSWdub3JlIGluIHBsYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0c1RvSWdub3JlLnNwbGljZShzZXRzVG9JZ25vcmUuaW5kZXhPZihvbGRXcml0ZUlkKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgdHJhbnNhY3Rpb24ucGF0aCwgbmV3Tm9kZVJlc29sdmVkLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJhbnNhY3Rpb24uYXBwbHlMb2NhbGx5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgb2xkV3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSAnbm9kYXRhJztcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgZXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKGFib3J0VHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gQWJvcnQuXHJcbiAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDIgLyogVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEICovO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmluZyBhIGxpc3RlbmVyIGNhbiB0cmlnZ2VyIHBydW5pbmcgd2hpY2ggY2FuIG11Y2sgd2l0aFxyXG4gICAgICAgICAgICAvLyBtZXJnZWREYXRhL3Zpc2libGVEYXRhIChhcyBpdCBwcnVuZXMgZGF0YSkuIFNvIGRlZmVyIHRoZSB1bndhdGNoZXJcclxuICAgICAgICAgICAgLy8gdW50aWwgd2UncmUgZG9uZS5cclxuICAgICAgICAgICAgKGZ1bmN0aW9uICh1bndhdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodW53YXRjaGVyLCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICAgICAgfSkocXVldWVbaV0udW53YXRjaGVyKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhYm9ydFJlYXNvbiA9PT0gJ25vZGF0YScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCgoKSA9PiBxdWV1ZVtpXS5vbkNvbXBsZXRlKG51bGwsIGZhbHNlLCBxdWV1ZVtpXS5jdXJyZW50SW5wdXRTbmFwc2hvdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goKCkgPT4gcXVldWVbaV0ub25Db21wbGV0ZShuZXcgRXJyb3IoYWJvcnRSZWFzb24pLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2xlYW4gdXAgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cclxuICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICAvLyBOb3cgZmlyZSBjYWxsYmFja3MsIG5vdyB0aGF0IHdlJ3JlIGluIGEgZ29vZCwga25vd24gc3RhdGUuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XHJcbiAgICB9XHJcbiAgICAvLyBUcnkgdG8gc2VuZCB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0IHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcm9vdG1vc3QgYW5jZXN0b3Igbm9kZSBvZiB0aGUgc3BlY2lmaWVkIHBhdGggdGhhdCBoYXMgYSBwZW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9uIG9uIGl0LCBvciBqdXN0IHJldHVybnMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBwYXRoIGlmIHRoZXJlIGFyZVxyXG4gKiBubyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvbiBhbnkgYW5jZXN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGxvY2F0aW9uIHRvIHN0YXJ0IGF0LlxyXG4gKiBAcmV0dXJucyBUaGUgcm9vdG1vc3Qgbm9kZSB3aXRoIGEgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUocmVwbywgcGF0aCkge1xyXG4gICAgbGV0IGZyb250O1xyXG4gICAgLy8gU3RhcnQgYXQgdGhlIHJvb3QgYW5kIHdhbGsgZGVlcGVyIGludG8gdGhlIHRyZWUgdG93YXJkcyBwYXRoIHVudGlsIHdlXHJcbiAgICAvLyBmaW5kIGEgbm9kZSB3aXRoIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxyXG4gICAgbGV0IHRyYW5zYWN0aW9uTm9kZSA9IHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfO1xyXG4gICAgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB3aGlsZSAoZnJvbnQgIT09IG51bGwgJiYgdHJlZUdldFZhbHVlKHRyYW5zYWN0aW9uTm9kZSkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uTm9kZSA9IHRyZWVTdWJUcmVlKHRyYW5zYWN0aW9uTm9kZSwgZnJvbnQpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25Ob2RlO1xyXG59XHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIHF1ZXVlIG9mIGFsbCB0cmFuc2FjdGlvbnMgYXQgb3IgYmVsb3cgdGhlIHNwZWNpZmllZFxyXG4gKiB0cmFuc2FjdGlvbk5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbk5vZGVcclxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgdHJhbnNhY3Rpb25Ob2RlKSB7XHJcbiAgICAvLyBXYWxrIGFueSBjaGlsZCB0cmFuc2FjdGlvbiBxdWV1ZXMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYSBzaW5nbGUgcXVldWUuXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvblF1ZXVlID0gW107XHJcbiAgICByZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlKHJlcG8sIHRyYW5zYWN0aW9uTm9kZSwgdHJhbnNhY3Rpb25RdWV1ZSk7XHJcbiAgICAvLyBTb3J0IHRoZW0gYnkgdGhlIG9yZGVyIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBjcmVhdGVkLlxyXG4gICAgdHJhbnNhY3Rpb25RdWV1ZS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcik7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25RdWV1ZTtcclxufVxyXG5mdW5jdGlvbiByZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlKHJlcG8sIG5vZGUsIHF1ZXVlKSB7XHJcbiAgICBjb25zdCBub2RlUXVldWUgPSB0cmVlR2V0VmFsdWUobm9kZSk7XHJcbiAgICBpZiAobm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlUXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcXVldWUucHVzaChub2RlUXVldWVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyZWVGb3JFYWNoQ2hpbGQobm9kZSwgY2hpbGQgPT4ge1xyXG4gICAgICAgIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgY2hpbGQsIHF1ZXVlKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgQ09NUExFVEVEIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGlzIG5vZGUgaW4gdGhlIHRyYW5zYWN0aW9uUXVldWVUcmVlXy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBub2RlKSB7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIGxldCB0byA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IDA7IGZyb20gPCBxdWV1ZS5sZW5ndGg7IGZyb20rKykge1xyXG4gICAgICAgICAgICBpZiAocXVldWVbZnJvbV0uc3RhdHVzICE9PSAyIC8qIFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVbdG9dID0gcXVldWVbZnJvbV07XHJcbiAgICAgICAgICAgICAgICB0bysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IHRvO1xyXG4gICAgICAgIHRyZWVTZXRWYWx1ZShub2RlLCBxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUgOiB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBjaGlsZE5vZGUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEFib3J0cyBhbGwgdHJhbnNhY3Rpb25zIG9uIGFuY2VzdG9ycyBvciBkZXNjZW5kYW50cyBvZiB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqIENhbGxlZCB3aGVuIGRvaW5nIGEgc2V0KCkgb3IgdXBkYXRlKCkgc2luY2Ugd2UgY29uc2lkZXIgdGhlbSBpbmNvbXBhdGlibGVcclxuICogd2l0aCB0cmFuc2FjdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCBmb3Igd2hpY2ggd2Ugd2FudCB0byBhYm9ydCByZWxhdGVkIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKSB7XHJcbiAgICBjb25zdCBhZmZlY3RlZFBhdGggPSB0cmVlR2V0UGF0aChyZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUocmVwbywgcGF0aCkpO1xyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25Ob2RlID0gdHJlZVN1YlRyZWUocmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8sIHBhdGgpO1xyXG4gICAgdHJlZUZvckVhY2hBbmNlc3Rvcih0cmFuc2FjdGlvbk5vZGUsIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlKHJlcG8sIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgdHJhbnNhY3Rpb25Ob2RlKTtcclxuICAgIHRyZWVGb3JFYWNoRGVzY2VuZGFudCh0cmFuc2FjdGlvbk5vZGUsIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlKHJlcG8sIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWZmZWN0ZWRQYXRoO1xyXG59XHJcbi8qKlxyXG4gKiBBYm9ydCB0cmFuc2FjdGlvbnMgc3RvcmVkIGluIHRoaXMgdHJhbnNhY3Rpb24gcXVldWUgbm9kZS5cclxuICpcclxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGFib3J0IHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSkge1xyXG4gICAgY29uc3QgcXVldWUgPSB0cmVlR2V0VmFsdWUobm9kZSk7XHJcbiAgICBpZiAocXVldWUpIHtcclxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZSB0aGUgY2FsbGJhY2sgY291bGQgdHJpZ2dlciBtb3JlIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIC8vIG9yIHNldHMuXHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgLy8gR28gdGhyb3VnaCBxdWV1ZS4gIEFueSBhbHJlYWR5LXNlbnQgdHJhbnNhY3Rpb25zIG11c3QgYmUgbWFya2VkIGZvclxyXG4gICAgICAgIC8vIGFib3J0LCB3aGlsZSB0aGUgdW5zZW50IG9uZXMgY2FuIGJlIGltbWVkaWF0ZWx5IGFib3J0ZWQgYW5kIHJlbW92ZWQuXHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBsYXN0U2VudCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gMyAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UX05FRURTX0FCT1JUICovKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gMSAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQobGFzdFNlbnQgPT09IGkgLSAxLCAnQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS4nKTtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50ID0gaTtcclxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdHJhbnNhY3Rpb24gZm9yIGFib3J0IHdoZW4gaXQgY29tZXMgYmFjay5cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDMgLyogVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gJ3NldCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQocXVldWVbaV0uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLywgJ1VuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0Jyk7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gYWJvcnQgaXQgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS51bndhdGNoZXIoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKHF1ZXVlW2ldLm9uQ29tcGxldGUuYmluZChudWxsLCBuZXcgRXJyb3IoJ3NldCcpLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0U2VudCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gV2UncmUgbm90IHdhaXRpbmcgZm9yIGFueSBzZW50IHRyYW5zYWN0aW9ucy4gIFdlIGNhbiBjbGVhciB0aGUgcXVldWUuXHJcbiAgICAgICAgICAgIHRyZWVTZXRWYWx1ZShub2RlLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFuc2FjdGlvbnMgd2UgYWJvcnRlZC5cclxuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gbGFzdFNlbnQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3cgZmlyZSB0aGUgY2FsbGJhY2tzLlxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHRyZWVHZXRQYXRoKG5vZGUpLCBldmVudHMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aFN0cmluZykge1xyXG4gICAgbGV0IHBhdGhTdHJpbmdEZWNvZGVkID0gJyc7XHJcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoU3RyaW5nLnNwbGl0KCcvJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwaWVjZXNbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgcGllY2UgPSBwaWVjZXNbaV07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwaWVjZSA9IGRlY29kZVVSSUNvbXBvbmVudChwaWVjZS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICBwYXRoU3RyaW5nRGVjb2RlZCArPSAnLycgKyBwaWVjZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFN0cmluZ0RlY29kZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIGtleSB2YWx1ZSBoYXNoXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGVRdWVyeShxdWVyeVN0cmluZykge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IHt9O1xyXG4gICAgaWYgKHF1ZXJ5U3RyaW5nLmNoYXJBdCgwKSA9PT0gJz8nKSB7XHJcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcXVlcnlTdHJpbmcuc3BsaXQoJyYnKSkge1xyXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga3YgPSBzZWdtZW50LnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgaWYgKGt2Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICByZXN1bHRzW2RlY29kZVVSSUNvbXBvbmVudChrdlswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KGt2WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgcXVlcnkgc2VnbWVudCAnJHtzZWdtZW50fScgaW4gcXVlcnkgJyR7cXVlcnlTdHJpbmd9J2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbmNvbnN0IHBhcnNlUmVwb0luZm8gPSBmdW5jdGlvbiAoZGF0YVVSTCwgbm9kZUFkbWluKSB7XHJcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBwYXJzZURhdGFiYXNlVVJMKGRhdGFVUkwpLCBuYW1lc3BhY2UgPSBwYXJzZWRVcmwubmFtZXNwYWNlO1xyXG4gICAgaWYgKHBhcnNlZFVybC5kb21haW4gPT09ICdmaXJlYmFzZS5jb20nKSB7XHJcbiAgICAgICAgZmF0YWwocGFyc2VkVXJsLmhvc3QgK1xyXG4gICAgICAgICAgICAnIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSA8WU9VUiBGSVJFQkFTRT4uZmlyZWJhc2Vpby5jb20gaW5zdGVhZCcpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2F0Y2ggY29tbW9uIGVycm9yIG9mIHVuaW5pdGlhbGl6ZWQgbmFtZXNwYWNlIHZhbHVlLlxyXG4gICAgaWYgKCghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gJ3VuZGVmaW5lZCcpICYmXHJcbiAgICAgICAgcGFyc2VkVXJsLmRvbWFpbiAhPT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgICAgICBmYXRhbCgnQ2Fubm90IHBhcnNlIEZpcmViYXNlIHVybC4gUGxlYXNlIHVzZSBodHRwczovLzxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbScpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFwYXJzZWRVcmwuc2VjdXJlKSB7XHJcbiAgICAgICAgd2FybklmUGFnZUlzU2VjdXJlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3ZWJTb2NrZXRPbmx5ID0gcGFyc2VkVXJsLnNjaGVtZSA9PT0gJ3dzJyB8fCBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3NzJztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVwb0luZm86IG5ldyBSZXBvSW5mbyhwYXJzZWRVcmwuaG9zdCwgcGFyc2VkVXJsLnNlY3VyZSwgbmFtZXNwYWNlLCB3ZWJTb2NrZXRPbmx5LCBub2RlQWRtaW4sIFxyXG4gICAgICAgIC8qcGVyc2lzdGVuY2VLZXk9Ki8gJycsIFxyXG4gICAgICAgIC8qaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXM9Ki8gbmFtZXNwYWNlICE9PSBwYXJzZWRVcmwuc3ViZG9tYWluKSxcclxuICAgICAgICBwYXRoOiBuZXcgUGF0aChwYXJzZWRVcmwucGF0aFN0cmluZylcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IHBhcnNlRGF0YWJhc2VVUkwgPSBmdW5jdGlvbiAoZGF0YVVSTCkge1xyXG4gICAgLy8gRGVmYXVsdCB0byBlbXB0eSBzdHJpbmdzIGluIHRoZSBldmVudCBvZiBhIG1hbGZvcm1lZCBzdHJpbmcuXHJcbiAgICBsZXQgaG9zdCA9ICcnLCBkb21haW4gPSAnJywgc3ViZG9tYWluID0gJycsIHBhdGhTdHJpbmcgPSAnJywgbmFtZXNwYWNlID0gJyc7XHJcbiAgICAvLyBBbHdheXMgZGVmYXVsdCB0byBTU0wsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxyXG4gICAgbGV0IHNlY3VyZSA9IHRydWUsIHNjaGVtZSA9ICdodHRwcycsIHBvcnQgPSA0NDM7XHJcbiAgICAvLyBEb24ndCBkbyBhbnkgdmFsaWRhdGlvbiBoZXJlLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSByZXN1bHQgb2YgcGFyc2luZy5cclxuICAgIGlmICh0eXBlb2YgZGF0YVVSTCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBQYXJzZSBzY2hlbWUuXHJcbiAgICAgICAgbGV0IGNvbG9uSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvLycpO1xyXG4gICAgICAgIGlmIChjb2xvbkluZCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHNjaGVtZSA9IGRhdGFVUkwuc3Vic3RyaW5nKDAsIGNvbG9uSW5kIC0gMSk7XHJcbiAgICAgICAgICAgIGRhdGFVUkwgPSBkYXRhVVJMLnN1YnN0cmluZyhjb2xvbkluZCArIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXJzZSBob3N0LCBwYXRoLCBhbmQgcXVlcnkgc3RyaW5nLlxyXG4gICAgICAgIGxldCBzbGFzaEluZCA9IGRhdGFVUkwuaW5kZXhPZignLycpO1xyXG4gICAgICAgIGlmIChzbGFzaEluZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgc2xhc2hJbmQgPSBkYXRhVVJMLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHF1ZXN0aW9uTWFya0luZCA9IGRhdGFVUkwuaW5kZXhPZignPycpO1xyXG4gICAgICAgIGlmIChxdWVzdGlvbk1hcmtJbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHF1ZXN0aW9uTWFya0luZCA9IGRhdGFVUkwubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0ID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgTWF0aC5taW4oc2xhc2hJbmQsIHF1ZXN0aW9uTWFya0luZCkpO1xyXG4gICAgICAgIGlmIChzbGFzaEluZCA8IHF1ZXN0aW9uTWFya0luZCkge1xyXG4gICAgICAgICAgICAvLyBGb3IgcGF0aFN0cmluZywgcXVlc3Rpb25NYXJrSW5kIHdpbGwgYWx3YXlzIGNvbWUgYWZ0ZXIgc2xhc2hJbmRcclxuICAgICAgICAgICAgcGF0aFN0cmluZyA9IGRlY29kZVBhdGgoZGF0YVVSTC5zdWJzdHJpbmcoc2xhc2hJbmQsIHF1ZXN0aW9uTWFya0luZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IGRlY29kZVF1ZXJ5KGRhdGFVUkwuc3Vic3RyaW5nKE1hdGgubWluKGRhdGFVUkwubGVuZ3RoLCBxdWVzdGlvbk1hcmtJbmQpKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnQsIHVzZSBzY2hlbWUgZm9yIGRldGVybWluaW5nIGlmIGl0J3Mgc2VjdXJlLlxyXG4gICAgICAgIGNvbG9uSW5kID0gaG9zdC5pbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcclxuICAgICAgICAgICAgc2VjdXJlID0gc2NoZW1lID09PSAnaHR0cHMnIHx8IHNjaGVtZSA9PT0gJ3dzcyc7XHJcbiAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhjb2xvbkluZCArIDEpLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xvbkluZCA9IGhvc3QubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBob3N0V2l0aG91dFBvcnQgPSBob3N0LnNsaWNlKDAsIGNvbG9uSW5kKTtcclxuICAgICAgICBpZiAoaG9zdFdpdGhvdXRQb3J0LnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhbGhvc3QnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9ICdsb2NhbGhvc3QnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChob3N0V2l0aG91dFBvcnQuc3BsaXQoJy4nKS5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICBkb21haW4gPSBob3N0V2l0aG91dFBvcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbnRlcnByZXQgdGhlIHN1YmRvbWFpbiBvZiBhIDMgb3IgbW9yZSBjb21wb25lbnQgVVJMIGFzIHRoZSBuYW1lc3BhY2UgbmFtZS5cclxuICAgICAgICAgICAgY29uc3QgZG90SW5kID0gaG9zdC5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgICAgIHN1YmRvbWFpbiA9IGhvc3Quc3Vic3RyaW5nKDAsIGRvdEluZCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgZG9tYWluID0gaG9zdC5zdWJzdHJpbmcoZG90SW5kICsgMSk7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBuYW1lc3BhY2VzIHRvIGxvd2VyY2FzZSB0byBzaGFyZSBzdG9yYWdlIC8gY29ubmVjdGlvbi5cclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gc3ViZG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbHdheXMgdHJlYXQgdGhlIHZhbHVlIG9mIHRoZSBgbnNgIGFzIHRoZSBuYW1lc3BhY2UgbmFtZSBpZiBpdCBpcyBwcmVzZW50LlxyXG4gICAgICAgIGlmICgnbnMnIGluIHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHF1ZXJ5UGFyYW1zWyducyddO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaG9zdCxcclxuICAgICAgICBwb3J0LFxyXG4gICAgICAgIGRvbWFpbixcclxuICAgICAgICBzdWJkb21haW4sXHJcbiAgICAgICAgc2VjdXJlLFxyXG4gICAgICAgIHNjaGVtZSxcclxuICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgIG5hbWVzcGFjZVxyXG4gICAgfTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gTW9kZWxlZCBhZnRlciBiYXNlNjQgd2ViLXNhZmUgY2hhcnMsIGJ1dCBvcmRlcmVkIGJ5IEFTQ0lJLlxyXG5jb25zdCBQVVNIX0NIQVJTID0gJy0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG4vKipcclxuICogRmFuY3kgSUQgZ2VuZXJhdG9yIHRoYXQgY3JlYXRlcyAyMC1jaGFyYWN0ZXIgc3RyaW5nIGlkZW50aWZpZXJzIHdpdGggdGhlXHJcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAxLiBUaGV5J3JlIGJhc2VkIG9uIHRpbWVzdGFtcCBzbyB0aGF0IHRoZXkgc29ydCAqYWZ0ZXIqIGFueSBleGlzdGluZyBpZHMuXHJcbiAqIDIuIFRoZXkgY29udGFpbiA3Mi1iaXRzIG9mIHJhbmRvbSBkYXRhIGFmdGVyIHRoZSB0aW1lc3RhbXAgc28gdGhhdCBJRHMgd29uJ3RcclxuICogICAgY29sbGlkZSB3aXRoIG90aGVyIGNsaWVudHMnIElEcy5cclxuICogMy4gVGhleSBzb3J0ICpsZXhpY29ncmFwaGljYWxseSogKHNvIHRoZSB0aW1lc3RhbXAgaXMgY29udmVydGVkIHRvIGNoYXJhY3RlcnNcclxuICogICAgdGhhdCB3aWxsIHNvcnQgcHJvcGVybHkpLlxyXG4gKiA0LiBUaGV5J3JlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy4gRXZlbiBpZiB5b3UgZ2VuZXJhdGUgbW9yZSB0aGFuIG9uZSBpblxyXG4gKiAgICB0aGUgc2FtZSB0aW1lc3RhbXAsIHRoZSBsYXR0ZXIgb25lcyB3aWxsIHNvcnQgYWZ0ZXIgdGhlIGZvcm1lciBvbmVzLiBXZSBkb1xyXG4gKiAgICB0aGlzIGJ5IHVzaW5nIHRoZSBwcmV2aW91cyByYW5kb20gYml0cyBidXQgXCJpbmNyZW1lbnRpbmdcIiB0aGVtIGJ5IDEgKG9ubHlcclxuICogICAgaW4gdGhlIGNhc2Ugb2YgYSB0aW1lc3RhbXAgY29sbGlzaW9uKS5cclxuICovXHJcbmNvbnN0IG5leHRQdXNoSWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gVGltZXN0YW1wIG9mIGxhc3QgcHVzaCwgdXNlZCB0byBwcmV2ZW50IGxvY2FsIGNvbGxpc2lvbnMgaWYgeW91IHB1c2ggdHdpY2VcclxuICAgIC8vIGluIG9uZSBtcy5cclxuICAgIGxldCBsYXN0UHVzaFRpbWUgPSAwO1xyXG4gICAgLy8gV2UgZ2VuZXJhdGUgNzItYml0cyBvZiByYW5kb21uZXNzIHdoaWNoIGdldCB0dXJuZWQgaW50byAxMiBjaGFyYWN0ZXJzIGFuZFxyXG4gICAgLy8gYXBwZW5kZWQgdG8gdGhlIHRpbWVzdGFtcCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgd2l0aCBvdGhlciBjbGllbnRzLiBXZVxyXG4gICAgLy8gc3RvcmUgdGhlIGxhc3QgY2hhcmFjdGVycyB3ZSBnZW5lcmF0ZWQgYmVjYXVzZSBpbiB0aGUgZXZlbnQgb2YgYSBjb2xsaXNpb24sXHJcbiAgICAvLyB3ZSdsbCB1c2UgdGhvc2Ugc2FtZSBjaGFyYWN0ZXJzIGV4Y2VwdCBcImluY3JlbWVudGVkXCIgYnkgb25lLlxyXG4gICAgY29uc3QgbGFzdFJhbmRDaGFycyA9IFtdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICBjb25zdCBkdXBsaWNhdGVUaW1lID0gbm93ID09PSBsYXN0UHVzaFRpbWU7XHJcbiAgICAgICAgbGFzdFB1c2hUaW1lID0gbm93O1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcENoYXJzID0gbmV3IEFycmF5KDgpO1xyXG4gICAgICAgIGZvciAoaSA9IDc7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRpbWVTdGFtcENoYXJzW2ldID0gUFVTSF9DSEFSUy5jaGFyQXQobm93ICUgNjQpO1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBDYW4ndCB1c2UgPDwgaGVyZSBiZWNhdXNlIGphdmFzY3JpcHQgd2lsbCBjb252ZXJ0IHRvIGludCBhbmQgbG9zZVxyXG4gICAgICAgICAgICAvLyB0aGUgdXBwZXIgYml0cy5cclxuICAgICAgICAgICAgbm93ID0gTWF0aC5mbG9vcihub3cgLyA2NCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydChub3cgPT09IDAsICdDYW5ub3QgcHVzaCBhdCB0aW1lID09IDAnKTtcclxuICAgICAgICBsZXQgaWQgPSB0aW1lU3RhbXBDaGFycy5qb2luKCcnKTtcclxuICAgICAgICBpZiAoIWR1cGxpY2F0ZVRpbWUpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aW1lc3RhbXAgaGFzbid0IGNoYW5nZWQgc2luY2UgbGFzdCBwdXNoLCB1c2UgdGhlIHNhbWUgcmFuZG9tXHJcbiAgICAgICAgICAgIC8vIG51bWJlciwgZXhjZXB0IGluY3JlbWVudGVkIGJ5IDEuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDExOyBpID49IDAgJiYgbGFzdFJhbmRDaGFyc1tpXSA9PT0gNjM7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICBpZCArPSBQVVNIX0NIQVJTLmNoYXJBdChsYXN0UmFuZENoYXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGlkLmxlbmd0aCA9PT0gMjAsICduZXh0UHVzaElkOiBMZW5ndGggc2hvdWxkIGJlIDIwLicpO1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH07XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIGRhdGEgbmVlZGVkIHRvIHJhaXNlIGFuIGV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEYXRhRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gT25lIG9mOiB2YWx1ZSwgY2hpbGRfYWRkZWQsIGNoaWxkX2NoYW5nZWQsIGNoaWxkX21vdmVkLCBjaGlsZF9yZW1vdmVkXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byB3aXRoIHRoZSBldmVudCBkYXRhLiBVc2VyIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0gc25hcHNob3QgLSBUaGUgZGF0YSBiYWNraW5nIHRoZSBldmVudFxyXG4gICAgICogQHBhcmFtIHByZXZOYW1lIC0gT3B0aW9uYWwsIHRoZSBuYW1lIG9mIHRoZSBwcmV2aW91cyBjaGlsZCBmb3IgY2hpbGRfKiBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50VHlwZSwgZXZlbnRSZWdpc3RyYXRpb24sIHNuYXBzaG90LCBwcmV2TmFtZSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24gPSBldmVudFJlZ2lzdHJhdGlvbjtcclxuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbiAgICAgICAgdGhpcy5wcmV2TmFtZSA9IHByZXZOYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICBjb25zdCByZWYgPSB0aGlzLnNuYXBzaG90LnJlZjtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZi5fcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWYucGFyZW50Ll9wYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEV2ZW50VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFR5cGU7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5nZXRQYXRoKCkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICc6JyArXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRUeXBlICtcclxuICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMuc25hcHNob3QuZXhwb3J0VmFsKCkpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDYW5jZWxFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFJlZ2lzdHJhdGlvbiwgZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uID0gZXZlbnRSZWdpc3RyYXRpb247XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24uZ2V0RXZlbnRSdW5uZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkgKyAnOmNhbmNlbCc7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBjbGFzcyB0aGF0IGNvbnZlcnRzIGV2ZW50cyBmcm9tIHRoZSBkYXRhYmFzZUBleHAgU0RLIHRvIHRoZSBsZWdhY3lcclxuICogRGF0YWJhc2UgU0RLLiBFdmVudHMgYXJlIG5vdCBjb252ZXJ0ZWQgZGlyZWN0bHkgYXMgZXZlbnQgcmVnaXN0cmF0aW9uIHJlbGllc1xyXG4gKiBvbiByZWZlcmVuY2UgY29tcGFyaXNvbiBvZiB0aGUgb3JpZ2luYWwgdXNlciBjYWxsYmFjayAoc2VlIGBtYXRjaGVzKClgKSBhbmRcclxuICogcmVsaWVzIG9uIGVxdWFsaXR5IG9mIHRoZSBsZWdhY3kgU0RLJ3MgYGNvbnRleHRgIG9iamVjdC5cclxuICovXHJcbmNsYXNzIENhbGxiYWNrQ29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzbmFwc2hvdENhbGxiYWNrLCBjYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayA9IHNuYXBzaG90Q2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgb25WYWx1ZShleHBEYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKSB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrLmNhbGwobnVsbCwgZXhwRGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSk7XHJcbiAgICB9XHJcbiAgICBvbkNhbmNlbChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmhhc0NhbmNlbENhbGxiYWNrLCAnUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsQ2FsbGJhY2suY2FsbChudWxsLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzQ2FuY2VsQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jYW5jZWxDYWxsYmFjaztcclxuICAgIH1cclxuICAgIG1hdGNoZXMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc25hcHNob3RDYWxsYmFjayA9PT0gb3RoZXIuc25hcHNob3RDYWxsYmFjayB8fFxyXG4gICAgICAgICAgICAodGhpcy5zbmFwc2hvdENhbGxiYWNrLnVzZXJDYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrID09PVxyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2suY29udGV4dCA9PT0gb3RoZXIuc25hcHNob3RDYWxsYmFjay5jb250ZXh0KSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBgb25EaXNjb25uZWN0YCBjbGFzcyBhbGxvd3MgeW91IHRvIHdyaXRlIG9yIGNsZWFyIGRhdGEgd2hlbiB5b3VyIGNsaWVudFxyXG4gKiBkaXNjb25uZWN0cyBmcm9tIHRoZSBEYXRhYmFzZSBzZXJ2ZXIuIFRoZXNlIHVwZGF0ZXMgb2NjdXIgd2hldGhlciB5b3VyXHJcbiAqIGNsaWVudCBkaXNjb25uZWN0cyBjbGVhbmx5IG9yIG5vdCwgc28geW91IGNhbiByZWx5IG9uIHRoZW0gdG8gY2xlYW4gdXAgZGF0YVxyXG4gKiBldmVuIGlmIGEgY29ubmVjdGlvbiBpcyBkcm9wcGVkIG9yIGEgY2xpZW50IGNyYXNoZXMuXHJcbiAqXHJcbiAqIFRoZSBgb25EaXNjb25uZWN0YCBjbGFzcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgdG8gbWFuYWdlIHByZXNlbmNlIGluXHJcbiAqIGFwcGxpY2F0aW9ucyB3aGVyZSBpdCBpcyB1c2VmdWwgdG8gZGV0ZWN0IGhvdyBtYW55IGNsaWVudHMgYXJlIGNvbm5lY3RlZCBhbmRcclxuICogd2hlbiBvdGhlciBjbGllbnRzIGRpc2Nvbm5lY3QuIFNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL29mZmxpbmUtY2FwYWJpbGl0aWVzIHwgRW5hYmxpbmcgT2ZmbGluZSBDYXBhYmlsaXRpZXMgaW4gSmF2YVNjcmlwdH1cclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFRvIGF2b2lkIHByb2JsZW1zIHdoZW4gYSBjb25uZWN0aW9uIGlzIGRyb3BwZWQgYmVmb3JlIHRoZSByZXF1ZXN0cyBjYW4gYmVcclxuICogdHJhbnNmZXJyZWQgdG8gdGhlIERhdGFiYXNlIHNlcnZlciwgdGhlc2UgZnVuY3Rpb25zIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlXHJcbiAqIHdyaXRpbmcgYW55IGRhdGEuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGFyZSBvbmx5IHRyaWdnZXJlZCBvbmNlLiBJZiB5b3Ugd2FudCBhblxyXG4gKiBvcGVyYXRpb24gdG8gb2NjdXIgZWFjaCB0aW1lIGEgZGlzY29ubmVjdCBvY2N1cnMsIHlvdSdsbCBuZWVkIHRvIHJlLWVzdGFibGlzaFxyXG4gKiB0aGUgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBlYWNoIHRpbWUgeW91IHJlY29ubmVjdC5cclxuICovXHJcbmNsYXNzIE9uRGlzY29ubmVjdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG8sIF9wYXRoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwbyA9IF9yZXBvO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyBhbGwgcHJldmlvdXNseSBxdWV1ZWQgYG9uRGlzY29ubmVjdCgpYCBzZXQgb3IgdXBkYXRlIGV2ZW50cyBmb3IgdGhpc1xyXG4gICAgICogbG9jYXRpb24gYW5kIGFsbCBjaGlsZHJlbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHdyaXRlIGhhcyBiZWVuIHF1ZXVlZCBmb3IgdGhpcyBsb2NhdGlvbiB2aWEgYSBgc2V0KClgIG9yIGB1cGRhdGUoKWAgYXQgYVxyXG4gICAgICogcGFyZW50IGxvY2F0aW9uLCB0aGUgd3JpdGUgYXQgdGhpcyBsb2NhdGlvbiB3aWxsIGJlIGNhbmNlbGVkLCB0aG91Z2ggd3JpdGVzXHJcbiAgICAgKiB0byBzaWJsaW5nIGxvY2F0aW9ucyB3aWxsIHN0aWxsIG9jY3VyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RDYW5jZWwodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gaXMgZGVsZXRlZCB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkXHJcbiAgICAgKiAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZSgpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnJlbW92ZScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFNldCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBzZXQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aGVuIHRoZVxyXG4gICAgICogY2xpZW50IGlzIGRpc2Nvbm5lY3RlZCAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSxcclxuICAgICAqIG9yIG5ldHdvcmsgaXNzdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBgc2V0KClgIGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBpbXBsZW1lbnRpbmcgXCJwcmVzZW5jZVwiIHN5c3RlbXMsIHdoZXJlIGFcclxuICAgICAqIHZhbHVlIHNob3VsZCBiZSBjaGFuZ2VkIG9yIGNsZWFyZWQgd2hlbiBhIHVzZXIgZGlzY29ubmVjdHMgc28gdGhhdCB0aGV5XHJcbiAgICAgKiBhcHBlYXIgXCJvZmZsaW5lXCIgdG8gb3RoZXIgdXNlcnMuIFNlZVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9vZmZsaW5lLWNhcGFiaWxpdGllcyB8IEVuYWJsaW5nIE9mZmxpbmUgQ2FwYWJpbGl0aWVzIGluIEphdmFTY3JpcHR9XHJcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBhcmUgb25seSB0cmlnZ2VyZWQgb25jZS4gSWYgeW91IHdhbnQgYW5cclxuICAgICAqIG9wZXJhdGlvbiB0byBvY2N1ciBlYWNoIHRpbWUgYSBkaXNjb25uZWN0IG9jY3VycywgeW91J2xsIG5lZWQgdG8gcmUtZXN0YWJsaXNoXHJcbiAgICAgKiB0aGUgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBlYWNoIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBsb2NhdGlvbiBvbiBkaXNjb25uZWN0IChjYW5cclxuICAgICAqIGJlIGFuIG9iamVjdCwgYXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKS5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5zZXQnLCB0aGlzLl9wYXRoKTtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnT25EaXNjb25uZWN0LnNldCcsIHZhbHVlLCB0aGlzLl9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0U2V0KHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIHZhbHVlLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBzZXQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSBhbmQgcHJpb3JpdHlcclxuICAgICAqIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKGR1ZSB0byBjbG9zaW5nIHRoZSBicm93c2VyLCBuYXZpZ2F0aW5nIHRvIGFcclxuICAgICAqIG5ldyBwYWdlLCBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBsb2NhdGlvbiBvbiBkaXNjb25uZWN0IChjYW5cclxuICAgICAqIGJlIGFuIG9iamVjdCwgYXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKS5cclxuICAgICAqIEBwYXJhbSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgb3IgbnVsbCkuXHJcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byB0aGUgRGF0YWJhc2UgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHNldFdpdGhQcmlvcml0eSh2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgdmFsdWUsIHRoaXMuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5KCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBtdWx0aXBsZSB2YWx1ZXMgYXQgdGhpcyBsb2NhdGlvbiB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkIChkdWVcclxuICAgICAqIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgdmFsdWVzYCBhcmd1bWVudCBjb250YWlucyBtdWx0aXBsZSBwcm9wZXJ0eS12YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmVcclxuICAgICAqIHdyaXR0ZW4gdG8gdGhlIERhdGFiYXNlIHRvZ2V0aGVyLiBFYWNoIGNoaWxkIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgYSBzaW1wbGVcclxuICAgICAqIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgXCJuYW1lXCIpIG9yIGEgcmVsYXRpdmUgcGF0aCAoZm9yIGV4YW1wbGUsIFwibmFtZS9maXJzdFwiKVxyXG4gICAgICogZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbiB0byB0aGUgZGF0YSB0byB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQXMgb3Bwb3NlZCB0byB0aGUgYHNldCgpYCBtZXRob2QsIGB1cGRhdGUoKWAgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseSB1cGRhdGVcclxuICAgICAqIG9ubHkgdGhlIHJlZmVyZW5jZWQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbiAoaW5zdGVhZCBvZiByZXBsYWNpbmdcclxuICAgICAqIGFsbCB0aGUgY2hpbGQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdCBjb250YWluaW5nIG11bHRpcGxlIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHZhbHVlcykge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QudXBkYXRlJywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygnT25EaXNjb25uZWN0LnVwZGF0ZScsIHZhbHVlcywgdGhpcy5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFVwZGF0ZSh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCB2YWx1ZXMsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUltcGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9yZXBvLCBfcGF0aCwgX3F1ZXJ5UGFyYW1zLCBfb3JkZXJCeUNhbGxlZCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG8gPSBfcmVwbztcclxuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICAgICAgdGhpcy5fcXVlcnlQYXJhbXMgPSBfcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fb3JkZXJCeUNhbGxlZCA9IF9vcmRlckJ5Q2FsbGVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IGtleSgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5fcGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aEdldEJhY2sodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHJlZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgdGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXQgX3F1ZXJ5SWRlbnRpZmllcigpIHtcclxuICAgICAgICBjb25zdCBvYmogPSBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHRoaXMuX3F1ZXJ5UGFyYW1zKTtcclxuICAgICAgICBjb25zdCBpZCA9IE9iamVjdFRvVW5pcXVlS2V5KG9iaik7XHJcbiAgICAgICAgcmV0dXJuIGlkID09PSAne30nID8gJ2RlZmF1bHQnIDogaWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVlcnkgcGFyYW1ldGVycyB1c2VkIGJ5IHRoaXMgUXVlcnkuXHJcbiAgICAgKi9cclxuICAgIGdldCBfcXVlcnlPYmplY3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QodGhpcy5fcXVlcnlQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIG90aGVyID0gZ2V0TW9kdWxhckluc3RhbmNlKG90aGVyKTtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFF1ZXJ5SW1wbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzYW1lUmVwbyA9IHRoaXMuX3JlcG8gPT09IG90aGVyLl9yZXBvO1xyXG4gICAgICAgIGNvbnN0IHNhbWVQYXRoID0gcGF0aEVxdWFscyh0aGlzLl9wYXRoLCBvdGhlci5fcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgc2FtZVF1ZXJ5SWRlbnRpZmllciA9IHRoaXMuX3F1ZXJ5SWRlbnRpZmllciA9PT0gb3RoZXIuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICByZXR1cm4gc2FtZVJlcG8gJiYgc2FtZVBhdGggJiYgc2FtZVF1ZXJ5SWRlbnRpZmllcjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcG8udG9TdHJpbmcoKSArIHBhdGhUb1VybEVuY29kZWRTdHJpbmcodGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IG5vIG90aGVyIG9yZGVyIGJ5IGNhbGwgaGFzIGJlZW4gbWFkZVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksIGZuTmFtZSkge1xyXG4gICAgaWYgKHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiOiBZb3UgY2FuJ3QgY29tYmluZSBtdWx0aXBsZSBvcmRlckJ5IGNhbGxzLlwiKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHN0YXJ0L2VuZCB2YWx1ZXMgZm9yIHF1ZXJpZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKHBhcmFtcykge1xyXG4gICAgbGV0IHN0YXJ0Tm9kZSA9IG51bGw7XHJcbiAgICBsZXQgZW5kTm9kZSA9IG51bGw7XHJcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICBzdGFydE5vZGUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgZW5kTm9kZSA9IHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgIGNvbnN0IHRvb01hbnlBcmdzRXJyb3IgPSAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gJyArXHJcbiAgICAgICAgICAgICdzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS4nO1xyXG4gICAgICAgIGNvbnN0IHdyb25nQXJnVHlwZUVycm9yID0gJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgJyArXHJcbiAgICAgICAgICAgICdlbmRBdCgpLCBlbmRCZWZvcmUoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuJztcclxuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnROYW1lID0gcGFyYW1zLmdldEluZGV4U3RhcnROYW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE5hbWUgIT09IE1JTl9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodG9vTWFueUFyZ3NFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0Tm9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmROYW1lID0gcGFyYW1zLmdldEluZGV4RW5kTmFtZSgpO1xyXG4gICAgICAgICAgICBpZiAoZW5kTmFtZSAhPT0gTUFYX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZW5kTm9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gUFJJT1JJVFlfSU5ERVgpIHtcclxuICAgICAgICBpZiAoKHN0YXJ0Tm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoc3RhcnROb2RlKSkgfHxcclxuICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiAhaXNWYWxpZFByaW9yaXR5KGVuZE5vZGUpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IHByaW9yaXR5LCB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgJyArXHJcbiAgICAgICAgICAgICAgICAnc3RhcnRBZnRlcigpIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHZhbGlkIHByaW9yaXR5IHZhbHVlICcgK1xyXG4gICAgICAgICAgICAgICAgJyhudWxsLCBhIG51bWJlciwgb3IgYSBzdHJpbmcpLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChwYXJhbXMuZ2V0SW5kZXgoKSBpbnN0YW5jZW9mIFBhdGhJbmRleCB8fFxyXG4gICAgICAgICAgICBwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gVkFMVUVfSU5ERVgsICd1bmtub3duIGluZGV4IHR5cGUuJyk7XHJcbiAgICAgICAgaWYgKChzdGFydE5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RhcnROb2RlID09PSAnb2JqZWN0JykgfHxcclxuICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiB0eXBlb2YgZW5kTm9kZSA9PT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnk6IEZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgZW5kQXQoKSwgZW5kQmVmb3JlKCksIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8oKSBjYW5ub3QgYmUgYW4gb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgbGltaXQqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IGNvbWJpbmF0aW9uIG9mIHBhcmFtZXRlcnNcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTGltaXQocGFyYW1zKSB7XHJcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkgJiZcclxuICAgICAgICBwYXJhbXMuaGFzRW5kKCkgJiZcclxuICAgICAgICBwYXJhbXMuaGFzTGltaXQoKSAmJlxyXG4gICAgICAgICFwYXJhbXMuaGFzQW5jaG9yZWRMaW1pdCgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBzdGFydEFmdGVyKCksIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBhbmQgbGltaXQoKS4gVXNlIFwiICtcclxuICAgICAgICAgICAgJ2xpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBSZWZlcmVuY2VJbXBsIGV4dGVuZHMgUXVlcnlJbXBsIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvLCBwYXRoKSB7XHJcbiAgICAgICAgc3VwZXIocmVwbywgcGF0aCwgbmV3IFF1ZXJ5UGFyYW1zKCksIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGhQYXJlbnQodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGggPT09IG51bGxcclxuICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgIDogbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgcGFyZW50UGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcm9vdCgpIHtcclxuICAgICAgICBsZXQgcmVmID0gdGhpcztcclxuICAgICAgICB3aGlsZSAocmVmLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZWYgPSByZWYucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVmO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBEYXRhU25hcHNob3RgIGNvbnRhaW5zIGRhdGEgZnJvbSBhIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBbnkgdGltZSB5b3UgcmVhZCBkYXRhIGZyb20gdGhlIERhdGFiYXNlLCB5b3UgcmVjZWl2ZSB0aGUgZGF0YSBhcyBhXHJcbiAqIGBEYXRhU25hcHNob3RgLiBBIGBEYXRhU25hcHNob3RgIGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgY2FsbGJhY2tzIHlvdSBhdHRhY2hcclxuICogd2l0aCBgb24oKWAgb3IgYG9uY2UoKWAuIFlvdSBjYW4gZXh0cmFjdCB0aGUgY29udGVudHMgb2YgdGhlIHNuYXBzaG90IGFzIGFcclxuICogSmF2YVNjcmlwdCBvYmplY3QgYnkgY2FsbGluZyB0aGUgYHZhbCgpYCBtZXRob2QuIEFsdGVybmF0aXZlbHksIHlvdSBjYW5cclxuICogdHJhdmVyc2UgaW50byB0aGUgc25hcHNob3QgYnkgY2FsbGluZyBgY2hpbGQoKWAgdG8gcmV0dXJuIGNoaWxkIHNuYXBzaG90c1xyXG4gKiAod2hpY2ggeW91IGNvdWxkIHRoZW4gY2FsbCBgdmFsKClgIG9uKS5cclxuICpcclxuICogQSBgRGF0YVNuYXBzaG90YCBpcyBhbiBlZmZpY2llbnRseSBnZW5lcmF0ZWQsIGltbXV0YWJsZSBjb3B5IG9mIHRoZSBkYXRhIGF0XHJcbiAqIGEgRGF0YWJhc2UgbG9jYXRpb24uIEl0IGNhbm5vdCBiZSBtb2RpZmllZCBhbmQgd2lsbCBuZXZlciBjaGFuZ2UgKHRvIG1vZGlmeVxyXG4gKiBkYXRhLCB5b3UgYWx3YXlzIGNhbGwgdGhlIGBzZXQoKWAgbWV0aG9kIG9uIGEgYFJlZmVyZW5jZWAgZGlyZWN0bHkpLlxyXG4gKi9cclxuY2xhc3MgRGF0YVNuYXBzaG90IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIF9ub2RlIC0gQSBTbmFwc2hvdE5vZGUgdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdGhpcyBzbmFwc2hvdCBjYW1lIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IC0gVGhlIGl0ZXJhdGlvbiBvcmRlciBmb3IgdGhpcyBzbmFwc2hvdFxyXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihfbm9kZSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGlzIERhdGFTbmFwc2hvdC5cclxuICAgICAqL1xyXG4gICAgcmVmLCBfaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl9ub2RlID0gX25vZGU7XHJcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBfaW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHByaW9yaXR5IHZhbHVlIG9mIHRoZSBkYXRhIGluIHRoaXMgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAgICAgKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICAgICAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8U29ydGluZyBhbmQgZmlsdGVyaW5nIGRhdGF9XHJcbiAgICAgKiApLlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJpb3JpdHkoKSB7XHJcbiAgICAgICAgLy8gdHlwZWNhc3QgaGVyZSBiZWNhdXNlIHdlIG5ldmVyIHJldHVybiBkZWZlcnJlZCB2YWx1ZXMgb3IgaW50ZXJuYWwgcHJpb3JpdGllcyAoTUFYX1BSSU9SSVRZKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBrZXkgKGxhc3QgcGFydCBvZiB0aGUgcGF0aCkgb2YgdGhlIGxvY2F0aW9uIG9mIHRoaXMgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxhc3QgdG9rZW4gaW4gYSBEYXRhYmFzZSBsb2NhdGlvbiBpcyBjb25zaWRlcmVkIGl0cyBrZXkuIEZvciBleGFtcGxlLFxyXG4gICAgICogXCJhZGFcIiBpcyB0aGUga2V5IGZvciB0aGUgL3VzZXJzL2FkYS8gbm9kZS4gQWNjZXNzaW5nIHRoZSBrZXkgb24gYW55XHJcbiAgICAgKiBgRGF0YVNuYXBzaG90YCB3aWxsIHJldHVybiB0aGUga2V5IGZvciB0aGUgbG9jYXRpb24gdGhhdCBnZW5lcmF0ZWQgaXQuXHJcbiAgICAgKiBIb3dldmVyLCBhY2Nlc3NpbmcgdGhlIGtleSBvbiB0aGUgcm9vdCBVUkwgb2YgYSBEYXRhYmFzZSB3aWxsIHJldHVyblxyXG4gICAgICogYG51bGxgLlxyXG4gICAgICovXHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZi5rZXk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkIHByb3BlcnRpZXMgb2YgdGhpcyBgRGF0YVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLm51bUNoaWxkcmVuKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW5vdGhlciBgRGF0YVNuYXBzaG90YCBmb3IgdGhlIGxvY2F0aW9uIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBQYXNzaW5nIGEgcmVsYXRpdmUgcGF0aCB0byB0aGUgYGNoaWxkKClgIG1ldGhvZCBvZiBhIERhdGFTbmFwc2hvdCByZXR1cm5zXHJcbiAgICAgKiBhbm90aGVyIGBEYXRhU25hcHNob3RgIGZvciB0aGUgbG9jYXRpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwYXRoLiBUaGVcclxuICAgICAqIHJlbGF0aXZlIHBhdGggY2FuIGVpdGhlciBiZSBhIHNpbXBsZSBjaGlsZCBuYW1lIChmb3IgZXhhbXBsZSwgXCJhZGFcIikgb3IgYVxyXG4gICAgICogZGVlcGVyLCBzbGFzaC1zZXBhcmF0ZWQgcGF0aCAoZm9yIGV4YW1wbGUsIFwiYWRhL25hbWUvZmlyc3RcIikuIElmIHRoZSBjaGlsZFxyXG4gICAgICogbG9jYXRpb24gaGFzIG5vIGRhdGEsIGFuIGVtcHR5IGBEYXRhU25hcHNob3RgICh0aGF0IGlzLCBhIGBEYXRhU25hcHNob3RgXHJcbiAgICAgKiB3aG9zZSB2YWx1ZSBpcyBgbnVsbGApIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiBvZiBjaGlsZCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBjaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gbmV3IFBhdGgocGF0aCk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRSZWYgPSBjaGlsZCh0aGlzLnJlZiwgcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU25hcHNob3QodGhpcy5fbm9kZS5nZXRDaGlsZChjaGlsZFBhdGgpLCBjaGlsZFJlZiwgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgRGF0YVNuYXBzaG90YCBjb250YWlucyBhbnkgZGF0YS4gSXQgaXMgc2xpZ2h0bHkgbW9yZVxyXG4gICAgICogZWZmaWNpZW50IHRoYW4gdXNpbmcgYHNuYXBzaG90LnZhbCgpICE9PSBudWxsYC5cclxuICAgICAqL1xyXG4gICAgZXhpc3RzKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgRGF0YVNuYXBzaG90IGFzIGEgSmF2YVNjcmlwdCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBleHBvcnRWYWwoKWAgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYHZhbCgpYCwgZXhjZXB0IHByaW9yaXR5IGluZm9ybWF0aW9uXHJcbiAgICAgKiBpcyBpbmNsdWRlZCAoaWYgYXZhaWxhYmxlKSwgbWFraW5nIGl0IHN1aXRhYmxlIGZvciBiYWNraW5nIHVwIHlvdXIgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgRGF0YVNuYXBzaG90J3MgY29udGVudHMgYXMgYSBKYXZhU2NyaXB0IHZhbHVlIChPYmplY3QsXHJcbiAgICAgKiAgIEFycmF5LCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYG51bGxgKS5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGV4cG9ydFZhbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZS52YWwodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVudW1lcmF0ZXMgdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBpbiB0aGUgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogQmVjYXVzZSBvZiB0aGUgd2F5IEphdmFTY3JpcHQgb2JqZWN0cyB3b3JrLCB0aGUgb3JkZXJpbmcgb2YgZGF0YSBpbiB0aGVcclxuICAgICAqIEphdmFTY3JpcHQgb2JqZWN0IHJldHVybmVkIGJ5IGB2YWwoKWAgaXMgbm90IGd1YXJhbnRlZWQgdG8gbWF0Y2ggdGhlXHJcbiAgICAgKiBvcmRlcmluZyBvbiB0aGUgc2VydmVyIG5vciB0aGUgb3JkZXJpbmcgb2YgYG9uQ2hpbGRBZGRlZCgpYCBldmVudHMuIFRoYXQgaXNcclxuICAgICAqIHdoZXJlIGBmb3JFYWNoKClgIGNvbWVzIGluIGhhbmR5LiBJdCBndWFyYW50ZWVzIHRoZSBjaGlsZHJlbiBvZiBhXHJcbiAgICAgKiBgRGF0YVNuYXBzaG90YCB3aWxsIGJlIGl0ZXJhdGVkIGluIHRoZWlyIHF1ZXJ5IG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIElmIG5vIGV4cGxpY2l0IGBvcmRlckJ5KigpYCBtZXRob2QgaXMgdXNlZCwgcmVzdWx0cyBhcmUgcmV0dXJuZWRcclxuICAgICAqIG9yZGVyZWQgYnkga2V5ICh1bmxlc3MgcHJpb3JpdGllcyBhcmUgdXNlZCwgaW4gd2hpY2ggY2FzZSwgcmVzdWx0cyBhcmVcclxuICAgICAqIHJldHVybmVkIGJ5IHByaW9yaXR5KS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNoaWxkIERhdGFTbmFwc2hvdC5cclxuICAgICAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIHRydWUgdG8gY2FuY2VsIGZ1cnRoZXIgZW51bWVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGVudW1lcmF0aW9uIHdhcyBjYW5jZWxlZCBkdWUgdG8geW91ciBjYWxsYmFjayByZXR1cm5pbmdcclxuICAgICAqIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2goYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW5Ob2RlID0gdGhpcy5fbm9kZTtcclxuICAgICAgICAvLyBTYW5pdGl6ZSB0aGUgcmV0dXJuIHZhbHVlIHRvIGEgYm9vbGVhbi4gQ2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZCBoYXMgYSB3ZWlyZCByZXR1cm4gdHlwZS4uLlxyXG4gICAgICAgIHJldHVybiAhIWNoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQodGhpcy5faW5kZXgsIChrZXksIG5vZGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbihuZXcgRGF0YVNuYXBzaG90KG5vZGUsIGNoaWxkKHRoaXMucmVmLCBrZXkpLCBQUklPUklUWV9JTkRFWCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjaGlsZCBwYXRoIGhhcyAobm9uLW51bGwpIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBIHJlbGF0aXZlIHBhdGggdG8gdGhlIGxvY2F0aW9uIG9mIGEgcG90ZW50aWFsIGNoaWxkLlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIGRhdGEgZXhpc3RzIGF0IHRoZSBzcGVjaWZpZWQgY2hpbGQgcGF0aDsgZWxzZVxyXG4gICAgICogIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGhhc0NoaWxkKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBuZXcgUGF0aChwYXRoKTtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX25vZGUuZ2V0Q2hpbGQoY2hpbGRQYXRoKS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGBEYXRhU25hcHNob3RgIGhhcyBhbnkgbm9uLWBudWxsYCBjaGlsZFxyXG4gICAgICogcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgY2FuIHVzZSBgaGFzQ2hpbGRyZW4oKWAgdG8gZGV0ZXJtaW5lIGlmIGEgYERhdGFTbmFwc2hvdGAgaGFzIGFueVxyXG4gICAgICogY2hpbGRyZW4uIElmIGl0IGRvZXMsIHlvdSBjYW4gZW51bWVyYXRlIHRoZW0gdXNpbmcgYGZvckVhY2goKWAuIElmIGl0XHJcbiAgICAgKiBkb2Vzbid0LCB0aGVuIGVpdGhlciB0aGlzIHNuYXBzaG90IGNvbnRhaW5zIGEgcHJpbWl0aXZlIHZhbHVlICh3aGljaCBjYW4gYmVcclxuICAgICAqIHJldHJpZXZlZCB3aXRoIGB2YWwoKWApIG9yIGl0IGlzIGVtcHR5IChpbiB3aGljaCBjYXNlLCBgdmFsKClgIHdpbGwgcmV0dXJuXHJcbiAgICAgKiBgbnVsbGApLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBzbmFwc2hvdCBoYXMgYW55IGNoaWxkcmVuOyBlbHNlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBoYXNDaGlsZHJlbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fbm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9ub2RlLmlzRW1wdHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydFZhbCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyBhIEphdmFTY3JpcHQgdmFsdWUgZnJvbSBhIGBEYXRhU25hcHNob3RgLlxyXG4gICAgICpcclxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgZGF0YSBpbiBhIGBEYXRhU25hcHNob3RgLCB0aGUgYHZhbCgpYCBtZXRob2QgbWF5IHJldHVybiBhXHJcbiAgICAgKiBzY2FsYXIgdHlwZSAoc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4pLCBhbiBhcnJheSwgb3IgYW4gb2JqZWN0LiBJdCBtYXlcclxuICAgICAqIGFsc28gcmV0dXJuIG51bGwsIGluZGljYXRpbmcgdGhhdCB0aGUgYERhdGFTbmFwc2hvdGAgaXMgZW1wdHkgKGNvbnRhaW5zIG5vXHJcbiAgICAgKiBkYXRhKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgRGF0YVNuYXBzaG90J3MgY29udGVudHMgYXMgYSBKYXZhU2NyaXB0IHZhbHVlIChPYmplY3QsXHJcbiAgICAgKiAgIEFycmF5LCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYG51bGxgKS5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHZhbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZS52YWwoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogUmV0dXJucyBhIGBSZWZlcmVuY2VgIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gaW4gdGhlIERhdGFiYXNlXHJcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIHBhdGguIElmIG5vIHBhdGggaXMgcHJvdmlkZWQsIHRoZSBgUmVmZXJlbmNlYFxyXG4gKiB3aWxsIHBvaW50IHRvIHRoZSByb290IG9mIHRoZSBEYXRhYmFzZS5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGRhdGFiYXNlIGluc3RhbmNlIHRvIG9idGFpbiBhIHJlZmVyZW5jZSBmb3IuXHJcbiAqIEBwYXJhbSBwYXRoIC0gT3B0aW9uYWwgcGF0aCByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIHRoZSByZXR1cm5lZFxyXG4gKiAgIGBSZWZlcmVuY2VgIHdpbGwgcG9pbnQuIElmIG5vdCBwcm92aWRlZCwgdGhlIHJldHVybmVkIGBSZWZlcmVuY2VgIHdpbGxcclxuICogICBwb2ludCB0byB0aGUgcm9vdCBvZiB0aGUgRGF0YWJhc2UuXHJcbiAqIEByZXR1cm5zIElmIGEgcGF0aCBpcyBwcm92aWRlZCwgYSBgUmVmZXJlbmNlYFxyXG4gKiAgIHBvaW50aW5nIHRvIHRoZSBwcm92aWRlZCBwYXRoLiBPdGhlcndpc2UsIGEgYFJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlXHJcbiAqICAgcm9vdCBvZiB0aGUgRGF0YWJhc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWYoZGIsIHBhdGgpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ3JlZicpO1xyXG4gICAgcmV0dXJuIHBhdGggIT09IHVuZGVmaW5lZCA/IGNoaWxkKGRiLl9yb290LCBwYXRoKSA6IGRiLl9yb290O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgYFJlZmVyZW5jZWAgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBpbiB0aGUgRGF0YWJhc2VcclxuICogY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgRmlyZWJhc2UgVVJMLlxyXG4gKlxyXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBVUkwgaXMgbm90IGEgdmFsaWQgRmlyZWJhc2UgRGF0YWJhc2UgVVJMIG9yIGl0XHJcbiAqIGhhcyBhIGRpZmZlcmVudCBkb21haW4gdGhhbiB0aGUgY3VycmVudCBgRGF0YWJhc2VgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYWxsIHF1ZXJ5IHBhcmFtZXRlcnMgKGBvcmRlckJ5YCwgYGxpbWl0VG9MYXN0YCwgZXRjLikgYXJlIGlnbm9yZWRcclxuICogYW5kIGFyZSBub3QgYXBwbGllZCB0byB0aGUgcmV0dXJuZWQgYFJlZmVyZW5jZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBkYXRhYmFzZSBpbnN0YW5jZSB0byBvYnRhaW4gYSByZWZlcmVuY2UgZm9yLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIEZpcmViYXNlIFVSTCBhdCB3aGljaCB0aGUgcmV0dXJuZWQgYFJlZmVyZW5jZWAgd2lsbFxyXG4gKiAgIHBvaW50LlxyXG4gKiBAcmV0dXJucyBBIGBSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZSBwcm92aWRlZFxyXG4gKiAgIEZpcmViYXNlIFVSTC5cclxuICovXHJcbmZ1bmN0aW9uIHJlZkZyb21VUkwoZGIsIHVybCkge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgncmVmRnJvbVVSTCcpO1xyXG4gICAgY29uc3QgcGFyc2VkVVJMID0gcGFyc2VSZXBvSW5mbyh1cmwsIGRiLl9yZXBvLnJlcG9JbmZvXy5ub2RlQWRtaW4pO1xyXG4gICAgdmFsaWRhdGVVcmwoJ3JlZkZyb21VUkwnLCBwYXJzZWRVUkwpO1xyXG4gICAgY29uc3QgcmVwb0luZm8gPSBwYXJzZWRVUkwucmVwb0luZm87XHJcbiAgICBpZiAoIWRiLl9yZXBvLnJlcG9JbmZvXy5pc0N1c3RvbUhvc3QoKSAmJlxyXG4gICAgICAgIHJlcG9JbmZvLmhvc3QgIT09IGRiLl9yZXBvLnJlcG9JbmZvXy5ob3N0KSB7XHJcbiAgICAgICAgZmF0YWwoJ3JlZkZyb21VUkwnICtcclxuICAgICAgICAgICAgJzogSG9zdCBuYW1lIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGRhdGFiYXNlOiAnICtcclxuICAgICAgICAgICAgJyhmb3VuZCAnICtcclxuICAgICAgICAgICAgcmVwb0luZm8uaG9zdCArXHJcbiAgICAgICAgICAgICcgYnV0IGV4cGVjdGVkICcgK1xyXG4gICAgICAgICAgICBkYi5fcmVwby5yZXBvSW5mb18uaG9zdCArXHJcbiAgICAgICAgICAgICcpJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVmKGRiLCBwYXJzZWRVUkwucGF0aC50b1N0cmluZygpKTtcclxufVxyXG4vKipcclxuICogR2V0cyBhIGBSZWZlcmVuY2VgIGZvciB0aGUgbG9jYXRpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwYXRoLlxyXG4gKlxyXG4gKiBUaGUgcmVsYXRpdmUgcGF0aCBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlIGNoaWxkIG5hbWUgKGZvciBleGFtcGxlLCBcImFkYVwiKSBvclxyXG4gKiBhIGRlZXBlciBzbGFzaC1zZXBhcmF0ZWQgcGF0aCAoZm9yIGV4YW1wbGUsIFwiYWRhL25hbWUvZmlyc3RcIikuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgcGFyZW50IGxvY2F0aW9uLlxyXG4gKiBAcGFyYW0gcGF0aCAtIEEgcmVsYXRpdmUgcGF0aCBmcm9tIHRoaXMgbG9jYXRpb24gdG8gdGhlIGRlc2lyZWQgY2hpbGRcclxuICogICBsb2NhdGlvbi5cclxuICogQHJldHVybnMgVGhlIHNwZWNpZmllZCBjaGlsZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNoaWxkKHBhcmVudCwgcGF0aCkge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICBpZiAocGF0aEdldEZyb250KHBhcmVudC5fcGF0aCkgPT09IG51bGwpIHtcclxuICAgICAgICB2YWxpZGF0ZVJvb3RQYXRoU3RyaW5nKCdjaGlsZCcsICdwYXRoJywgcGF0aCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWRhdGVQYXRoU3RyaW5nKCdjaGlsZCcsICdwYXRoJywgcGF0aCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2VJbXBsKHBhcmVudC5fcmVwbywgcGF0aENoaWxkKHBhcmVudC5fcGF0aCwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGBPbkRpc2Nvbm5lY3RgIG9iamVjdCAtIHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL29mZmxpbmUtY2FwYWJpbGl0aWVzIHwgRW5hYmxpbmcgT2ZmbGluZSBDYXBhYmlsaXRpZXMgaW4gSmF2YVNjcmlwdH1cclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIHVzZSBpdC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSByZWZlcmVuY2UgdG8gYWRkIE9uRGlzY29ubmVjdCB0cmlnZ2VycyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBvbkRpc2Nvbm5lY3QocmVmKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHJldHVybiBuZXcgT25EaXNjb25uZWN0KHJlZi5fcmVwbywgcmVmLl9wYXRoKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgbmV3IGNoaWxkIGxvY2F0aW9uIHVzaW5nIGEgdW5pcXVlIGtleSBhbmQgcmV0dXJucyBpdHNcclxuICogYFJlZmVyZW5jZWAuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIHBhdHRlcm4gZm9yIGFkZGluZyBkYXRhIHRvIGEgY29sbGVjdGlvbiBvZiBpdGVtcy5cclxuICpcclxuICogSWYgeW91IHByb3ZpZGUgYSB2YWx1ZSB0byBgcHVzaCgpYCwgdGhlIHZhbHVlIGlzIHdyaXR0ZW4gdG8gdGhlXHJcbiAqIGdlbmVyYXRlZCBsb2NhdGlvbi4gSWYgeW91IGRvbid0IHBhc3MgYSB2YWx1ZSwgbm90aGluZyBpcyB3cml0dGVuIHRvIHRoZVxyXG4gKiBkYXRhYmFzZSBhbmQgdGhlIGNoaWxkIHJlbWFpbnMgZW1wdHkgKGJ1dCB5b3UgY2FuIHVzZSB0aGUgYFJlZmVyZW5jZWBcclxuICogZWxzZXdoZXJlKS5cclxuICpcclxuICogVGhlIHVuaXF1ZSBrZXlzIGdlbmVyYXRlZCBieSBgcHVzaCgpYCBhcmUgb3JkZXJlZCBieSB0aGUgY3VycmVudCB0aW1lLCBzbyB0aGVcclxuICogcmVzdWx0aW5nIGxpc3Qgb2YgaXRlbXMgaXMgY2hyb25vbG9naWNhbGx5IHNvcnRlZC4gVGhlIGtleXMgYXJlIGFsc29cclxuICogZGVzaWduZWQgdG8gYmUgdW5ndWVzc2FibGUgKHRoZXkgY29udGFpbiA3MiByYW5kb20gYml0cyBvZiBlbnRyb3B5KS5cclxuICpcclxuICogU2VlIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNhcHBlbmRfdG9fYV9saXN0X29mX2RhdGEgfCBBcHBlbmQgdG8gYSBsaXN0IG9mIGRhdGF9LlxyXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlYmxvZy5jb20vMjAxNS8wMi90aGUtMjEyMC13YXlzLXRvLWVuc3VyZS11bmlxdWVfNjguaHRtbCB8IFRoZSAyXjEyMCBXYXlzIHRvIEVuc3VyZSBVbmlxdWUgSWRlbnRpZmllcnN9LlxyXG4gKlxyXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCBsb2NhdGlvbi5cclxuICogQHBhcmFtIHZhbHVlIC0gT3B0aW9uYWwgdmFsdWUgdG8gYmUgd3JpdHRlbiBhdCB0aGUgZ2VuZXJhdGVkIGxvY2F0aW9uLlxyXG4gKiBAcmV0dXJucyBDb21iaW5lZCBgUHJvbWlzZWAgYW5kIGBSZWZlcmVuY2VgOyByZXNvbHZlcyB3aGVuIHdyaXRlIGlzIGNvbXBsZXRlLFxyXG4gKiBidXQgY2FuIGJlIHVzZWQgaW1tZWRpYXRlbHkgYXMgdGhlIGBSZWZlcmVuY2VgIHRvIHRoZSBjaGlsZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHB1c2gocGFyZW50LCB2YWx1ZSkge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgncHVzaCcsIHBhcmVudC5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygncHVzaCcsIHZhbHVlLCBwYXJlbnQuX3BhdGgsIHRydWUpO1xyXG4gICAgY29uc3Qgbm93ID0gcmVwb1NlcnZlclRpbWUocGFyZW50Ll9yZXBvKTtcclxuICAgIGNvbnN0IG5hbWUgPSBuZXh0UHVzaElkKG5vdyk7XHJcbiAgICAvLyBwdXNoKCkgcmV0dXJucyBhIFRoZW5uYWJsZVJlZmVyZW5jZSB3aG9zZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFcclxuICAgIC8vIHJlZ3VsYXIgUmVmZXJlbmNlLiBXZSB1c2UgY2hpbGQoKSB0byBjcmVhdGUgaGFuZGxlcyB0byB0d28gZGlmZmVyZW50XHJcbiAgICAvLyByZWZlcmVuY2VzLiBUaGUgZmlyc3QgaXMgdHVybmVkIGludG8gYSBUaGVubmFibGVSZWZlcmVuY2UgYmVsb3cgYnkgYWRkaW5nXHJcbiAgICAvLyB0aGVuKCkgYW5kIGNhdGNoKCkgbWV0aG9kcyBhbmQgaXMgdXNlZCBhcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHB1c2goKS4gVGhlXHJcbiAgICAvLyBzZWNvbmQgcmVtYWlucyBhIHJlZ3VsYXIgUmVmZXJlbmNlIGFuZCBpcyB1c2VkIGFzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2ZcclxuICAgIC8vIHRoZSBmaXJzdCBUaGVubmFibGVSZWZlcmVuY2UuXHJcbiAgICBjb25zdCB0aGVubmFibGVQdXNoUmVmID0gY2hpbGQocGFyZW50LCBuYW1lKTtcclxuICAgIGNvbnN0IHB1c2hSZWYgPSBjaGlsZChwYXJlbnQsIG5hbWUpO1xyXG4gICAgbGV0IHByb21pc2U7XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIHByb21pc2UgPSBzZXQocHVzaFJlZiwgdmFsdWUpLnRoZW4oKCkgPT4gcHVzaFJlZik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHB1c2hSZWYpO1xyXG4gICAgfVxyXG4gICAgdGhlbm5hYmxlUHVzaFJlZi50aGVuID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSk7XHJcbiAgICB0aGVubmFibGVQdXNoUmVmLmNhdGNoID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSwgdW5kZWZpbmVkKTtcclxuICAgIHJldHVybiB0aGVubmFibGVQdXNoUmVmO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBkYXRhIGF0IHRoaXMgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEFueSBkYXRhIGF0IGNoaWxkIGxvY2F0aW9ucyB3aWxsIGFsc28gYmUgZGVsZXRlZC5cclxuICpcclxuICogVGhlIGVmZmVjdCBvZiB0aGUgcmVtb3ZlIHdpbGwgYmUgdmlzaWJsZSBpbW1lZGlhdGVseSBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogZXZlbnQgJ3ZhbHVlJyB3aWxsIGJlIHRyaWdnZXJlZC4gU3luY2hyb25pemF0aW9uIG9mIHRoZSByZW1vdmUgdG8gdGhlXHJcbiAqIEZpcmViYXNlIHNlcnZlcnMgd2lsbCBhbHNvIGJlIHN0YXJ0ZWQsIGFuZCB0aGUgcmV0dXJuZWQgUHJvbWlzZSB3aWxsIHJlc29sdmVcclxuICogd2hlbiBjb21wbGV0ZS4gSWYgcHJvdmlkZWQsIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXHJcbiAqIGFzeW5jaHJvbm91c2x5IGFmdGVyIHN5bmNocm9uaXphdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gcmVtb3ZlLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHJlbW92ZSBvbiBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmUocmVmKSB7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgncmVtb3ZlJywgcmVmLl9wYXRoKTtcclxuICAgIHJldHVybiBzZXQocmVmLCBudWxsKTtcclxufVxyXG4vKipcclxuICogV3JpdGVzIGRhdGEgdG8gdGhpcyBEYXRhYmFzZSBsb2NhdGlvbi5cclxuICpcclxuICogVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGFuZCBhbGwgY2hpbGQgbG9jYXRpb25zLlxyXG4gKlxyXG4gKiBUaGUgZWZmZWN0IG9mIHRoZSB3cml0ZSB3aWxsIGJlIHZpc2libGUgaW1tZWRpYXRlbHksIGFuZCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiBldmVudHMgKFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLCBldGMuKSB3aWxsIGJlIHRyaWdnZXJlZC4gU3luY2hyb25pemF0aW9uIG9mXHJcbiAqIHRoZSBkYXRhIHRvIHRoZSBGaXJlYmFzZSBzZXJ2ZXJzIHdpbGwgYWxzbyBiZSBzdGFydGVkLCBhbmQgdGhlIHJldHVybmVkXHJcbiAqIFByb21pc2Ugd2lsbCByZXNvbHZlIHdoZW4gY29tcGxldGUuIElmIHByb3ZpZGVkLCB0aGUgYG9uQ29tcGxldGVgIGNhbGxiYWNrXHJcbiAqIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHN5bmNocm9uaXphdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIFBhc3NpbmcgYG51bGxgIGZvciB0aGUgbmV3IHZhbHVlIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgcmVtb3ZlKClgOyBuYW1lbHksXHJcbiAqIGFsbCBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYW5kIGFsbCBjaGlsZCBsb2NhdGlvbnMgd2lsbCBiZSBkZWxldGVkLlxyXG4gKlxyXG4gKiBgc2V0KClgIHdpbGwgcmVtb3ZlIGFueSBwcmlvcml0eSBzdG9yZWQgYXQgdGhpcyBsb2NhdGlvbiwgc28gaWYgcHJpb3JpdHkgaXNcclxuICogbWVhbnQgdG8gYmUgcHJlc2VydmVkLCB5b3UgbmVlZCB0byB1c2UgYHNldFdpdGhQcmlvcml0eSgpYCBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgbW9kaWZ5aW5nIGRhdGEgd2l0aCBgc2V0KClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nIHRyYW5zYWN0aW9uc1xyXG4gKiBhdCB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZyBgc2V0KClgIGFuZFxyXG4gKiBgdHJhbnNhY3Rpb24oKWAgdG8gbW9kaWZ5IHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIEEgc2luZ2xlIGBzZXQoKWAgd2lsbCBnZW5lcmF0ZSBhIHNpbmdsZSBcInZhbHVlXCIgZXZlbnQgYXQgdGhlIGxvY2F0aW9uIHdoZXJlXHJcbiAqIHRoZSBgc2V0KClgIHdhcyBwZXJmb3JtZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LFxyXG4gKiAgIGFycmF5LCBvciBudWxsKS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB3cml0ZSB0byBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXQocmVmLCB2YWx1ZSkge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnc2V0JywgcmVmLl9wYXRoKTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzZXQnLCB2YWx1ZSwgcmVmLl9wYXRoLCBmYWxzZSk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1NldFdpdGhQcmlvcml0eShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWUsIFxyXG4gICAgLypwcmlvcml0eT0qLyBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogU2V0cyBhIHByaW9yaXR5IGZvciB0aGUgZGF0YSBhdCB0aGlzIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICogb3JkaW5hcnkgcHJvcGVydGllcyAoc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8IFNvcnRpbmcgYW5kIGZpbHRlcmluZyBkYXRhfVxyXG4gKiApLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIG9yIG51bGwpLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHdyaXRlIHRvIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldFByaW9yaXR5KHJlZiwgcHJpb3JpdHkpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3NldFByaW9yaXR5JywgcmVmLl9wYXRoKTtcclxuICAgIHZhbGlkYXRlUHJpb3JpdHkoJ3NldFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvU2V0V2l0aFByaW9yaXR5KHJlZi5fcmVwbywgcGF0aENoaWxkKHJlZi5fcGF0aCwgJy5wcmlvcml0eScpLCBwcmlvcml0eSwgbnVsbCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlcyBkYXRhIHRoZSBEYXRhYmFzZSBsb2NhdGlvbi4gTGlrZSBgc2V0KClgIGJ1dCBhbHNvIHNwZWNpZmllcyB0aGVcclxuICogcHJpb3JpdHkgZm9yIHRoYXQgZGF0YS5cclxuICpcclxuICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydGluZ19hbmRfZmlsdGVyaW5nX2RhdGEgfCBTb3J0aW5nIGFuZCBmaWx0ZXJpbmcgZGF0YX1cclxuICogKS5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvYmplY3QsXHJcbiAqICAgYXJyYXksIG9yIG51bGwpLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIG9yIG51bGwpLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHdyaXRlIHRvIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldFdpdGhQcmlvcml0eShyZWYsIHZhbHVlLCBwcmlvcml0eSkge1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3NldFdpdGhQcmlvcml0eScsIHJlZi5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnc2V0V2l0aFByaW9yaXR5JywgdmFsdWUsIHJlZi5fcGF0aCwgZmFsc2UpO1xyXG4gICAgdmFsaWRhdGVQcmlvcml0eSgnc2V0V2l0aFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgIGlmIChyZWYua2V5ID09PSAnLmxlbmd0aCcgfHwgcmVmLmtleSA9PT0gJy5rZXlzJykge1xyXG4gICAgICAgIHRocm93ICdzZXRXaXRoUHJpb3JpdHkgZmFpbGVkOiAnICsgcmVmLmtleSArICcgaXMgYSByZWFkLW9ubHkgb2JqZWN0Lic7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1NldFdpdGhQcmlvcml0eShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogV3JpdGVzIG11bHRpcGxlIHZhbHVlcyB0byB0aGUgRGF0YWJhc2UgYXQgb25jZS5cclxuICpcclxuICogVGhlIGB2YWx1ZXNgIGFyZ3VtZW50IGNvbnRhaW5zIG11bHRpcGxlIHByb3BlcnR5LXZhbHVlIHBhaXJzIHRoYXQgd2lsbCBiZVxyXG4gKiB3cml0dGVuIHRvIHRoZSBEYXRhYmFzZSB0b2dldGhlci4gRWFjaCBjaGlsZCBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlXHJcbiAqIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgXCJuYW1lXCIpIG9yIGEgcmVsYXRpdmUgcGF0aCAoZm9yIGV4YW1wbGUsXHJcbiAqIFwibmFtZS9maXJzdFwiKSBmcm9tIHRoZSBjdXJyZW50IGxvY2F0aW9uIHRvIHRoZSBkYXRhIHRvIHVwZGF0ZS5cclxuICpcclxuICogQXMgb3Bwb3NlZCB0byB0aGUgYHNldCgpYCBtZXRob2QsIGB1cGRhdGUoKWAgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseSB1cGRhdGVcclxuICogb25seSB0aGUgcmVmZXJlbmNlZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIChpbnN0ZWFkIG9mIHJlcGxhY2luZ1xyXG4gKiBhbGwgdGhlIGNoaWxkIHByb3BlcnRpZXMgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24pLlxyXG4gKlxyXG4gKiBUaGUgZWZmZWN0IG9mIHRoZSB3cml0ZSB3aWxsIGJlIHZpc2libGUgaW1tZWRpYXRlbHksIGFuZCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiBldmVudHMgKCd2YWx1ZScsICdjaGlsZF9hZGRlZCcsIGV0Yy4pIHdpbGwgYmUgdHJpZ2dlcmVkLiBTeW5jaHJvbml6YXRpb24gb2ZcclxuICogdGhlIGRhdGEgdG8gdGhlIEZpcmViYXNlIHNlcnZlcnMgd2lsbCBhbHNvIGJlIHN0YXJ0ZWQsIGFuZCB0aGUgcmV0dXJuZWRcclxuICogUHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiBjb21wbGV0ZS4gSWYgcHJvdmlkZWQsIHRoZSBgb25Db21wbGV0ZWAgY2FsbGJhY2tcclxuICogd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgc3luY2hyb25pemF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogQSBzaW5nbGUgYHVwZGF0ZSgpYCB3aWxsIGdlbmVyYXRlIGEgc2luZ2xlIFwidmFsdWVcIiBldmVudCBhdCB0aGUgbG9jYXRpb25cclxuICogd2hlcmUgdGhlIGB1cGRhdGUoKWAgd2FzIHBlcmZvcm1lZCwgcmVnYXJkbGVzcyBvZiBob3cgbWFueSBjaGlsZHJlbiB3ZXJlXHJcbiAqIG1vZGlmaWVkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgbW9kaWZ5aW5nIGRhdGEgd2l0aCBgdXBkYXRlKClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9ucyBhdCB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZ1xyXG4gKiBgdXBkYXRlKClgIGFuZCBgdHJhbnNhY3Rpb24oKWAgdG8gbW9kaWZ5IHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIFBhc3NpbmcgYG51bGxgIHRvIGB1cGRhdGUoKWAgd2lsbCByZW1vdmUgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi5cclxuICpcclxuICogU2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZWJsb2cuY29tLzIwMTUvMDkvaW50cm9kdWNpbmctbXVsdGktbG9jYXRpb24tdXBkYXRlcy1hbmRfODYuaHRtbCB8IEludHJvZHVjaW5nIG11bHRpLWxvY2F0aW9uIHVwZGF0ZXMgYW5kIG1vcmV9LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgdmFsdWVzLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHVwZGF0ZSBvbiBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGUocmVmLCB2YWx1ZXMpIHtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmcoJ3VwZGF0ZScsIHZhbHVlcywgcmVmLl9wYXRoLCBmYWxzZSk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1VwZGF0ZShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWVzLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogR2V0cyB0aGUgbW9zdCB1cC10by1kYXRlIHJlc3VsdCBmb3IgdGhpcyBxdWVyeS5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHJ1bi5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHJlc3VsdGluZyBEYXRhU25hcHNob3QgaWYgYSB2YWx1ZSBpc1xyXG4gKiBhdmFpbGFibGUsIG9yIHJlamVjdHMgaWYgdGhlIGNsaWVudCBpcyB1bmFibGUgdG8gcmV0dXJuIGEgdmFsdWUgKGUuZy4sIGlmIHRoZVxyXG4gKiBzZXJ2ZXIgaXMgdW5yZWFjaGFibGUgYW5kIHRoZXJlIGlzIG5vdGhpbmcgY2FjaGVkKS5cclxuICovXHJcbmZ1bmN0aW9uIGdldChxdWVyeSkge1xyXG4gICAgcXVlcnkgPSBnZXRNb2R1bGFySW5zdGFuY2UocXVlcnkpO1xyXG4gICAgY29uc3QgY2FsbGJhY2tDb250ZXh0ID0gbmV3IENhbGxiYWNrQ29udGV4dCgoKSA9PiB7IH0pO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tDb250ZXh0KTtcclxuICAgIHJldHVybiByZXBvR2V0VmFsdWUocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpLnRoZW4obm9kZSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU25hcHNob3Qobm9kZSwgbmV3IFJlZmVyZW5jZUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoKSwgcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgcmVnaXN0cmF0aW9uIGZvciAndmFsdWUnIGV2ZW50cy5cclxuICovXHJcbmNsYXNzIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2tDb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSBjYWxsYmFja0NvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXNwb25kc1RvKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBldmVudFR5cGUgPT09ICd2YWx1ZSc7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFdmVudChjaGFuZ2UsIHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFFdmVudCgndmFsdWUnLCB0aGlzLCBuZXcgRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIG5ldyBSZWZlcmVuY2VJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCksIGluZGV4KSk7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcihldmVudERhdGEpIHtcclxuICAgICAgICBpZiAoZXZlbnREYXRhLmdldEV2ZW50VHlwZSgpID09PSAnY2FuY2VsJykge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25DYW5jZWwoZXZlbnREYXRhLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vblZhbHVlKGV2ZW50RGF0YS5zbmFwc2hvdCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FuY2VsRXZlbnQoZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWxsYmFja0NvbnRleHQuaGFzQ2FuY2VsQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvdGhlci5jYWxsYmFja0NvbnRleHQgfHwgIXRoaXMuY2FsbGJhY2tDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2UgY29uc2lkZXIgaXQgdG8gbWF0Y2ggYW55IGNhbGxiYWNrLlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5jYWxsYmFja0NvbnRleHQubWF0Y2hlcyh0aGlzLmNhbGxiYWNrQ29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzQW55Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tDb250ZXh0ICE9PSBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSByZWdpc3RyYXRpb24gb2YgYSBjaGlsZF94IGV2ZW50LlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFR5cGUsIGNhbGxiYWNrQ29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gY2FsbGJhY2tDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgcmVzcG9uZHNUbyhldmVudFR5cGUpIHtcclxuICAgICAgICBsZXQgZXZlbnRUb0NoZWNrID0gZXZlbnRUeXBlID09PSAnY2hpbGRyZW5fYWRkZWQnID8gJ2NoaWxkX2FkZGVkJyA6IGV2ZW50VHlwZTtcclxuICAgICAgICBldmVudFRvQ2hlY2sgPVxyXG4gICAgICAgICAgICBldmVudFRvQ2hlY2sgPT09ICdjaGlsZHJlbl9yZW1vdmVkJyA/ICdjaGlsZF9yZW1vdmVkJyA6IGV2ZW50VG9DaGVjaztcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFR5cGUgPT09IGV2ZW50VG9DaGVjaztcclxuICAgIH1cclxuICAgIGNyZWF0ZUNhbmNlbEV2ZW50KGVycm9yLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tDb250ZXh0Lmhhc0NhbmNlbENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FuY2VsRXZlbnQodGhpcywgZXJyb3IsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlRXZlbnQoY2hhbmdlLCBxdWVyeSkge1xyXG4gICAgICAgIGFzc2VydChjaGFuZ2UuY2hpbGROYW1lICE9IG51bGwsICdDaGlsZCBldmVudHMgc2hvdWxkIGhhdmUgYSBjaGlsZE5hbWUuJyk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRSZWYgPSBjaGlsZChuZXcgUmVmZXJlbmNlSW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpLCBjaGFuZ2UuY2hpbGROYW1lKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YUV2ZW50KGNoYW5nZS50eXBlLCB0aGlzLCBuZXcgRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIGNoaWxkUmVmLCBpbmRleCksIGNoYW5nZS5wcmV2TmFtZSk7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcihldmVudERhdGEpIHtcclxuICAgICAgICBpZiAoZXZlbnREYXRhLmdldEV2ZW50VHlwZSgpID09PSAnY2FuY2VsJykge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25DYW5jZWwoZXZlbnREYXRhLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vblZhbHVlKGV2ZW50RGF0YS5zbmFwc2hvdCwgZXZlbnREYXRhLnByZXZOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZXZlbnRUeXBlID09PSBvdGhlci5ldmVudFR5cGUgJiZcclxuICAgICAgICAgICAgICAgICghdGhpcy5jYWxsYmFja0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAhb3RoZXIuY2FsbGJhY2tDb250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQubWF0Y2hlcyhvdGhlci5jYWxsYmFja0NvbnRleHQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGhhc0FueUNhbGxiYWNrKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuY2FsbGJhY2tDb250ZXh0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksIGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgY2FuY2VsQ2FsbGJhY2s7XHJcbiAgICBpZiAodHlwZW9mIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNhbmNlbENhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIG9wdGlvbnMgPSBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vbmx5T25jZSkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGNvbnN0IG9uY2VDYWxsYmFjayA9IChkYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICB1c2VyQ2FsbGJhY2soZGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvbmNlQ2FsbGJhY2sudXNlckNhbGxiYWNrID0gY2FsbGJhY2sudXNlckNhbGxiYWNrO1xyXG4gICAgICAgIG9uY2VDYWxsYmFjay5jb250ZXh0ID0gY2FsbGJhY2suY29udGV4dDtcclxuICAgICAgICBjYWxsYmFjayA9IG9uY2VDYWxsYmFjaztcclxuICAgIH1cclxuICAgIGNvbnN0IGNhbGxiYWNrQ29udGV4dCA9IG5ldyBDYWxsYmFja0NvbnRleHQoY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrIHx8IHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudFR5cGUgPT09ICd2YWx1ZSdcclxuICAgICAgICA/IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrQ29udGV4dClcclxuICAgICAgICA6IG5ldyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50VHlwZSwgY2FsbGJhY2tDb250ZXh0KTtcclxuICAgIHJlcG9BZGRFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG4gICAgcmV0dXJuICgpID0+IHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG9uVmFsdWUocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICd2YWx1ZScsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZEFkZGVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfYWRkZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRDaGFuZ2VkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfY2hhbmdlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZE1vdmVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfbW92ZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRSZW1vdmVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfcmVtb3ZlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIERldGFjaGVzIGEgY2FsbGJhY2sgcHJldmlvdXNseSBhdHRhY2hlZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbiooKWAgKGBvblZhbHVlYCwgYG9uQ2hpbGRBZGRlZGApIGxpc3RlbmVyLlxyXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIHJlbW92ZSBhIGxpc3RlbmVyLiBJbnN0ZWFkLCBwbGVhc2UgdXNlIHRoZSByZXR1cm5lZCBjYWxsYmFjayBmdW5jdGlvbiBmcm9tXHJcbiAqIHRoZSByZXNwZWN0aXZlIGBvbipgIGNhbGxiYWNrcy5cclxuICpcclxuICogRGV0YWNoIGEgY2FsbGJhY2sgcHJldmlvdXNseSBhdHRhY2hlZCB3aXRoIGBvbiooKWAuIENhbGxpbmcgYG9mZigpYCBvbiBhIHBhcmVudCBsaXN0ZW5lclxyXG4gKiB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IHJlbW92ZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBvbiBjaGlsZCBub2RlcywgYG9mZigpYFxyXG4gKiBtdXN0IGFsc28gYmUgY2FsbGVkIG9uIGFueSBjaGlsZCBsaXN0ZW5lcnMgdG8gcmVtb3ZlIHRoZSBjYWxsYmFjay5cclxuICpcclxuICogSWYgYSBjYWxsYmFjayBpcyBub3Qgc3BlY2lmaWVkLCBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50VHlwZVxyXG4gKiB3aWxsIGJlIHJlbW92ZWQuIFNpbWlsYXJseSwgaWYgbm8gZXZlbnRUeXBlIGlzIHNwZWNpZmllZCwgYWxsIGNhbGxiYWNrc1xyXG4gKiBmb3IgdGhlIGBSZWZlcmVuY2VgIHdpbGwgYmUgcmVtb3ZlZC5cclxuICpcclxuICogSW5kaXZpZHVhbCBsaXN0ZW5lcnMgY2FuIGFsc28gYmUgcmVtb3ZlZCBieSBpbnZva2luZyB0aGVpciB1bnN1YnNjcmliZVxyXG4gKiBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0aGF0IHRoZSBsaXN0ZW5lciB3YXMgcmVnaXN0ZXJlZCB3aXRoLlxyXG4gKiBAcGFyYW0gZXZlbnRUeXBlIC0gT25lIG9mIHRoZSBmb2xsb3dpbmcgc3RyaW5nczogXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsXHJcbiAqIFwiY2hpbGRfY2hhbmdlZFwiLCBcImNoaWxkX3JlbW92ZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZC5cIiBJZiBvbWl0dGVkLCBhbGwgY2FsbGJhY2tzXHJcbiAqIGZvciB0aGUgYFJlZmVyZW5jZWAgd2lsbCBiZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3YXMgcGFzc2VkIHRvIGBvbigpYCBvclxyXG4gKiBgdW5kZWZpbmVkYCB0byByZW1vdmUgYWxsIGNhbGxiYWNrcy5cclxuICovXHJcbmZ1bmN0aW9uIG9mZihxdWVyeSwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xyXG4gICAgbGV0IGNvbnRhaW5lciA9IG51bGw7XHJcbiAgICBjb25zdCBleHBDYWxsYmFjayA9IGNhbGxiYWNrID8gbmV3IENhbGxiYWNrQ29udGV4dChjYWxsYmFjaykgOiBudWxsO1xyXG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgIGNvbnRhaW5lciA9IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKGV4cENhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGNvbnRhaW5lciA9IG5ldyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50VHlwZSwgZXhwQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcik7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5Q29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYVxyXG4gKiBEYXRhYmFzZSBxdWVyeS4gYFF1ZXJ5Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayBlbmRBdH0sXHJcbiAqIHtAbGluayBlbmRCZWZvcmV9LCB7QGxpbmsgc3RhcnRBdH0sIHtAbGluayBzdGFydEFmdGVyfSwge0BsaW5rXHJcbiAqIGxpbWl0VG9GaXJzdH0sIHtAbGluayBsaW1pdFRvTGFzdH0sIHtAbGluayBvcmRlckJ5Q2hpbGR9LFxyXG4gKiB7QGxpbmsgb3JkZXJCeUNoaWxkfSwge0BsaW5rIG9yZGVyQnlLZXl9ICwge0BsaW5rIG9yZGVyQnlQcmlvcml0eX0gLFxyXG4gKiB7QGxpbmsgb3JkZXJCeVZhbHVlfSAgb3Ige0BsaW5rIGVxdWFsVG99IGFuZFxyXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIHF1ZXJ5fSB0byBjcmVhdGUgYSBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdFxyXG4gKiBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5Q29uc3RyYWludGAuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUNvbnN0cmFpbnQge1xyXG59XHJcbmNsYXNzIFF1ZXJ5RW5kQXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlbmRBdCcsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnZW5kQmVmb3JlIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIGVuZGluZyBwb2ludC5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgZW5kaW5nIHBvaW50IGlzIGluY2x1c2l2ZSwgc28gY2hpbGRyZW4gd2l0aCBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICogd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkuIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG9cclxuICogZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdFxyXG4gKiBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBhIGtleSBuYW1lIGxlc3MgdGhhbiBvciBlcXVhbFxyXG4gKiB0byB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGVuZEF0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuZCBhdC4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gZW5kIGF0LCBhbW9uZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgcHJldmlvdXNseVxyXG4gKiBzcGVjaWZpZWQgcHJpb3JpdHkuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmIG9yZGVyaW5nIGJ5IGNoaWxkLFxyXG4gKiB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmRBdCh2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnZW5kQXQnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRBdENvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlbmRCZWZvcmUnLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc0VuZEJlZm9yZShxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZEJlZm9yZTogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VuZEJlZm9yZSBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBlbmRpbmcgcG9pbnQgKGV4Y2x1c2l2ZSkuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIGVuZGluZyBwb2ludCBpcyBleGNsdXNpdmUuIElmIG9ubHkgYSB2YWx1ZSBpcyBwcm92aWRlZCwgY2hpbGRyZW5cclxuICogd2l0aCBhIHZhbHVlIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gKiBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gbXVzdCBoYXZlIGEgdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsXHJcbiAqIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgYW5kIGEga2V5IG5hbWUgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5kIGJlZm9yZS4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gZW5kIGJlZm9yZSwgYW1vbmcgdGhlIGNoaWxkcmVuIHdpdGggdGhlXHJcbiAqIHByZXZpb3VzbHkgc3BlY2lmaWVkIHByaW9yaXR5LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZiBvcmRlcmluZyBieVxyXG4gKiBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZW5kQmVmb3JlKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdlbmRCZWZvcmUnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3N0YXJ0QXQnLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnc3RhcnRCZWZvcmUgb3IgZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlDb25zdHJhaW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhcnRpbmcgcG9pbnQuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIGluY2x1c2l2ZSwgc28gY2hpbGRyZW4gd2l0aCBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICogd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkuIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG9cclxuICogZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdFxyXG4gKiBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBhIGtleSBuYW1lIGdyZWF0ZXIgdGhhbiBvclxyXG4gKiBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYHN0YXJ0QXQoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2ZpbHRlcmluZ19kYXRhIHwgRmlsdGVyaW5nIGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RhcnQgYXQuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIHN0YXJ0IGF0LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZlxyXG4gKiBvcmRlcmluZyBieSBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnRBdCh2YWx1ZSA9IG51bGwsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ3N0YXJ0QXQnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh2YWx1ZSwga2V5KTtcclxufVxyXG5jbGFzcyBRdWVyeVN0YXJ0QWZ0ZXJDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzdGFydEFmdGVyJywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNTdGFydEFmdGVyKHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fdmFsdWUsIHRoaXMuX2tleSk7XHJcbiAgICAgICAgdmFsaWRhdGVMaW1pdChuZXdQYXJhbXMpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydEFmdGVyOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0LCAnICtcclxuICAgICAgICAgICAgICAgICdzdGFydEFmdGVyLCBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBzdGFydGluZyBwb2ludCAoZXhjbHVzaXZlKS5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgZXhjbHVzaXZlLiBJZiBvbmx5IGEgdmFsdWUgaXMgcHJvdmlkZWQsIGNoaWxkcmVuXHJcbiAqIHdpdGggYSB2YWx1ZSBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS5cclxuICogSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIG11c3QgaGF2ZSBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxyXG4gKiB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIGFuZCBhIGEga2V5IG5hbWUgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RhcnQgYWZ0ZXIuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIHN0YXJ0IGFmdGVyLiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZlxyXG4gKiBvcmRlcmluZyBieSBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnRBZnRlcih2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnc3RhcnRBZnRlcicsICdrZXknLCBrZXksIHRydWUpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeVN0YXJ0QWZ0ZXJDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5TGltaXRUb0ZpcnN0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfbGltaXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNMaW1pdCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdFRvRmlyc3QgJyArXHJcbiAgICAgICAgICAgICAgICAnb3IgbGltaXRUb0xhc3QpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIHF1ZXJ5UGFyYW1zTGltaXRUb0ZpcnN0KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fbGltaXQpLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBpZiBsaW1pdGVkIHRvIHRoZSBmaXJzdCBzcGVjaWZpYyBudW1iZXJcclxuICogb2YgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIFRoZSBgbGltaXRUb0ZpcnN0KClgIG1ldGhvZCBpcyB1c2VkIHRvIHNldCBhIG1heGltdW0gbnVtYmVyIG9mIGNoaWxkcmVuIHRvIGJlXHJcbiAqIHN5bmNlZCBmb3IgYSBnaXZlbiBjYWxsYmFjay4gSWYgd2Ugc2V0IGEgbGltaXQgb2YgMTAwLCB3ZSB3aWxsIGluaXRpYWxseSBvbmx5XHJcbiAqIHJlY2VpdmUgdXAgdG8gMTAwIGBjaGlsZF9hZGRlZGAgZXZlbnRzLiBJZiB3ZSBoYXZlIGZld2VyIHRoYW4gMTAwIG1lc3NhZ2VzXHJcbiAqIHN0b3JlZCBpbiBvdXIgRGF0YWJhc2UsIGEgYGNoaWxkX2FkZGVkYCBldmVudCB3aWxsIGZpcmUgZm9yIGVhY2ggbWVzc2FnZS5cclxuICogSG93ZXZlciwgaWYgd2UgaGF2ZSBvdmVyIDEwMCBtZXNzYWdlcywgd2Ugd2lsbCBvbmx5IHJlY2VpdmUgYSBgY2hpbGRfYWRkZWRgXHJcbiAqIGV2ZW50IGZvciB0aGUgZmlyc3QgMTAwIG9yZGVyZWQgbWVzc2FnZXMuIEFzIGl0ZW1zIGNoYW5nZSwgd2Ugd2lsbCByZWNlaXZlXHJcbiAqIGBjaGlsZF9yZW1vdmVkYCBldmVudHMgZm9yIGVhY2ggaXRlbSB0aGF0IGRyb3BzIG91dCBvZiB0aGUgYWN0aXZlIGxpc3Qgc29cclxuICogdGhhdCB0aGUgdG90YWwgbnVtYmVyIHN0YXlzIGF0IDEwMC5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGxpbWl0VG9GaXJzdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byBpbmNsdWRlIGluIHRoaXMgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaW1pdFRvRmlyc3QobGltaXQpIHtcclxuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fCBsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUxpbWl0VG9GaXJzdENvbnN0cmFpbnQobGltaXQpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5TGltaXRUb0xhc3RDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF9saW1pdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0xpbWl0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvTGFzdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXRUb0ZpcnN0ICcgK1xyXG4gICAgICAgICAgICAgICAgJ29yIGxpbWl0VG9MYXN0KS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBxdWVyeVBhcmFtc0xpbWl0VG9MYXN0KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fbGltaXQpLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBpcyBsaW1pdGVkIHRvIHJldHVybiBvbmx5IHRoZSBsYXN0XHJcbiAqIHNwZWNpZmllZCBudW1iZXIgb2YgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIFRoZSBgbGltaXRUb0xhc3QoKWAgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IGEgbWF4aW11bSBudW1iZXIgb2YgY2hpbGRyZW4gdG8gYmVcclxuICogc3luY2VkIGZvciBhIGdpdmVuIGNhbGxiYWNrLiBJZiB3ZSBzZXQgYSBsaW1pdCBvZiAxMDAsIHdlIHdpbGwgaW5pdGlhbGx5IG9ubHlcclxuICogcmVjZWl2ZSB1cCB0byAxMDAgYGNoaWxkX2FkZGVkYCBldmVudHMuIElmIHdlIGhhdmUgZmV3ZXIgdGhhbiAxMDAgbWVzc2FnZXNcclxuICogc3RvcmVkIGluIG91ciBEYXRhYmFzZSwgYSBgY2hpbGRfYWRkZWRgIGV2ZW50IHdpbGwgZmlyZSBmb3IgZWFjaCBtZXNzYWdlLlxyXG4gKiBIb3dldmVyLCBpZiB3ZSBoYXZlIG92ZXIgMTAwIG1lc3NhZ2VzLCB3ZSB3aWxsIG9ubHkgcmVjZWl2ZSBhIGBjaGlsZF9hZGRlZGBcclxuICogZXZlbnQgZm9yIHRoZSBsYXN0IDEwMCBvcmRlcmVkIG1lc3NhZ2VzLiBBcyBpdGVtcyBjaGFuZ2UsIHdlIHdpbGwgcmVjZWl2ZVxyXG4gKiBgY2hpbGRfcmVtb3ZlZGAgZXZlbnRzIGZvciBlYWNoIGl0ZW0gdGhhdCBkcm9wcyBvdXQgb2YgdGhlIGFjdGl2ZSBsaXN0IHNvXHJcbiAqIHRoYXQgdGhlIHRvdGFsIG51bWJlciBzdGF5cyBhdCAxMDAuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBsaW1pdFRvTGFzdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byBpbmNsdWRlIGluIHRoaXMgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaW1pdFRvTGFzdChsaW1pdCkge1xyXG4gICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgTWF0aC5mbG9vcihsaW1pdCkgIT09IGxpbWl0IHx8IGxpbWl0IDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbWl0VG9MYXN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUXVlcnlMaW1pdFRvTGFzdENvbnN0cmFpbnQobGltaXQpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeUNoaWxkQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfcGF0aCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksICdvcmRlckJ5Q2hpbGQnKTtcclxuICAgICAgICBjb25zdCBwYXJzZWRQYXRoID0gbmV3IFBhdGgodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhcnNlZFBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBjYW5ub3QgcGFzcyBpbiBlbXB0eSBwYXRoLiBVc2Ugb3JkZXJCeVZhbHVlKCkgaW5zdGVhZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBuZXcgUGF0aEluZGV4KHBhcnNlZFBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIGluZGV4KTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSB0aGUgc3BlY2lmaWVkIGNoaWxkIGtleS5cclxuICpcclxuICogUXVlcmllcyBjYW4gb25seSBvcmRlciBieSBvbmUga2V5IGF0IGEgdGltZS4gQ2FsbGluZyBgb3JkZXJCeUNoaWxkKClgXHJcbiAqIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIHF1ZXJ5IGlzIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBGaXJlYmFzZSBxdWVyaWVzIGFsbG93IHlvdSB0byBvcmRlciB5b3VyIGRhdGEgYnkgYW55IGNoaWxkIGtleSBvbiB0aGUgZmx5LlxyXG4gKiBIb3dldmVyLCBpZiB5b3Uga25vdyBpbiBhZHZhbmNlIHdoYXQgeW91ciBpbmRleGVzIHdpbGwgYmUsIHlvdSBjYW4gZGVmaW5lXHJcbiAqIHRoZW0gdmlhIHRoZSAuaW5kZXhPbiBydWxlIGluIHlvdXIgU2VjdXJpdHkgUnVsZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS4gU2VlXHJcbiAqIHRoZXtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS9zZWN1cml0eS9pbmRleGluZy1kYXRhfVxyXG4gKiBydWxlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgb3JkZXJCeUNoaWxkKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIG9yZGVyIGJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeUNoaWxkKHBhdGgpIHtcclxuICAgIGlmIChwYXRoID09PSAnJGtleScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogXCIka2V5XCIgaXMgaW52YWxpZC4gIFVzZSBvcmRlckJ5S2V5KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdGggPT09ICckcHJpb3JpdHknKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IFwiJHByaW9yaXR5XCIgaXMgaW52YWxpZC4gIFVzZSBvcmRlckJ5UHJpb3JpdHkoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0aCA9PT0gJyR2YWx1ZScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogXCIkdmFsdWVcIiBpcyBpbnZhbGlkLiAgVXNlIG9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoJ29yZGVyQnlDaGlsZCcsICdwYXRoJywgcGF0aCwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlDaGlsZENvbnN0cmFpbnQocGF0aCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5S2V5Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlLZXknKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBLRVlfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHRoZSBrZXkuXHJcbiAqXHJcbiAqIFNvcnRzIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkgYnkgdGhlaXIgKGFzY2VuZGluZykga2V5IHZhbHVlcy5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYG9yZGVyQnlLZXkoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5S2V5KCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlLZXlDb25zdHJhaW50KCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5UHJpb3JpdHlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeVByaW9yaXR5Jyk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHByaW9yaXR5LlxyXG4gKlxyXG4gKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICogb3JkaW5hcnkgcHJvcGVydGllcyAoc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9XHJcbiAqIGZvciBhbHRlcm5hdGl2ZXMgdG8gcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5UHJpb3JpdHkoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeVByaW9yaXR5Q29uc3RyYWludCgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeVZhbHVlQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlWYWx1ZScpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIFZBTFVFX0lOREVYKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSB2YWx1ZS5cclxuICpcclxuICogSWYgdGhlIGNoaWxkcmVuIG9mIGEgcXVlcnkgYXJlIGFsbCBzY2FsYXIgdmFsdWVzIChzdHJpbmcsIG51bWJlciwgb3JcclxuICogYm9vbGVhbiksIHlvdSBjYW4gb3JkZXIgdGhlIHJlc3VsdHMgYnkgdGhlaXIgKGFzY2VuZGluZykgdmFsdWVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgb3JkZXJCeVZhbHVlKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeVZhbHVlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlWYWx1ZUNvbnN0cmFpbnQoKTtcclxufVxyXG5jbGFzcyBRdWVyeUVxdWFsVG9WYWx1ZUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ2VxdWFsVG8nLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcXVhbFRvOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0L3N0YXJ0QWZ0ZXIgb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQvZW5kQmVmb3JlIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpLl9hcHBseShuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KS5fYXBwbHkocXVlcnkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgaW5jbHVkZXMgY2hpbGRyZW4gdGhhdCBtYXRjaCB0aGUgc3BlY2lmaWVkXHJcbiAqIHZhbHVlLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlXHJcbiAqIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdCBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZFxyXG4gKiB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQga2V5IGFzIHRoZWlyIGtleSBuYW1lLiBUaGlzIGNhbiBiZVxyXG4gKiB1c2VkIHRvIGZpbHRlciByZXN1bHQgc2V0cyB3aXRoIG1hbnkgbWF0Y2hlcyBmb3IgdGhlIHNhbWUgdmFsdWUuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBlcXVhbFRvKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIG1hdGNoIGZvci4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYXQsIGFtb25nIHRoZSBjaGlsZHJlbiB3aXRoIHRoZVxyXG4gKiBwcmV2aW91c2x5IHNwZWNpZmllZCBwcmlvcml0eS4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWYgb3JkZXJpbmcgYnlcclxuICogY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIGVxdWFsVG8odmFsdWUsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ2VxdWFsVG8nLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFcXVhbFRvVmFsdWVDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBpbnN0YW5jZSBvZiBgUXVlcnlgIHRoYXQgaXMgZXh0ZW5kZWQgdG8gYWxzbyBpbmNsdWRlXHJcbiAqIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBRdWVyeSBpbnN0YW5jZSB0byB1c2UgYXMgYSBiYXNlIGZvciB0aGUgbmV3IGNvbnN0cmFpbnRzLlxyXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIFRoZSBsaXN0IG9mIGBRdWVyeUNvbnN0cmFpbnRgcyB0byBhcHBseS5cclxuICogQHRocm93cyBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIHF1ZXJ5IGNvbnN0cmFpbnRzIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIHRoZVxyXG4gKiBleGlzdGluZyBvciBuZXcgY29uc3RyYWludHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeShxdWVyeSwgLi4ucXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgbGV0IHF1ZXJ5SW1wbCA9IGdldE1vZHVsYXJJbnN0YW5jZShxdWVyeSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgcXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgICAgIHF1ZXJ5SW1wbCA9IGNvbnN0cmFpbnQuX2FwcGx5KHF1ZXJ5SW1wbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlJbXBsO1xyXG59XHJcbi8qKlxyXG4gKiBEZWZpbmUgcmVmZXJlbmNlIGNvbnN0cnVjdG9yIGluIHZhcmlvdXMgbW9kdWxlc1xyXG4gKlxyXG4gKiBXZSBhcmUgZG9pbmcgdGhpcyBoZXJlIHRvIGF2b2lkIHNldmVyYWwgY2lyY3VsYXJcclxuICogZGVwZW5kZW5jeSBpc3N1ZXNcclxuICovXHJcbnN5bmNQb2ludFNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKFJlZmVyZW5jZUltcGwpO1xyXG5zeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKFJlZmVyZW5jZUltcGwpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyB2YXJpYWJsZSBpcyBhbHNvIGRlZmluZWQgaW4gdGhlIGZpcmViYXNlIE5vZGUuanMgQWRtaW4gU0RLLiBCZWZvcmVcclxuICogbW9kaWZ5aW5nIHRoaXMgZGVmaW5pdGlvbiwgY29uc3VsdCB0aGUgZGVmaW5pdGlvbiBpbjpcclxuICpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWFkbWluLW5vZGVcclxuICpcclxuICogYW5kIG1ha2Ugc3VyZSB0aGUgdHdvIGFyZSBjb25zaXN0ZW50LlxyXG4gKi9cclxuY29uc3QgRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVF9WQVIgPSAnRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCBjYWNoZXMgYFJlcG9gIGluc3RhbmNlcy5cclxuICovXHJcbmNvbnN0IHJlcG9zID0ge307XHJcbi8qKlxyXG4gKiBJZiB0cnVlLCBhbnkgbmV3IGBSZXBvYCB3aWxsIGJlIGNyZWF0ZWQgdG8gdXNlIGBSZWFkb25seVJlc3RDbGllbnRgIChmb3IgdGVzdGluZyBwdXJwb3NlcykuXHJcbiAqL1xyXG5sZXQgdXNlUmVzdENsaWVudCA9IGZhbHNlO1xyXG4vKipcclxuICogVXBkYXRlIGFuIGV4aXN0aW5nIGBSZXBvYCBpbiBwbGFjZSB0byBwb2ludCB0byBhIG5ldyBob3N0L3BvcnQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckFwcGx5RW11bGF0b3JTZXR0aW5ncyhyZXBvLCBob3N0LCBwb3J0LCB0b2tlblByb3ZpZGVyKSB7XHJcbiAgICByZXBvLnJlcG9JbmZvXyA9IG5ldyBSZXBvSW5mbyhgJHtob3N0fToke3BvcnR9YCwgXHJcbiAgICAvKiBzZWN1cmU9ICovIGZhbHNlLCByZXBvLnJlcG9JbmZvXy5uYW1lc3BhY2UsIHJlcG8ucmVwb0luZm9fLndlYlNvY2tldE9ubHksIHJlcG8ucmVwb0luZm9fLm5vZGVBZG1pbiwgcmVwby5yZXBvSW5mb18ucGVyc2lzdGVuY2VLZXksIHJlcG8ucmVwb0luZm9fLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zLCBcclxuICAgIC8qaXNVc2luZ0VtdWxhdG9yPSovIHRydWUpO1xyXG4gICAgaWYgKHRva2VuUHJvdmlkZXIpIHtcclxuICAgICAgICByZXBvLmF1dGhUb2tlblByb3ZpZGVyXyA9IHRva2VuUHJvdmlkZXI7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgdG8gQ1JFQVRFIGEgbmV3IGRhdGFiYXNlIGluc3RhbmNlLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwKGFwcCwgYXV0aFByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyLCB1cmwsIG5vZGVBZG1pbikge1xyXG4gICAgbGV0IGRiVXJsID0gdXJsIHx8IGFwcC5vcHRpb25zLmRhdGFiYXNlVVJMO1xyXG4gICAgaWYgKGRiVXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoIWFwcC5vcHRpb25zLnByb2plY3RJZCkge1xyXG4gICAgICAgICAgICBmYXRhbChcIkNhbid0IGRldGVybWluZSBGaXJlYmFzZSBEYXRhYmFzZSBVUkwuIEJlIHN1cmUgdG8gaW5jbHVkZSBcIiArXHJcbiAgICAgICAgICAgICAgICAnIGEgUHJvamVjdCBJRCB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCgpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2coJ1VzaW5nIGRlZmF1bHQgaG9zdCBmb3IgcHJvamVjdCAnLCBhcHAub3B0aW9ucy5wcm9qZWN0SWQpO1xyXG4gICAgICAgIGRiVXJsID0gYCR7YXBwLm9wdGlvbnMucHJvamVjdElkfS1kZWZhdWx0LXJ0ZGIuZmlyZWJhc2Vpby5jb21gO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhcnNlZFVybCA9IHBhcnNlUmVwb0luZm8oZGJVcmwsIG5vZGVBZG1pbik7XHJcbiAgICBsZXQgcmVwb0luZm8gPSBwYXJzZWRVcmwucmVwb0luZm87XHJcbiAgICBsZXQgaXNFbXVsYXRvcjtcclxuICAgIGxldCBkYkVtdWxhdG9ySG9zdCA9IHVuZGVmaW5lZDtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYpIHtcclxuICAgICAgICBkYkVtdWxhdG9ySG9zdCA9IHByb2Nlc3MuZW52W0ZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1RfVkFSXTtcclxuICAgIH1cclxuICAgIGlmIChkYkVtdWxhdG9ySG9zdCkge1xyXG4gICAgICAgIGlzRW11bGF0b3IgPSB0cnVlO1xyXG4gICAgICAgIGRiVXJsID0gYGh0dHA6Ly8ke2RiRW11bGF0b3JIb3N0fT9ucz0ke3JlcG9JbmZvLm5hbWVzcGFjZX1gO1xyXG4gICAgICAgIHBhcnNlZFVybCA9IHBhcnNlUmVwb0luZm8oZGJVcmwsIG5vZGVBZG1pbik7XHJcbiAgICAgICAgcmVwb0luZm8gPSBwYXJzZWRVcmwucmVwb0luZm87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc0VtdWxhdG9yID0gIXBhcnNlZFVybC5yZXBvSW5mby5zZWN1cmU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoVG9rZW5Qcm92aWRlciA9IG5vZGVBZG1pbiAmJiBpc0VtdWxhdG9yXHJcbiAgICAgICAgPyBuZXcgRW11bGF0b3JUb2tlblByb3ZpZGVyKEVtdWxhdG9yVG9rZW5Qcm92aWRlci5PV05FUilcclxuICAgICAgICA6IG5ldyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyKGFwcC5uYW1lLCBhcHAub3B0aW9ucywgYXV0aFByb3ZpZGVyKTtcclxuICAgIHZhbGlkYXRlVXJsKCdJbnZhbGlkIEZpcmViYXNlIERhdGFiYXNlIFVSTCcsIHBhcnNlZFVybCk7XHJcbiAgICBpZiAoIXBhdGhJc0VtcHR5KHBhcnNlZFVybC5wYXRoKSkge1xyXG4gICAgICAgIGZhdGFsKCdEYXRhYmFzZSBVUkwgbXVzdCBwb2ludCB0byB0aGUgcm9vdCBvZiBhIEZpcmViYXNlIERhdGFiYXNlICcgK1xyXG4gICAgICAgICAgICAnKG5vdCBpbmNsdWRpbmcgYSBjaGlsZCBwYXRoKS4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcG8gPSByZXBvTWFuYWdlckNyZWF0ZVJlcG8ocmVwb0luZm8sIGFwcCwgYXV0aFRva2VuUHJvdmlkZXIsIG5ldyBBcHBDaGVja1Rva2VuUHJvdmlkZXIoYXBwLm5hbWUsIGFwcENoZWNrUHJvdmlkZXIpKTtcclxuICAgIHJldHVybiBuZXcgRGF0YWJhc2UocmVwbywgYXBwKTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIHRoZSByZXBvIGFuZCBtYWtlIHN1cmUgaXQgaXMgZGlzY29ubmVjdGVkLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJEZWxldGVSZXBvKHJlcG8sIGFwcE5hbWUpIHtcclxuICAgIGNvbnN0IGFwcFJlcG9zID0gcmVwb3NbYXBwTmFtZV07XHJcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uLi5cclxuICAgIGlmICghYXBwUmVwb3MgfHwgYXBwUmVwb3NbcmVwby5rZXldICE9PSByZXBvKSB7XHJcbiAgICAgICAgZmF0YWwoYERhdGFiYXNlICR7YXBwTmFtZX0oJHtyZXBvLnJlcG9JbmZvX30pIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZC5gKTtcclxuICAgIH1cclxuICAgIHJlcG9JbnRlcnJ1cHQocmVwbyk7XHJcbiAgICBkZWxldGUgYXBwUmVwb3NbcmVwby5rZXldO1xyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmVzIGEgcmVwbyBkb2Vzbid0IGFscmVhZHkgZXhpc3QgYW5kIHRoZW4gY3JlYXRlcyBvbmUgdXNpbmcgdGhlXHJcbiAqIHByb3ZpZGVkIGFwcC5cclxuICpcclxuICogQHBhcmFtIHJlcG9JbmZvIC0gVGhlIG1ldGFkYXRhIGFib3V0IHRoZSBSZXBvXHJcbiAqIEByZXR1cm5zIFRoZSBSZXBvIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBzZXJ2ZXIgLyByZXBvTmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyQ3JlYXRlUmVwbyhyZXBvSW5mbywgYXBwLCBhdXRoVG9rZW5Qcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlcikge1xyXG4gICAgbGV0IGFwcFJlcG9zID0gcmVwb3NbYXBwLm5hbWVdO1xyXG4gICAgaWYgKCFhcHBSZXBvcykge1xyXG4gICAgICAgIGFwcFJlcG9zID0ge307XHJcbiAgICAgICAgcmVwb3NbYXBwLm5hbWVdID0gYXBwUmVwb3M7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVwbyA9IGFwcFJlcG9zW3JlcG9JbmZvLnRvVVJMU3RyaW5nKCldO1xyXG4gICAgaWYgKHJlcG8pIHtcclxuICAgICAgICBmYXRhbCgnRGF0YWJhc2UgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YWJhc2UgVVJMIG1hdGNoZXMgd2l0aCBlYWNoIGRhdGFiYXNlKCkgY2FsbC4nKTtcclxuICAgIH1cclxuICAgIHJlcG8gPSBuZXcgUmVwbyhyZXBvSW5mbywgdXNlUmVzdENsaWVudCwgYXV0aFRva2VuUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIpO1xyXG4gICAgYXBwUmVwb3NbcmVwb0luZm8udG9VUkxTdHJpbmcoKV0gPSByZXBvO1xyXG4gICAgcmV0dXJuIHJlcG87XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlcyB1cyB0byB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24gZm9yIG5ldyBSZXBvcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRm9yY2VSZXN0Q2xpZW50KGZvcmNlUmVzdENsaWVudCkge1xyXG4gICAgdXNlUmVzdENsaWVudCA9IGZvcmNlUmVzdENsaWVudDtcclxufVxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgRmlyZWJhc2UgUmVhbHRpbWUgRGF0YWJhc2UuXHJcbiAqL1xyXG5jbGFzcyBEYXRhYmFzZSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG9JbnRlcm5hbCwgXHJcbiAgICAvKiogVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBhc3NvY2lhdGVkIHdpdGggdGhpcyBSZWFsdGltZSBEYXRhYmFzZSBpbnN0YW5jZS4gKi9cclxuICAgIGFwcCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG9JbnRlcm5hbCA9IF9yZXBvSW50ZXJuYWw7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgLyoqIFJlcHJlc2VudHMgYSBgRGF0YWJhc2VgIGluc3RhbmNlLiAqL1xyXG4gICAgICAgIHRoaXNbJ3R5cGUnXSA9ICdkYXRhYmFzZSc7XHJcbiAgICAgICAgLyoqIFRyYWNrIGlmIHRoZSBpbnN0YW5jZSBoYXMgYmVlbiB1c2VkIChyb290IG9yIHJlcG8gYWNjZXNzZWQpICovXHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2VTdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXQgX3JlcG8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmVwb1N0YXJ0KHRoaXMuX3JlcG9JbnRlcm5hbCwgdGhpcy5hcHAub3B0aW9ucy5hcHBJZCwgdGhpcy5hcHAub3B0aW9uc1snZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZSddKTtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcG9JbnRlcm5hbDtcclxuICAgIH1cclxuICAgIGdldCBfcm9vdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RJbnRlcm5hbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290SW50ZXJuYWwgPSBuZXcgUmVmZXJlbmNlSW1wbCh0aGlzLl9yZXBvLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290SW50ZXJuYWw7XHJcbiAgICB9XHJcbiAgICBfZGVsZXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290SW50ZXJuYWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVwb01hbmFnZXJEZWxldGVSZXBvKHRoaXMuX3JlcG8sIHRoaXMuYXBwLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvSW50ZXJuYWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9yb290SW50ZXJuYWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBfY2hlY2tOb3REZWxldGVkKGFwaU5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdEludGVybmFsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKCdDYW5ub3QgY2FsbCAnICsgYXBpTmFtZSArICcgb24gYSBkZWxldGVkIGRhdGFiYXNlLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1RyYW5zcG9ydEluaXQoKSB7XHJcbiAgICBpZiAoVHJhbnNwb3J0TWFuYWdlci5JU19UUkFOU1BPUlRfSU5JVElBTElaRUQpIHtcclxuICAgICAgICB3YXJuKCdUcmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGNhbGwgdGhpcyBmdW5jdGlvbiBiZWZvcmUgY2FsbGluZyByZWYgb3Igc2V0dGluZyB1cCBhIGxpc3RlbmVyJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlIHRoZSB1c2Ugb2Ygd2Vic29ja2V0cyBpbnN0ZWFkIG9mIGxvbmdQb2xsaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZm9yY2VXZWJTb2NrZXRzKCkge1xyXG4gICAgY2hlY2tUcmFuc3BvcnRJbml0KCk7XHJcbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdygpO1xyXG59XHJcbi8qKlxyXG4gKiBGb3JjZSB0aGUgdXNlIG9mIGxvbmdQb2xsaW5nIGluc3RlYWQgb2Ygd2Vic29ja2V0cy4gVGhpcyB3aWxsIGJlIGlnbm9yZWQgaWYgd2Vic29ja2V0IHByb3RvY29sIGlzIHVzZWQgaW4gZGF0YWJhc2VVUkwuXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JjZUxvbmdQb2xsaW5nKCkge1xyXG4gICAgY2hlY2tUcmFuc3BvcnRJbml0KCk7XHJcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3coKTtcclxuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93KCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBSZWFsdGltZSBEYXRhYmFzZSBTREsgdGhhdCBpcyBhc3NvY2lhdGVkXHJcbiAqIHdpdGggdGhlIHByb3ZpZGVkIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfS4gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugd2l0aFxyXG4gKiB3aXRoIGRlZmF1bHQgc2V0dGluZ3MgaWYgbm8gaW5zdGFuY2UgZXhpc3RzIG9yIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSB1c2VzXHJcbiAqIGEgY3VzdG9tIGRhdGFiYXNlIFVSTC5cclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UgdGhhdCB0aGUgcmV0dXJuZWQgUmVhbHRpbWVcclxuICogRGF0YWJhc2UgaW5zdGFuY2UgaXMgYXNzb2NpYXRlZCB3aXRoLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBvZiB0aGUgUmVhbHRpbWUgRGF0YWJhc2UgaW5zdGFuY2UgdG8gY29ubmVjdCB0by4gSWYgbm90XHJcbiAqIHByb3ZpZGVkLCB0aGUgU0RLIGNvbm5lY3RzIHRvIHRoZSBkZWZhdWx0IGluc3RhbmNlIG9mIHRoZSBGaXJlYmFzZSBBcHAuXHJcbiAqIEByZXR1cm5zIFRoZSBgRGF0YWJhc2VgIGluc3RhbmNlIG9mIHRoZSBwcm92aWRlZCBhcHAuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREYXRhYmFzZShhcHAgPSBnZXRBcHAoKSwgdXJsKSB7XHJcbiAgICBjb25zdCBkYiA9IF9nZXRQcm92aWRlcihhcHAsICdkYXRhYmFzZScpLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgaWRlbnRpZmllcjogdXJsXHJcbiAgICB9KTtcclxuICAgIGlmICghZGIuX2luc3RhbmNlU3RhcnRlZCkge1xyXG4gICAgICAgIGNvbnN0IGVtdWxhdG9yID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0KCdkYXRhYmFzZScpO1xyXG4gICAgICAgIGlmIChlbXVsYXRvcikge1xyXG4gICAgICAgICAgICBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcihkYiwgLi4uZW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYjtcclxufVxyXG4vKipcclxuICogTW9kaWZ5IHRoZSBwcm92aWRlZCBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBSZWFsdGltZSBEYXRhYmFzZVxyXG4gKiBlbXVsYXRvci5cclxuICpcclxuICogPHA+Tm90ZTogVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHBlcmZvcm1pbmcgYW55IG90aGVyIG9wZXJhdGlvbi5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGluc3RhbmNlIHRvIG1vZGlmeS5cclxuICogQHBhcmFtIGhvc3QgLSBUaGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdClcclxuICogQHBhcmFtIHBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCAoZXg6IDgwODApXHJcbiAqIEBwYXJhbSBvcHRpb25zLm1vY2tVc2VyVG9rZW4gLSB0aGUgbW9jayBhdXRoIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nIFNlY3VyaXR5IFJ1bGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcihkYiwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCd1c2VFbXVsYXRvcicpO1xyXG4gICAgaWYgKGRiLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICBmYXRhbCgnQ2Fubm90IGNhbGwgdXNlRW11bGF0b3IoKSBhZnRlciBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwbyA9IGRiLl9yZXBvSW50ZXJuYWw7XHJcbiAgICBsZXQgdG9rZW5Qcm92aWRlciA9IHVuZGVmaW5lZDtcclxuICAgIGlmIChyZXBvLnJlcG9JbmZvXy5ub2RlQWRtaW4pIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5tb2NrVXNlclRva2VuKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKCdtb2NrVXNlclRva2VuIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEFkbWluIFNESy4gRm9yIGNsaWVudCBhY2Nlc3Mgd2l0aCBtb2NrIHVzZXJzLCBwbGVhc2UgdXNlIHRoZSBcImZpcmViYXNlXCIgcGFja2FnZSBpbnN0ZWFkIG9mIFwiZmlyZWJhc2UtYWRtaW5cIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9rZW5Qcm92aWRlciA9IG5ldyBFbXVsYXRvclRva2VuUHJvdmlkZXIoRW11bGF0b3JUb2tlblByb3ZpZGVyLk9XTkVSKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbnMubW9ja1VzZXJUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHRva2VuID0gdHlwZW9mIG9wdGlvbnMubW9ja1VzZXJUb2tlbiA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBvcHRpb25zLm1vY2tVc2VyVG9rZW5cclxuICAgICAgICAgICAgOiBjcmVhdGVNb2NrVXNlclRva2VuKG9wdGlvbnMubW9ja1VzZXJUb2tlbiwgZGIuYXBwLm9wdGlvbnMucHJvamVjdElkKTtcclxuICAgICAgICB0b2tlblByb3ZpZGVyID0gbmV3IEVtdWxhdG9yVG9rZW5Qcm92aWRlcih0b2tlbik7XHJcbiAgICB9XHJcbiAgICAvLyBNb2RpZnkgdGhlIHJlcG8gdG8gYXBwbHkgZW11bGF0b3Igc2V0dGluZ3NcclxuICAgIHJlcG9NYW5hZ2VyQXBwbHlFbXVsYXRvclNldHRpbmdzKHJlcG8sIGhvc3QsIHBvcnQsIHRva2VuUHJvdmlkZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBEaXNjb25uZWN0cyBmcm9tIHRoZSBzZXJ2ZXIgKGFsbCBEYXRhYmFzZSBvcGVyYXRpb25zIHdpbGwgYmUgY29tcGxldGVkXHJcbiAqIG9mZmxpbmUpLlxyXG4gKlxyXG4gKiBUaGUgY2xpZW50IGF1dG9tYXRpY2FsbHkgbWFpbnRhaW5zIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRvIHRoZSBEYXRhYmFzZVxyXG4gKiBzZXJ2ZXIsIHdoaWNoIHdpbGwgcmVtYWluIGFjdGl2ZSBpbmRlZmluaXRlbHkgYW5kIHJlY29ubmVjdCB3aGVuXHJcbiAqIGRpc2Nvbm5lY3RlZC4gSG93ZXZlciwgdGhlIGBnb09mZmxpbmUoKWAgYW5kIGBnb09ubGluZSgpYCBtZXRob2RzIG1heSBiZSB1c2VkXHJcbiAqIHRvIGNvbnRyb2wgdGhlIGNsaWVudCBjb25uZWN0aW9uIGluIGNhc2VzIHdoZXJlIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIGlzXHJcbiAqIHVuZGVzaXJhYmxlLlxyXG4gKlxyXG4gKiBXaGlsZSBvZmZsaW5lLCB0aGUgY2xpZW50IHdpbGwgbm8gbG9uZ2VyIHJlY2VpdmUgZGF0YSB1cGRhdGVzIGZyb20gdGhlXHJcbiAqIERhdGFiYXNlLiBIb3dldmVyLCBhbGwgRGF0YWJhc2Ugb3BlcmF0aW9ucyBwZXJmb3JtZWQgbG9jYWxseSB3aWxsIGNvbnRpbnVlIHRvXHJcbiAqIGltbWVkaWF0ZWx5IGZpcmUgZXZlbnRzLCBhbGxvd2luZyB5b3VyIGFwcGxpY2F0aW9uIHRvIGNvbnRpbnVlIGJlaGF2aW5nXHJcbiAqIG5vcm1hbGx5LiBBZGRpdGlvbmFsbHksIGVhY2ggb3BlcmF0aW9uIHBlcmZvcm1lZCBsb2NhbGx5IHdpbGwgYXV0b21hdGljYWxseVxyXG4gKiBiZSBxdWV1ZWQgYW5kIHJldHJpZWQgdXBvbiByZWNvbm5lY3Rpb24gdG8gdGhlIERhdGFiYXNlIHNlcnZlci5cclxuICpcclxuICogVG8gcmVjb25uZWN0IHRvIHRoZSBEYXRhYmFzZSBhbmQgYmVnaW4gcmVjZWl2aW5nIHJlbW90ZSBldmVudHMsIHNlZVxyXG4gKiBgZ29PbmxpbmUoKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBpbnN0YW5jZSB0byBkaXNjb25uZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ29PZmZsaW5lKGRiKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdnb09mZmxpbmUnKTtcclxuICAgIHJlcG9JbnRlcnJ1cHQoZGIuX3JlcG8pO1xyXG59XHJcbi8qKlxyXG4gKiBSZWNvbm5lY3RzIHRvIHRoZSBzZXJ2ZXIgYW5kIHN5bmNocm9uaXplcyB0aGUgb2ZmbGluZSBEYXRhYmFzZSBzdGF0ZVxyXG4gKiB3aXRoIHRoZSBzZXJ2ZXIgc3RhdGUuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGFmdGVyIGRpc2FibGluZyB0aGUgYWN0aXZlIGNvbm5lY3Rpb24gd2l0aFxyXG4gKiBgZ29PZmZsaW5lKClgLiBPbmNlIHJlY29ubmVjdGVkLCB0aGUgY2xpZW50IHdpbGwgdHJhbnNtaXQgdGhlIHByb3BlciBkYXRhXHJcbiAqIGFuZCBmaXJlIHRoZSBhcHByb3ByaWF0ZSBldmVudHMgc28gdGhhdCB5b3VyIGNsaWVudCBcImNhdGNoZXMgdXBcIlxyXG4gKiBhdXRvbWF0aWNhbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgaW5zdGFuY2UgdG8gcmVjb25uZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ29PbmxpbmUoZGIpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ2dvT25saW5lJyk7XHJcbiAgICByZXBvUmVzdW1lKGRiLl9yZXBvKTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVMb2dnaW5nKGxvZ2dlciwgcGVyc2lzdGVudCkge1xyXG4gICAgZW5hYmxlTG9nZ2luZyQxKGxvZ2dlciwgcGVyc2lzdGVudCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJEYXRhYmFzZSh2YXJpYW50KSB7XHJcbiAgICBzZXRTREtWZXJzaW9uKFNES19WRVJTSU9OJDEpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2RhdGFiYXNlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IHVybCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBhdXRoUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnKTtcclxuICAgICAgICBjb25zdCBhcHBDaGVja1Byb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcclxuICAgICAgICByZXR1cm4gcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCk7XHJcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKS5zZXRNdWx0aXBsZUluc3RhbmNlcyh0cnVlKSk7XHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgU0VSVkVSX1RJTUVTVEFNUCA9IHtcclxuICAgICcuc3YnOiAndGltZXN0YW1wJ1xyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBhIHBsYWNlaG9sZGVyIHZhbHVlIGZvciBhdXRvLXBvcHVsYXRpbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wICh0aW1lXHJcbiAqIHNpbmNlIHRoZSBVbml4IGVwb2NoLCBpbiBtaWxsaXNlY29uZHMpIGFzIGRldGVybWluZWQgYnkgdGhlIEZpcmViYXNlXHJcbiAqIHNlcnZlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJ2ZXJUaW1lc3RhbXAoKSB7XHJcbiAgICByZXR1cm4gU0VSVkVSX1RJTUVTVEFNUDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHBsYWNlaG9sZGVyIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXRvbWljYWxseSBpbmNyZW1lbnQgdGhlXHJcbiAqIGN1cnJlbnQgZGF0YWJhc2UgdmFsdWUgYnkgdGhlIHByb3ZpZGVkIGRlbHRhLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGVsdGEgLSB0aGUgYW1vdW50IHRvIG1vZGlmeSB0aGUgY3VycmVudCB2YWx1ZSBhdG9taWNhbGx5LlxyXG4gKiBAcmV0dXJucyBBIHBsYWNlaG9sZGVyIHZhbHVlIGZvciBtb2RpZnlpbmcgZGF0YSBhdG9taWNhbGx5IHNlcnZlci1zaWRlLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5jcmVtZW50KGRlbHRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICcuc3YnOiB7XHJcbiAgICAgICAgICAgICdpbmNyZW1lbnQnOiBkZWx0YVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgdHlwZSBmb3IgdGhlIHJlc29sdmUgdmFsdWUgb2Yge0BsaW5rIHJ1blRyYW5zYWN0aW9ufS5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uUmVzdWx0IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBXaGV0aGVyIHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZC4gKi9cclxuICAgIGNvbW1pdHRlZCwgXHJcbiAgICAvKiogVGhlIHJlc3VsdGluZyBkYXRhIHNuYXBzaG90LiAqL1xyXG4gICAgc25hcHNob3QpIHtcclxuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGNvbW1pdHRlZDtcclxuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LiAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IGNvbW1pdHRlZDogdGhpcy5jb21taXR0ZWQsIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90LnRvSlNPTigpIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEF0b21pY2FsbHkgbW9kaWZpZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi5cclxuICpcclxuICogQXRvbWljYWxseSBtb2RpZnkgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi4gVW5saWtlIGEgbm9ybWFsIGBzZXQoKWAsIHdoaWNoXHJcbiAqIGp1c3Qgb3ZlcndyaXRlcyB0aGUgZGF0YSByZWdhcmRsZXNzIG9mIGl0cyBwcmV2aW91cyB2YWx1ZSwgYHJ1blRyYW5zYWN0aW9uKClgIGlzXHJcbiAqIHVzZWQgdG8gbW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byBhIG5ldyB2YWx1ZSwgZW5zdXJpbmcgdGhlcmUgYXJlIG5vXHJcbiAqIGNvbmZsaWN0cyB3aXRoIG90aGVyIGNsaWVudHMgd3JpdGluZyB0byB0aGUgc2FtZSBsb2NhdGlvbiBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gKlxyXG4gKiBUbyBhY2NvbXBsaXNoIHRoaXMsIHlvdSBwYXNzIGBydW5UcmFuc2FjdGlvbigpYCBhbiB1cGRhdGUgZnVuY3Rpb24gd2hpY2ggaXNcclxuICogdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGN1cnJlbnQgdmFsdWUgaW50byBhIG5ldyB2YWx1ZS4gSWYgYW5vdGhlciBjbGllbnRcclxuICogd3JpdGVzIHRvIHRoZSBsb2NhdGlvbiBiZWZvcmUgeW91ciBuZXcgdmFsdWUgaXMgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4sIHlvdXJcclxuICogdXBkYXRlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGggdGhlIG5ldyBjdXJyZW50IHZhbHVlLCBhbmQgdGhlXHJcbiAqIHdyaXRlIHdpbGwgYmUgcmV0cmllZC4gVGhpcyB3aWxsIGhhcHBlbiByZXBlYXRlZGx5IHVudGlsIHlvdXIgd3JpdGUgc3VjY2VlZHNcclxuICogd2l0aG91dCBjb25mbGljdCBvciB5b3UgYWJvcnQgdGhlIHRyYW5zYWN0aW9uIGJ5IG5vdCByZXR1cm5pbmcgYSB2YWx1ZSBmcm9tXHJcbiAqIHlvdXIgdXBkYXRlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBOb3RlOiBNb2RpZnlpbmcgZGF0YSB3aXRoIGBzZXQoKWAgd2lsbCBjYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNhY3Rpb25zIGF0XHJcbiAqIHRoYXQgbG9jYXRpb24sIHNvIGV4dHJlbWUgY2FyZSBzaG91bGQgYmUgdGFrZW4gaWYgbWl4aW5nIGBzZXQoKWAgYW5kXHJcbiAqIGBydW5UcmFuc2FjdGlvbigpYCB0byB1cGRhdGUgdGhlIHNhbWUgZGF0YS5cclxuICpcclxuICogTm90ZTogV2hlbiB1c2luZyB0cmFuc2FjdGlvbnMgd2l0aCBTZWN1cml0eSBhbmQgRmlyZWJhc2UgUnVsZXMgaW4gcGxhY2UsIGJlXHJcbiAqIGF3YXJlIHRoYXQgYSBjbGllbnQgbmVlZHMgYC5yZWFkYCBhY2Nlc3MgaW4gYWRkaXRpb24gdG8gYC53cml0ZWAgYWNjZXNzIGluXHJcbiAqIG9yZGVyIHRvIHBlcmZvcm0gYSB0cmFuc2FjdGlvbi4gVGhpcyBpcyBiZWNhdXNlIHRoZSBjbGllbnQtc2lkZSBuYXR1cmUgb2ZcclxuICogdHJhbnNhY3Rpb25zIHJlcXVpcmVzIHRoZSBjbGllbnQgdG8gcmVhZCB0aGUgZGF0YSBpbiBvcmRlciB0byB0cmFuc2FjdGlvbmFsbHlcclxuICogdXBkYXRlIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIGF0b21pY2FsbHkgbW9kaWZ5LlxyXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25VcGRhdGUgLSBBIGRldmVsb3Blci1zdXBwbGllZCBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHBhc3NlZFxyXG4gKiB0aGUgY3VycmVudCBkYXRhIHN0b3JlZCBhdCB0aGlzIGxvY2F0aW9uIChhcyBhIEphdmFTY3JpcHQgb2JqZWN0KS4gVGhlXHJcbiAqIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdGhlIG5ldyB2YWx1ZSBpdCB3b3VsZCBsaWtlIHdyaXR0ZW4gKGFzIGEgSmF2YVNjcmlwdFxyXG4gKiBvYmplY3QpLiBJZiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCAoaS5lLiB5b3UgcmV0dXJuIHdpdGggbm8gYXJndW1lbnRzKSB0aGVcclxuICogdHJhbnNhY3Rpb24gd2lsbCBiZSBhYm9ydGVkIGFuZCB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIHdpbGwgbm90IGJlXHJcbiAqIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0cmFuc2FjdGlvbnMuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBgb25Db21wbGV0ZWBcclxuICogY2FsbGJhY2sgdG8gaGFuZGxlIHN1Y2Nlc3MgYW5kIGZhaWx1cmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBydW5UcmFuc2FjdGlvbihyZWYsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG50cmFuc2FjdGlvblVwZGF0ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgcmVmLl9wYXRoKTtcclxuICAgIGlmIChyZWYua2V5ID09PSAnLmxlbmd0aCcgfHwgcmVmLmtleSA9PT0gJy5rZXlzJykge1xyXG4gICAgICAgIHRocm93ICgnUmVmZXJlbmNlLnRyYW5zYWN0aW9uIGZhaWxlZDogJyArIHJlZi5rZXkgKyAnIGlzIGEgcmVhZC1vbmx5IG9iamVjdC4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFwcGx5TG9jYWxseSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hcHBseUxvY2FsbHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY29uc3QgcHJvbWlzZUNvbXBsZXRlID0gKGVycm9yLCBjb21taXR0ZWQsIG5vZGUpID0+IHtcclxuICAgICAgICBsZXQgZGF0YVNuYXBzaG90ID0gbnVsbDtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGFTbmFwc2hvdCA9IG5ldyBEYXRhU25hcHNob3Qobm9kZSwgbmV3IFJlZmVyZW5jZUltcGwocmVmLl9yZXBvLCByZWYuX3BhdGgpLCBQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobmV3IFRyYW5zYWN0aW9uUmVzdWx0KGNvbW1pdHRlZCwgZGF0YVNuYXBzaG90KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEFkZCBhIHdhdGNoIHRvIG1ha2Ugc3VyZSB3ZSBnZXQgc2VydmVyIHVwZGF0ZXMuXHJcbiAgICBjb25zdCB1bndhdGNoZXIgPSBvblZhbHVlKHJlZiwgKCkgPT4geyB9KTtcclxuICAgIHJlcG9TdGFydFRyYW5zYWN0aW9uKHJlZi5fcmVwbywgcmVmLl9wYXRoLCB0cmFuc2FjdGlvblVwZGF0ZSwgcHJvbWlzZUNvbXBsZXRlLCB1bndhdGNoZXIsIGFwcGx5TG9jYWxseSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNpbXBsZUxpc3RlbiA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7XHJcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdxJywgeyBwOiBwYXRoU3RyaW5nIH0sIG9uQ29tcGxldGUpO1xyXG59O1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuZWNobyA9IGZ1bmN0aW9uIChkYXRhLCBvbkVjaG8pIHtcclxuICAgIHRoaXMuc2VuZFJlcXVlc3QoJ2VjaG8nLCB7IGQ6IGRhdGEgfSwgb25FY2hvKTtcclxufTtcclxuLy8gUmVhbFRpbWVDb25uZWN0aW9uIHByb3BlcnRpZXMgdGhhdCB3ZSB1c2UgaW4gdGVzdHMuXHJcbkNvbm5lY3Rpb247XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IGhpamFja0hhc2ggPSBmdW5jdGlvbiAobmV3SGFzaCkge1xyXG4gICAgY29uc3Qgb2xkUHV0ID0gUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dDtcclxuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xyXG4gICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaGFzaCA9IG5ld0hhc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2xkUHV0LmNhbGwodGhpcywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0ID0gb2xkUHV0O1xyXG4gICAgfTtcclxufTtcclxuUmVwb0luZm87XHJcbi8qKlxyXG4gKiBGb3JjZXMgdGhlIFJlcG9NYW5hZ2VyIHRvIGNyZWF0ZSBSZXBvcyB0aGF0IHVzZSBSZWFkb25seVJlc3RDbGllbnQgaW5zdGVhZCBvZiBQZXJzaXN0ZW50Q29ubmVjdGlvbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBmb3JjZVJlc3RDbGllbnQgPSBmdW5jdGlvbiAoZm9yY2VSZXN0Q2xpZW50KSB7XHJcbiAgICByZXBvTWFuYWdlckZvcmNlUmVzdENsaWVudChmb3JjZVJlc3RDbGllbnQpO1xyXG59O1xuXG4vKipcclxuICogRmlyZWJhc2UgUmVhbHRpbWUgRGF0YWJhc2VcclxuICpcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3RlckRhdGFiYXNlKCk7XG5cbmV4cG9ydCB7IERhdGFTbmFwc2hvdCwgRGF0YWJhc2UsIE9uRGlzY29ubmVjdCwgUXVlcnlDb25zdHJhaW50LCBUcmFuc2FjdGlvblJlc3VsdCwgUXVlcnlJbXBsIGFzIF9RdWVyeUltcGwsIFF1ZXJ5UGFyYW1zIGFzIF9RdWVyeVBhcmFtcywgUmVmZXJlbmNlSW1wbCBhcyBfUmVmZXJlbmNlSW1wbCwgZm9yY2VSZXN0Q2xpZW50IGFzIF9URVNUX0FDQ0VTU19mb3JjZVJlc3RDbGllbnQsIGhpamFja0hhc2ggYXMgX1RFU1RfQUNDRVNTX2hpamFja0hhc2gsIHJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwIGFzIF9yZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCwgc2V0U0RLVmVyc2lvbiBhcyBfc2V0U0RLVmVyc2lvbiwgdmFsaWRhdGVQYXRoU3RyaW5nIGFzIF92YWxpZGF0ZVBhdGhTdHJpbmcsIHZhbGlkYXRlV3JpdGFibGVQYXRoIGFzIF92YWxpZGF0ZVdyaXRhYmxlUGF0aCwgY2hpbGQsIGNvbm5lY3REYXRhYmFzZUVtdWxhdG9yLCBlbmFibGVMb2dnaW5nLCBlbmRBdCwgZW5kQmVmb3JlLCBlcXVhbFRvLCBmb3JjZUxvbmdQb2xsaW5nLCBmb3JjZVdlYlNvY2tldHMsIGdldCwgZ2V0RGF0YWJhc2UsIGdvT2ZmbGluZSwgZ29PbmxpbmUsIGluY3JlbWVudCwgbGltaXRUb0ZpcnN0LCBsaW1pdFRvTGFzdCwgb2ZmLCBvbkNoaWxkQWRkZWQsIG9uQ2hpbGRDaGFuZ2VkLCBvbkNoaWxkTW92ZWQsIG9uQ2hpbGRSZW1vdmVkLCBvbkRpc2Nvbm5lY3QsIG9uVmFsdWUsIG9yZGVyQnlDaGlsZCwgb3JkZXJCeUtleSwgb3JkZXJCeVByaW9yaXR5LCBvcmRlckJ5VmFsdWUsIHB1c2gsIHF1ZXJ5LCByZWYsIHJlZkZyb21VUkwsIHJlbW92ZSwgcnVuVHJhbnNhY3Rpb24sIHNlcnZlclRpbWVzdGFtcCwgc2V0LCBzZXRQcmlvcml0eSwgc2V0V2l0aFByaW9yaXR5LCBzdGFydEFmdGVyLCBzdGFydEF0LCB1cGRhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),

/***/ 11:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataSnapshot\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.DataSnapshot),\n/* harmony export */   \"Database\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.Database),\n/* harmony export */   \"OnDisconnect\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.OnDisconnect),\n/* harmony export */   \"QueryConstraint\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.QueryConstraint),\n/* harmony export */   \"TransactionResult\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.TransactionResult),\n/* harmony export */   \"_QueryImpl\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._QueryImpl),\n/* harmony export */   \"_QueryParams\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._QueryParams),\n/* harmony export */   \"_ReferenceImpl\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._ReferenceImpl),\n/* harmony export */   \"_TEST_ACCESS_forceRestClient\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._TEST_ACCESS_forceRestClient),\n/* harmony export */   \"_TEST_ACCESS_hijackHash\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._TEST_ACCESS_hijackHash),\n/* harmony export */   \"_repoManagerDatabaseFromApp\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._repoManagerDatabaseFromApp),\n/* harmony export */   \"_setSDKVersion\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._setSDKVersion),\n/* harmony export */   \"_validatePathString\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._validatePathString),\n/* harmony export */   \"_validateWritablePath\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__._validateWritablePath),\n/* harmony export */   \"child\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.child),\n/* harmony export */   \"connectDatabaseEmulator\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.connectDatabaseEmulator),\n/* harmony export */   \"enableLogging\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.enableLogging),\n/* harmony export */   \"endAt\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.endAt),\n/* harmony export */   \"endBefore\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.endBefore),\n/* harmony export */   \"equalTo\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.equalTo),\n/* harmony export */   \"forceLongPolling\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.forceLongPolling),\n/* harmony export */   \"forceWebSockets\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.forceWebSockets),\n/* harmony export */   \"get\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.get),\n/* harmony export */   \"getDatabase\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.getDatabase),\n/* harmony export */   \"goOffline\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.goOffline),\n/* harmony export */   \"goOnline\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.goOnline),\n/* harmony export */   \"increment\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.increment),\n/* harmony export */   \"limitToFirst\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.limitToFirst),\n/* harmony export */   \"limitToLast\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.limitToLast),\n/* harmony export */   \"off\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.off),\n/* harmony export */   \"onChildAdded\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildAdded),\n/* harmony export */   \"onChildChanged\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildChanged),\n/* harmony export */   \"onChildMoved\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildMoved),\n/* harmony export */   \"onChildRemoved\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onChildRemoved),\n/* harmony export */   \"onDisconnect\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onDisconnect),\n/* harmony export */   \"onValue\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue),\n/* harmony export */   \"orderByChild\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByChild),\n/* harmony export */   \"orderByKey\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByKey),\n/* harmony export */   \"orderByPriority\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByPriority),\n/* harmony export */   \"orderByValue\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.orderByValue),\n/* harmony export */   \"push\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.push),\n/* harmony export */   \"query\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.query),\n/* harmony export */   \"ref\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref),\n/* harmony export */   \"refFromURL\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.refFromURL),\n/* harmony export */   \"remove\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.remove),\n/* harmony export */   \"runTransaction\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.runTransaction),\n/* harmony export */   \"serverTimestamp\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp),\n/* harmony export */   \"set\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.set),\n/* harmony export */   \"setPriority\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.setPriority),\n/* harmony export */   \"setWithPriority\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.setWithPriority),\n/* harmony export */   \"startAfter\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.startAfter),\n/* harmony export */   \"startAt\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.startAt),\n/* harmony export */   \"update\": () => (/* reexport safe */ _firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)\n/* harmony export */ });\n/* harmony import */ var _firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWEuLy4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvZXNtL2luZGV4LmVzbS5qcz8yNzlkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJ0BmaXJlYmFzZS9kYXRhYmFzZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ })

}]);